1
00:00:04,830 --> 00:00:06,850
хорошо, доброе утро, мы пойдем

2
00:00:06,850 --> 00:00:08,138
вперед и начнем

3
00:00:08,138 --> 00:00:11,170
домашнее задание 1 нужно сдать сегодня, если вы не

4
00:00:11,170 --> 00:00:13,990
используете последние дни, а домашнее

5
00:00:13,990 --> 00:00:16,149
задание 2 будет выпущено сегодня

6
00:00:16,149 --> 00:00:19,180


7
00:00:19,180 --> 00:00:20,740


8
00:00:20,740 --> 00:00:22,600
начните освещать этот материал сегодня, а

9
00:00:22,600 --> 00:00:24,010
затем мы продолжим на следующей неделе глубокое

10
00:00:24,010 --> 00:00:26,470
обучение глубокое обучение не является

11
00:00:26,470 --> 00:00:28,570
обязательным условием для этого класса, поэтому мы

12
00:00:28,570 --> 00:00:30,370
собираемся выпустить учебник по

13
00:00:30,370 --> 00:00:31,060
тензорному потоку

14
00:00:31,060 --> 00:00:34,329
позже на этой неделе, а затем на следующей неделе мы

15
00:00:34,329 --> 00:00:36,190
также  сеансы имеют возможность

16
00:00:36,190 --> 00:00:37,719
углубиться в некоторые дополнительные сведения о

17
00:00:37,719 --> 00:00:39,909
глубоком обучении, от вас не ожидается, что вы

18
00:00:39,909 --> 00:00:41,019
будете экспертом в этом, но вам нужно знать

19
00:00:41,019 --> 00:00:42,219
достаточно, чтобы делать

20
00:00:42,219 --> 00:00:43,749
домашние задания и выполнять аппроксимацию функции, которую

21
00:00:43,749 --> 00:00:46,030
мы будем предполагать, что

22
00:00:46,030 --> 00:00:47,489
вы хорошо знакомы с такими вещами, как

23
00:00:47,489 --> 00:00:49,749
градиентный спуск и получение производных,

24
00:00:49,749 --> 00:00:50,559
и такими вещами, как

25
00:00:50,559 --> 00:00:52,989
тензорный поток и другие пакеты, которые могут сделать

26
00:00:52,989 --> 00:00:54,370
это автоматически для вас, но вы

27
00:00:54,370 --> 00:00:55,719
должны быть знакомы с общим

28
00:00:55,719 --> 00:00:58,510
процессом, в котором это происходит.  прежде чем мы

29
00:00:58,510 --> 00:01:00,039
продолжим, тогда могут возникнуть какие-либо

30
00:01:00,039 --> 00:01:05,890
вопросы по логистике, хорошо, давайте продолжим и начнем,

31
00:01:05,890 --> 00:01:06,430


32
00:01:06,430 --> 00:01:09,160
как вы можете видеть, я немного потерял голос,

33
00:01:09,160 --> 00:01:10,420
он возвращается, но мы

34
00:01:10,420 --> 00:01:12,790
посмотрим, как мы пойдем, и если это станет слишком сложным

35
00:01:12,790 --> 00:01:16,030
и ударит, и мы  все в

36
00:01:16,030 --> 00:01:17,200
порядке, поэтому то, о чем мы говорили

37
00:01:17,200 --> 00:01:21,520
до сих пор, - это думать о том, чтобы научиться

38
00:01:21,520 --> 00:01:23,380
оценивать политику и последовательные

39
00:01:23,380 --> 00:01:25,180
случаи принятия решений, а также быть способным

40
00:01:25,180 --> 00:01:27,610
принимать решения, все это когда

41
00:01:27,610 --> 00:01:29,470
мир неизвестен, и что я имею в виду  это то

42
00:01:29,470 --> 00:01:31,420
, что нам не дается заранее

43
00:01:31,420 --> 00:01:34,570
модель динамики или модель вознаграждения, и

44
00:01:34,570 --> 00:01:35,950
то, о чем мы собираемся начать говорить

45
00:01:35,950 --> 00:01:39,210
сегодня, - это приближение функции ценности,

46
00:01:39,210 --> 00:01:41,950
просто чтобы я действительно знал, кто из тех,

47
00:01:41,950 --> 00:01:43,630
кто вы видели это раньше  мы видели

48
00:01:43,630 --> 00:01:45,100
некоторую форму аппроксимации функции ценности,

49
00:01:45,100 --> 00:01:47,800
хорошо, так что пара человек,

50
00:01:47,800 --> 00:01:51,910
но большинство людей знают, что я, поэтому, когда я говорю

51
00:01:51,910 --> 00:01:53,620
аппроксимация функции ценности, я имею в виду

52
00:01:53,620 --> 00:01:55,150
, что до сих пор мы думали о

53
00:01:55,150 --> 00:01:57,370
областях, где мы склонны иметь конечное

54
00:01:57,370 --> 00:01:59,590
множество  состояний и действий  и где с

55
00:01:59,590 --> 00:02:02,440
вычислительной точки зрения и памяти

56
00:02:02,440 --> 00:02:05,350
возможно просто записать таблицу, чтобы отслеживать,

57
00:02:05,350 --> 00:02:07,720
каково значение состояний или

58
00:02:07,720 --> 00:02:10,179
значение пар состояний-действий, или что мы

59
00:02:10,179 --> 00:02:11,739
могли бы представить себе запись таблицы, чтобы

60
00:02:11,739 --> 00:02:13,720
явно записывать модели

61
00:02:13,720 --> 00:02:16,269
модели вознаграждения.  в модели динамики

62
00:02:16,269 --> 00:02:18,489
многие проблемы реального мира имеют огромные

63
00:02:18,489 --> 00:02:21,099
пространства состояний и действий, поэтому, если вы думаете

64
00:02:21,099 --> 00:02:23,620
о таких вещах, как игры Atari, о которых

65
00:02:23,620 --> 00:02:24,879
мы можем спорить, является ли

66
00:02:24,879 --> 00:02:26,230
это проблемой реального мира, но это,

67
00:02:26,230 --> 00:02:28,750
безусловно, сложная проблема,

68
00:02:28,750 --> 00:02:30,459
пространство состояний, которое мы обсуждали.

69
00:02:30,459 --> 00:02:32,349
начало действительно через набор пикселей,

70
00:02:32,349 --> 00:02:34,180
так что это будет огромное пространство,

71
00:02:34,180 --> 00:02:35,500
и мы не сможем

72
00:02:35,500 --> 00:02:38,739
записать это в виде таблицы, и поэтому в этих

73
00:02:38,739 --> 00:02:40,599
случаях нам придется выйти за

74
00:02:40,599 --> 00:02:42,400
рамки этого  табличное представление и

75
00:02:42,400 --> 00:02:44,019
действительно подумать об этой проблеме

76
00:02:44,019 --> 00:02:46,930
обобщения, поэтому нам нужно будет

77
00:02:46,930 --> 00:02:48,519
иметь возможность сказать, что мы хотим иметь возможность принимать

78
00:02:48,519 --> 00:02:50,620
решения и учиться принимать решения, которые

79
00:02:50,620 --> 00:02:51,790
нам понадобятся, чтобы иметь возможность

80
00:02:51,790 --> 00:02:53,709
обобщать  ze из нашего предыдущего опыта, так

81
00:02:53,709 --> 00:02:55,599
что даже если мы окажемся в паре состояний и действий,

82
00:02:55,599 --> 00:02:57,730
которую мы никогда точно не видели

83
00:02:57,730 --> 00:02:59,530
раньше, это похоже на немного другой

84
00:02:59,530 --> 00:03:00,879
набор пикселей, чем мы когда-либо видели

85
00:03:00,879 --> 00:03:01,510
раньше

86
00:03:01,510 --> 00:03:02,739
, мы все равно сможем

87
00:03:02,739 --> 00:03:04,419
принимать правильные решения, и это

88
00:03:04,419 --> 00:03:09,400
потребует обобщения, поэтому сегодня мы

89
00:03:09,400 --> 00:03:10,629
собираемся поговорить о том, чтобы

90
00:03:10,629 --> 00:03:12,250
начать с аппроксимации функции ценности

91
00:03:12,250 --> 00:03:15,159
для прогнозирования, а затем

92
00:03:15,159 --> 00:03:18,730
поговорить об управлении и той

93
00:03:18,730 --> 00:03:20,500
ключевой идее, о которой мы начнем

94
00:03:20,500 --> 00:03:22,269
говорить в  этот случай заключается в том, что мы

95
00:03:22,269 --> 00:03:24,639
собираемся представлять функцию значения действия состояния

96
00:03:24,639 --> 00:03:27,400
с помощью параметризованной

97
00:03:27,400 --> 00:03:30,609
функции, поэтому мы можем думать о том, что теперь

98
00:03:30,609 --> 00:03:32,590
есть функция, в которую мы вводим состояние

99
00:03:32,590 --> 00:03:34,810
и вместо того, чтобы искать в таблице,

100
00:03:34,810 --> 00:03:36,849
каково его значение  вместо этого у

101
00:03:36,849 --> 00:03:38,949
нас будут некоторые параметры здесь, так что

102
00:03:38,949 --> 00:03:42,870
это может быть глубокая нейронная сеть,

103
00:03:43,079 --> 00:03:49,659
это может быть многочлен, это

104
00:03:49,659 --> 00:03:50,919
могут быть всевозможные приближения различных функций,

105
00:03:50,919 --> 00:03:52,659
но ключ здесь в том, что

106
00:03:52,659 --> 00:03:54,909
у нас есть некоторые параметры  которые позволяют нам

107
00:03:54,909 --> 00:03:57,459
сказать для любого входного состояния, что является

108
00:03:57,459 --> 00:04:00,669
значением, и, как мы видели ранее, мы

109
00:04:00,669 --> 00:04:02,169
собираемся как бы идти вперед и назад

110
00:04:02,169 --> 00:04:03,970
между размышлениями о наличии

111
00:04:03,970 --> 00:04:06,549
функции значения состояния и функции значения действия состояния

112
00:04:06,549 --> 00:04:09,040
и ключевой вещью сейчас  заключается в том, что

113
00:04:09,040 --> 00:04:10,989
у нас есть эти параметры, и мы в

114
00:04:10,989 --> 00:04:12,250
основном будем говорить об этих

115
00:04:12,250 --> 00:04:15,280
параметрах с точки зрения W, так что вы можете

116
00:04:15,280 --> 00:04:19,060
думать, что W — это просто вектор hi,

117
00:04:19,060 --> 00:04:20,738
где этот вектор может быть

118
00:04:20,738 --> 00:04:22,210
параметрами глубокой нейронной сети

119
00:04:22,210 --> 00:04:25,409
или может быть  что-то гораздо более простое,

120
00:04:26,890 --> 00:04:29,630
так что опять же, вы знаете, почему мы хотим это сделать

121
00:04:29,630 --> 00:04:31,100
и какие формы

122
00:04:31,100 --> 00:04:32,630
приближений мы могли бы начать думать,

123
00:04:32,630 --> 00:04:34,730
поэтому мы просто не хотим

124
00:04:34,730 --> 00:04:36,410
явно хранить обучение для каждой

125
00:04:36,410 --> 00:04:38,870
отдельной пары действий состояния, поэтому мы не  нам

126
00:04:38,870 --> 00:04:40,010
не нужно делать это с точки зрения

127
00:04:40,010 --> 00:04:41,780
модели динамики обучения, нам не нужно делать это

128
00:04:41,780 --> 00:04:43,940
с точки зрения функции

129
00:04:43,940 --> 00:04:45,770
ценности или функции ценности действия состояния или даже с точки

130
00:04:45,770 --> 00:04:47,960
зрения политики, мне нужно будет уметь

131
00:04:47,960 --> 00:04:49,310
обобщать, чтобы  мы можем понять,

132
00:04:49,310 --> 00:04:51,740
что наш  агенты, наши алгоритмы могут

133
00:04:51,740 --> 00:04:54,470
определить хорошие политики для

134
00:04:54,470 --> 00:04:56,330
таких огромных пространств состояний и пространств действий,

135
00:04:56,330 --> 00:04:58,250
поэтому нам нужны эти компактные

136
00:04:58,250 --> 00:05:03,080
представления, поэтому, как только мы это сделаем, мы

137
00:05:03,080 --> 00:05:04,670
получим множество различных преимуществ,

138
00:05:04,670 --> 00:05:06,380
которые мы также столкнемся с потенциальными

139
00:05:06,380 --> 00:05:08,600
проблемами, поэтому  мы уменьшим

140
00:05:08,600 --> 00:05:10,130
объем памяти, который нам нужен для хранения всех

141
00:05:10,130 --> 00:05:11,420
этих вещей, мы уменьшим количество

142
00:05:11,420 --> 00:05:13,760
необходимых вычислений, и, возможно, мы

143
00:05:13,760 --> 00:05:15,920
сможем уменьшить опыт, и поэтому я

144
00:05:15,920 --> 00:05:18,710
имею в виду, сколько данных

145
00:05:18,710 --> 00:05:21,110
нужно нашему агенту для обработки.  собирать, чтобы

146
00:05:21,110 --> 00:05:23,420
научиться принимать правильные решения, так что

147
00:05:23,420 --> 00:05:25,280
это действительно представление о том, сколько

148
00:05:25,280 --> 00:05:34,460
данных необходимо сейчас, я просто хочу подчеркнуть

149
00:05:34,460 --> 00:05:36,260
здесь, что вы знаете, что могут быть

150
00:05:36,260 --> 00:05:38,650
очень плохие, очень плохие приближения,

151
00:05:38,650 --> 00:05:41,660
и они могут быть отличными с точки зрения  не

152
00:05:41,660 --> 00:05:43,250
оставляя много данных и не требуя

153
00:05:43,250 --> 00:05:44,720
много вычислений и не требуя много

154
00:05:44,720 --> 00:05:46,580
памяти, но они могут просто не позволить

155
00:05:46,580 --> 00:05:50,090
вам представлять очень хорошие политики, поэтому

156
00:05:50,090 --> 00:05:52,580
эти варианты представления

157
00:05:52,580 --> 00:05:55,130
определяют в сортировке  классов гипотез

158
00:05:55,130 --> 00:05:57,050
они определяют пространства, в которых вы

159
00:05:57,050 --> 00:05:59,270
не можете представить политику и функции ценности,

160
00:05:59,270 --> 00:06:01,460
и, таким образом, вы могли бы

161
00:06:01,460 --> 00:06:02,750
иметь здесь своего рода компромисс дисперсии смещения и компромисс

162
00:06:02,750 --> 00:06:04,700
аппроксимации функции

163
00:06:04,700 --> 00:06:06,950
в том смысле, что если у вас есть

164
00:06:06,950 --> 00:06:09,080
очень маленькое представление, вам

165
00:06:09,080 --> 00:06:10,580
не потребуется очень много данных, чтобы научиться

166
00:06:10,580 --> 00:06:13,010
вписывать его, но тогда оно также не будет

167
00:06:13,010 --> 00:06:14,960
иметь очень хороших возможностей с точки зрения

168
00:06:14,960 --> 00:06:16,640
представления сложных функций

169
00:06:16,640 --> 00:06:20,330
или политик значений, поэтому в качестве простого примера мы

170
00:06:20,330 --> 00:06:22,220
могли бы предположить, что наш агент  всегда находится в

171
00:06:22,220 --> 00:06:24,110
одном и том же состоянии все время, вы знаете, что все

172
00:06:24,110 --> 00:06:26,240
кадры видеоигры всегда идентичны,

173
00:06:26,240 --> 00:06:28,070
и это действительно сжатое

174
00:06:28,070 --> 00:06:30,890
представление, вы знаете, что у нас есть только одно

175
00:06:30,890 --> 00:06:33,050
состояние, но это не позволит нам

176
00:06:33,050 --> 00:06:34,370
научиться принимать разные решения в

177
00:06:34,370 --> 00:06:35,960
разных частях игры, поэтому  это не

178
00:06:35,960 --> 00:06:37,710
позволит нам получить высокую награду,

179
00:06:37,710 --> 00:06:39,419
поэтому, как правило, будет

180
00:06:39,419 --> 00:06:41,729
компромисс между емкостью

181
00:06:41,729 --> 00:06:44,250
представления, которое мы выбираем, так что

182
00:06:44,250 --> 00:06:52,919
репрезентативная способность ver  sus все

183
00:06:52,919 --> 00:06:54,570
эти другие вещи, которые мы хотели бы по сравнению с

184
00:06:54,570 --> 00:07:01,560
вычислением памяти и данными теперь

185
00:07:01,560 --> 00:07:03,389
есть не всегда, иногда кому-то везет,

186
00:07:03,389 --> 00:07:05,430
и вы можете выбрать что-то

187
00:07:05,430 --> 00:07:07,590
очень-очень компактное, и этого все же

188
00:07:07,590 --> 00:07:10,050
достаточно для представления свойств, которые

189
00:07:10,050 --> 00:07:11,490
вам нужны для его представления, чтобы

190
00:07:11,490 --> 00:07:13,380
сделать  хорошие решения, но мы просто

191
00:07:13,380 --> 00:07:14,639
думаем, что часто существует этот

192
00:07:14,639 --> 00:07:16,229
явный компромисс, и мы часто не

193
00:07:16,229 --> 00:07:18,360
знаем заранее, что является достаточной

194
00:07:18,360 --> 00:07:20,699
репрезентативной способностью для

195
00:07:20,699 --> 00:07:27,419
достижения высокого вознаграждения, да, это более или

196
00:07:27,419 --> 00:07:29,430
менее ортогональное рассмотрение из-

197
00:07:29,430 --> 00:07:32,430
за предвзятости  - компромисс дисперсии в

198
00:07:32,430 --> 00:07:34,470
функциональном названии, да, вы можете

199
00:07:34,470 --> 00:07:35,340
думать об этом как о правильном, это было как

200
00:07:35,340 --> 00:07:36,360
вопрос, является ли это

201
00:07:36,360 --> 00:07:37,620
ортогональным компромиссом своего рода

202
00:07:37,620 --> 00:07:40,050
компромисса дисперсии смещения, который хорошо может дать, это

203
00:07:40,050 --> 00:07:41,849
связано, если вы выберете действительно

204
00:07:41,849 --> 00:07:43,110
ограниченную репрезентативную способность

205
00:07:43,110 --> 00:07:46,770
у вас всегда будет предвзятость, потому

206
00:07:46,770 --> 00:07:47,789
что вы просто не сможете

207
00:07:47,789 --> 00:07:50,580
представить истинную функцию, поэтому она есть, а

208
00:07:50,580 --> 00:07:52,320
затем вы рассмотрите меньшую

209
00:07:52,320 --> 00:07:53,849
дисперсия в течение длительного времени, потому что это

210
00:07:53,849 --> 00:07:55,620
меньшее представление, поэтому оно

211
00:07:55,620 --> 00:07:57,690
связано с этим, если вы использовали

212
00:07:57,690 --> 00:07:59,460
машинное обучение и говорили о таких вещах,

213
00:07:59,460 --> 00:08:01,620
как минимизация структурного риска и

214
00:08:01,620 --> 00:08:03,810
думали о том, как вы выбираете емкость класса вашей модели по

215
00:08:03,810 --> 00:08:05,789
сравнению с тем, сколько данных у вас

216
00:08:05,789 --> 00:08:07,740
есть в терминах  минимизировать ваши тесты,

217
00:08:07,740 --> 00:08:10,470
которые тоже похожи на этот, чтобы вы знали,

218
00:08:10,470 --> 00:08:11,699
как вы находите компромисс между

219
00:08:11,699 --> 00:08:14,130
способностью обобщать и

220
00:08:14,130 --> 00:08:19,229
выразительной силой, хорошо, так что естественный

221
00:08:19,229 --> 00:08:20,880
непосредственный вопрос, который мы начали, я

222
00:08:20,880 --> 00:08:23,070
уже начал намекать на то, что

223
00:08:23,070 --> 00:08:24,949
приближение функции  мы собираемся использовать

224
00:08:24,949 --> 00:08:28,380
есть огромное количество вариантов сегодня

225
00:08:28,380 --> 00:08:30,509
мы только начнем говорить об одном

226
00:08:30,509 --> 00:08:33,029
конкретном наборе, но есть огромное

227
00:08:33,029 --> 00:08:35,130
количество, вероятно, большинство из тех, которые вы можете

228
00:08:35,130 --> 00:08:36,208
придумать, были опробованы с

229
00:08:36,208 --> 00:08:38,039
обучением с подкреплением, так что почти

230
00:08:38,039 --> 00:08:39,479
все, что вы могли сделать  в

231
00:08:39,479 --> 00:08:40,979
обучении с учителем вы также можете попробовать в качестве

232
00:08:40,979 --> 00:08:43,110
аппроксиматора функции для вашей

233
00:08:43,110 --> 00:08:45,660
функции значения могут быть нейронные сети,

234
00:08:45,660 --> 00:08:47,779
глубокие деревья решений или неа  остальные соседи на

235
00:08:47,779 --> 00:08:49,290
вейвлетной основе

236
00:08:49,290 --> 00:08:49,889
много

237
00:08:49,889 --> 00:08:53,279
вещей, которые мы собираемся делать в этом классе,

238
00:08:53,279 --> 00:08:54,899
в основном сосредоточены на вещах, которые

239
00:08:54,899 --> 00:08:56,569
дифференцируемы,

240
00:08:56,569 --> 00:08:59,179
они хороши по ряду причин,

241
00:08:59,179 --> 00:09:02,040
но они, как правило, имеют действительно хорошие

242
00:09:02,040 --> 00:09:03,989
свойства плавной оптимизации, поэтому

243
00:09:03,989 --> 00:09:06,059
их легче оптимизировать.  потому что это

244
00:09:06,059 --> 00:09:07,439
одна из причин, по которой он сосредоточился на

245
00:09:07,439 --> 00:09:09,239
них в этом классе, это не

246
00:09:09,239 --> 00:09:12,779
всегда правильный выбор. Я могу каждый привести

247
00:09:12,779 --> 00:09:14,399
пример того, где для тех из вас,

248
00:09:14,399 --> 00:09:15,929
кто знаком с деревьями решений, где

249
00:09:15,929 --> 00:09:17,339
вы можете захотеть, чтобы дерево решений

250
00:09:17,339 --> 00:09:19,499
представляло либо  ваша функция ценности или

251
00:09:19,499 --> 00:09:25,399
ваша политика, да,

252
00:09:27,020 --> 00:09:29,450
они могут быть

253
00:09:29,450 --> 00:09:38,149
интерпретативными, всезащитными, так что вы только что

254
00:09:38,149 --> 00:09:40,540
сказали, что вы знаете, в зависимости от того, где

255
00:09:40,540 --> 00:09:42,560
вы используете этот вид

256
00:09:42,560 --> 00:09:44,029
политики обучения с подкреплением, это может

257
00:09:44,029 --> 00:09:45,470
быть взаимодействие напрямую с людьми, так

258
00:09:45,470 --> 00:09:46,940
что скажем  это будет использоваться в качестве

259
00:09:46,940 --> 00:09:48,980
поддержки принятия решений для врачей в тех

260
00:09:48,980 --> 00:09:51,050
случаях, когда глубокая нейронная сеть

261
00:09:51,050 --> 00:09:52,520
может быть не очень эффективной с точки зрения

262
00:09:52,520 --> 00:09:53,870
обоснования того, почему вы хотите конкретное

263
00:09:53,870 --> 00:09:56,209
лечение пациента, но если вы используете

264
00:09:56,209 --> 00:09:58,399
дерево решений, они, как правило,

265
00:09:58,399 --> 00:10:02,480
хорошо интерпретируются в зависимости от того, какие

266
00:10:02,480 --> 00:10:03,740
функции вы используете, но часто это довольно

267
00:10:03,740 --> 00:10:05,420
интерпретируемо, и поэтому это может быть

268
00:10:05,420 --> 00:10:07,220
действительно полезно, поэтому размышление о том, какую

269
00:10:07,220 --> 00:10:09,410
аппроксимацию функции вы используете, часто

270
00:10:09,410 --> 00:10:10,910
зависит от того, как вы  мы собираемся использовать его

271
00:10:10,910 --> 00:10:13,190
позже, недавно также была проведена действительно

272
00:10:13,190 --> 00:10:14,899
расширяющаяся и захватывающая работа над

273
00:10:14,899 --> 00:10:16,339
своего рода объяснимыми глубокими нейронными сетями,

274
00:10:16,339 --> 00:10:18,380
где вы можете разместить глубокую нейронную сеть,

275
00:10:18,380 --> 00:10:20,300
а затем вы можете поместить своего рода более простой

276
00:10:20,300 --> 00:10:22,370
аппроксиматор функций сверху, чтобы вы

277
00:10:22,370 --> 00:10:23,990
могли  сначала подогнать вашу глубокую

278
00:10:23,990 --> 00:10:25,160
нейронную сеть, а затем попытаться подогнать

279
00:10:25,160 --> 00:10:26,930
к ней дерево решений, чтобы вы попытались

280
00:10:26,930 --> 00:10:28,190
получить лучшее из обоих миров

281
00:10:28,190 --> 00:10:31,160
супервыразительного функционального аппроксиматора,

282
00:10:31,160 --> 00:10:32,930
а затем еще получить возможность интерпретации

283
00:10:32,930 --> 00:10:35,420
позже, но стоит подумать о своего

284
00:10:35,420 --> 00:10:36,740
рода  приложение, на которое вы смотрите

285
00:10:36,740 --> 00:10:38,089
, потому что разные будут более

286
00:10:38,089 --> 00:10:41,209
подходящими в разных случаях, поэтому вы

287
00:10:41,209 --> 00:10:42,260
знаете, вероятно, два самых популярных

288
00:10:42,260 --> 00:10:45,500
класса:  В наши дни и в RL в целом

289
00:10:45,500 --> 00:10:47,600
используются аппроксимация линейной функции ценности

290
00:10:47,600 --> 00:10:51,320
и глубокие нейронные сети, и мы собираемся

291
00:10:51,320 --> 00:10:52,700
начать с аппроксимации линейной функции ценности

292
00:10:52,700 --> 00:10:54,410
по двум причинам: во-

293
00:10:54,410 --> 00:10:56,300
первых, это, вероятно,

294
00:10:56,300 --> 00:10:57,500
наиболее хорошо изученный

295
00:10:57,500 --> 00:10:59,390
аппроксиматор функции в обучении с подкреплением,

296
00:10:59,390 --> 00:11:02,029
но выше  до последних нескольких лет, а во-вторых

297
00:11:02,029 --> 00:11:03,500
, потому что вы можете думать о глубоких нейронных

298
00:11:03,500 --> 00:11:05,300
сетях как о вычислении некоторого действительно

299
00:11:05,300 --> 00:11:07,370
сложного набора функций, которые вы

300
00:11:07,370 --> 00:11:08,990
затем выполняете аппроксимацию линейной функцией,

301
00:11:08,990 --> 00:11:11,630
по крайней мере, в ряде случаев, так что

302
00:11:11,630 --> 00:11:12,770
это вроде как обеспечивает хорошую основу

303
00:11:12,770 --> 00:11:16,760
для  следующая часть в любом случае хорошо, так

304
00:11:16,760 --> 00:11:18,350
что мы собираемся сделать очень быстрый обзор

305
00:11:18,350 --> 00:11:19,790
градиентного спуска, потому что мы собираемся

306
00:11:19,790 --> 00:11:21,529
использовать его тонну в течение следующих нескольких дней, так что

307
00:11:21,529 --> 00:11:23,480
давайте просто подумаем о какой-либо

308
00:11:23,480 --> 00:11:25,459
общей функции J, которая является

309
00:11:25,459 --> 00:11:27,050
дифференцируемой функцией  вектора параметров

310
00:11:27,050 --> 00:11:30,500
W, поэтому у вас есть некоторый вектор W,

311
00:11:30,500 --> 00:11:31,880
скоро он будет набором линейных весов,

312
00:11:31,880 --> 00:11:35,839
и наша цель — найти параметр W,

313
00:11:35,839 --> 00:11:37,820
который минимизирует нашу целевую функцию

314
00:11:37,820 --> 00:11:39,320
Я не сказал вам, какова целевая

315
00:11:39,320 --> 00:11:40,100
функция,

316
00:11:40,100 --> 00:11:43,490
чтобы найти ее в ближайшее время, поэтому градиент J

317
00:11:43,490 --> 00:11:46,970
от W мы собираемся обозначить как дельта

318
00:11:46,970 --> 00:11:50,329
J от W, и это просто мы берем

319
00:11:50,329 --> 00:11:52,550
производную от него по отношению к

320
00:11:52,550 --> 00:11:55,519
каждому из  параметры внутри

321
00:11:55,519 --> 00:12:08,630
вектора, и поэтому это будет градиент,

322
00:12:08,630 --> 00:12:10,550
и поэтому способ градиентного спуска

323
00:12:10,550 --> 00:12:14,540
для оптимизации функции J от W будет

324
00:12:14,540 --> 00:12:16,459
состоять в том, чтобы вычислить производную или

325
00:12:16,459 --> 00:12:18,680
градиент от нее, а затем переместить

326
00:12:18,680 --> 00:12:20,779
вектор параметров в направлении

327
00:12:20,779 --> 00:12:24,319
градиента, поэтому, если ваши веса и,

328
00:12:24,319 --> 00:12:25,759
как правило, мы собираемся, всегда

329
00:12:25,759 --> 00:12:27,970
предполагается, что веса являются вектором, и

330
00:12:27,970 --> 00:12:30,170
я буду равен вашему предыдущему

331
00:12:30,170 --> 00:12:34,009
значению весов за вычетом некоторой

332
00:12:34,009 --> 00:12:40,490
скорости обучения производной вашей целевой

333
00:12:40,490 --> 00:12:45,949
функции, поэтому мы  вроде как мы просто

334
00:12:45,949 --> 00:12:47,089
вычисляем производную нашей

335
00:12:47,089 --> 00:12:50,029
функции, а затем мы собираемся взять

336
00:12:50,029 --> 00:12:52,040
размер шага и

337
00:12:52,040 --> 00:12:54,649
немного сдвинуть веса наших параметров, а

338
00:12:54,649 --> 00:12:58,279
затем мы будем продолжать, так что если мы сделаем

339
00:12:58,279 --> 00:13:01,550
это достаточное количество раз  мы гарантированно

340
00:13:01,550 --> 00:13:08,689
найдем  локальная оптима, так что предположим,

341
00:13:08,689 --> 00:13:09,980
что да, чтобы они могли встретиться, да,

342
00:13:09,980 --> 00:13:11,779
могут быть некоторые условия для скорости обучения,

343
00:13:11,779 --> 00:13:14,689
но да, если мы сделаем это достаточно,

344
00:13:14,689 --> 00:13:16,130
мы гарантированно доберемся до локальной

345
00:13:16,130 --> 00:13:23,089
оптимы, теперь обратите внимание, что это локально, поэтому, когда

346
00:13:23,089 --> 00:13:24,319
мы начинаем думать  об этом с точки зрения

347
00:13:24,319 --> 00:13:26,540
аполлонов с точки зрения выполнения RL

348
00:13:26,540 --> 00:13:28,069
важно подумать о том, где мы

349
00:13:28,069 --> 00:13:29,569
собираемся сойтись, и собираемся ли мы

350
00:13:29,569 --> 00:13:31,459
сойтись, и я буду говорить об этом больше на

351
00:13:31,459 --> 00:13:33,560
протяжении всего урока, так что это будет что-то

352
00:13:33,560 --> 00:13:35,089
вроде местного  способ для нас попытаться

353
00:13:35,089 --> 00:13:37,759
плавно начать изменять наше

354
00:13:37,759 --> 00:13:39,680
представление параметра функции значения

355
00:13:39,680 --> 00:13:42,380
, чтобы попытаться получить лучшее

356
00:13:42,380 --> 00:13:47,990
приближение к этому, хорошо, так что давайте

357
00:13:47,990 --> 00:13:49,220
подумаем о том, как это будет применяться, если

358
00:13:49,220 --> 00:13:50,809
мы снова пытаемся выполнить оценку политики

359
00:13:50,809 --> 00:13:52,850
оценка политики, если кто-то

360
00:13:52,850 --> 00:13:53,990
дал вам политику,

361
00:13:53,990 --> 00:13:58,700
дал вам сопоставление первого свидания, каково

362
00:13:58,700 --> 00:14:00,980
ваше действие, и это

363
00:14:00,980 --> 00:14:04,130
может быть стохастическим, поэтому это может быть

364
00:14:04,130 --> 00:14:08,060
сопоставление состояний с распределением вероятностей

365
00:14:08,060 --> 00:14:11,390
по действиям, поэтому, но

366
00:14:11,390 --> 00:14:12,740
кто-то дает  У вас есть политика, и что

367
00:14:12,740 --> 00:14:14,060
вы хотите сделать, так это выяснить, какова

368
00:14:14,060 --> 00:14:15,290
ценность этой политики,

369
00:14:15,290 --> 00:14:16,700
какова ожидаемая скидка, сумма

370
00:14:16,700 --> 00:14:18,200
вознаграждений, которые вы получите, следуя этой политике,

371
00:14:18,200 --> 00:14:22,040
поэтому давайте предположим на секунду, что мы

372
00:14:22,040 --> 00:14:24,170
можем нести определенное состояние, а

373
00:14:24,170 --> 00:14:25,550
затем Oracle  просто дал бы нам

374
00:14:25,550 --> 00:14:29,779
значение истинной стоимости полиса, поэтому я, вы

375
00:14:29,779 --> 00:14:31,040
знаете, я спрашиваю вас, как вы знаете,

376
00:14:31,040 --> 00:14:32,450
какова ожидаемая скидка

377
00:14:32,450 --> 00:14:34,640
летнего возвращения, сначала начинающаяся в этой

378
00:14:34,640 --> 00:14:35,420
части комнаты и пытающаяся пройти

379
00:14:35,420 --> 00:14:37,279
к двери по какой-то политике  и

380
00:14:37,279 --> 00:14:39,500
он говорит, что ожидаемое количество шагов со скидкой,

381
00:14:39,500 --> 00:14:40,970
которое вам потребуется, в

382
00:14:40,970 --> 00:14:44,720
среднем равно 30, например, так что

383
00:14:44,720 --> 00:14:46,399
это будет способ, которым Oracle мог бы

384
00:14:46,399 --> 00:14:48,380
вернуть эти пары, и поэтому вы получите что-то

385
00:14:48,380 --> 00:14:52,640
вроде этой пары s V PI of s  а затем

386
00:14:52,640 --> 00:14:54,709
скажем, учитывая, что у нас есть все эти

387
00:14:54,709 --> 00:14:56,330
данные, что мы хотим сделать, так это то, что

388
00:14:56,330 --> 00:14:57,920
мы хотим подогнать функцию, мы хотим, чтобы наша

389
00:14:57,920 --> 00:15:00,110
функция параметризации точно представляла все

390
00:15:00,110 --> 00:15:02,660
эти данные, поэтому мы хотим

391
00:15:02,660 --> 00:15:05,740
найти наилучшее представление в нашем

392
00:15:05,740 --> 00:15:12,200
пространстве sta  пары значений, поэтому, если вы представите

393
00:15:12,200 --> 00:15:13,850
это в контексте стохастического

394
00:15:13,850 --> 00:15:15,320
градиентного спуска, то, что мы

395
00:15:15,320 --> 00:15:17,120
собираемся сделать, это просто попытаться минимизировать

396
00:15:17,120 --> 00:15:21,380
нашу потерю между значением, которое мы

397
00:15:21,380 --> 00:15:23,180
предсказываем, и истинным значением, так что прямо

398
00:15:23,180 --> 00:15:24,529
сейчас представьте, что кто-то дает нам  эти

399
00:15:24,529 --> 00:15:27,020
истинные пары значений s, а затем мы просто

400
00:15:27,020 --> 00:15:28,579
хотим подогнать аппроксиматор функции для соответствия

401
00:15:28,579 --> 00:15:31,610
этим данным, так что это действительно очень похоже на

402
00:15:31,610 --> 00:15:32,829
простое обучение с учителем,

403
00:15:32,829 --> 00:15:35,420
и в целом мы собираемся использовать

404
00:15:35,420 --> 00:15:36,829
среднеквадратичную потерю, и мы вернемся к

405
00:15:36,829 --> 00:15:39,290
это позже, так что среднеквадратичная потеря в

406
00:15:39,290 --> 00:15:40,520
этом случае заключается в том, что мы просто собираемся

407
00:15:40,520 --> 00:15:42,950
сравнить истинное значение с нашим

408
00:15:42,950 --> 00:15:44,899
приблизительным значением, и наше приблизительное

409
00:15:44,899 --> 00:15:48,380
значение здесь параметризуется нашим

410
00:15:48,380 --> 00:15:52,040
вектором параметров, и мы просто

411
00:15:52,040 --> 00:15:55,339
собираемся сделать градиентный спуск, поэтому мы  мы собираемся

412
00:15:55,339 --> 00:15:57,350
вычислить производную нашей целевой

413
00:15:57,350 --> 00:15:59,089
функции, и когда мы вычислим

414
00:15:59,089 --> 00:16:00,470
производную от нее, мы

415
00:16:00,470 --> 00:16:03,230
возьмем размер шага и выполним

416
00:16:03,230 --> 00:16:05,000
здесь стохастический градиентный спуск, что

417
00:16:05,000 --> 00:16:06,350
означает, что мы просто собираемся сэмплировать

418
00:16:06,350 --> 00:16:07,380
градиент,

419
00:16:07,380 --> 00:16:10,170
так что я имею в виду, что если мы

420
00:16:10,170 --> 00:16:12,420
возьмем производную нашей целевой

421
00:16:12,420 --> 00:16:16,740
функции, мы получим

422
00:16:16,740 --> 00:16:29,730
что-то похожее на это, и что

423
00:16:29,730 --> 00:16:31,050
мы собираемся сделать, так это то, что мы собираемся взять

424
00:16:31,050 --> 00:16:32,700
я  собираемся использовать это как сокращение для

425
00:16:32,700 --> 00:16:36,330
обновления весов, мы собираемся

426
00:16:36,330 --> 00:16:39,630
сделать небольшой шаг в направлении

427
00:16:39,630 --> 00:16:44,780
этого, как оценивается для одной точки,

428
00:16:49,160 --> 00:16:52,080
так что теперь нет никаких ожиданий, и

429
00:16:52,080 --> 00:16:56,970
это только для одной точки, так что это

430
00:16:56,970 --> 00:16:58,920
стохастический градиентный спуск  где мы

431
00:16:58,920 --> 00:17:01,380
не пытаемся вычислить среднее значение

432
00:17:01,380 --> 00:17:02,820
этого градиента, мы кунда, мы

433
00:17:02,820 --> 00:17:04,800
пытаемся просто выбрать этот градиент, оцениваемый

434
00:17:04,800 --> 00:17:06,720
в определенных состояниях, и я сказал

435
00:17:06,720 --> 00:17:08,339
вам прямо сейчас, что кто-то дал нам

436
00:17:08,339 --> 00:17:10,530
эти пары состояний и  функция истинного значения,

437
00:17:10,530 --> 00:17:12,599
поэтому вы просто берете одну из этих

438
00:17:12,599 --> 00:17:14,640
пар, вычисляете градиент в этой точке,

439
00:17:14,640 --> 00:17:16,619
а затем обновляете свою волновую функцию и

440
00:17:16,619 --> 00:17:19,079
делаете это много раз, и приятно

441
00:17:19,079 --> 00:17:20,730
то, что ожидаемый стохастический

442
00:17:20,730 --> 00:17:22,560
градиентный спуск такой же, как полное

443
00:17:22,560 --> 00:17:25,079
обновление градиента, поэтому это  га  хорошие

444
00:17:25,079 --> 00:17:27,180
свойства с точки зрения конвергенции, да,

445
00:17:27,180 --> 00:17:28,130
именованный кошелек, пожалуйста,

446
00:17:28,130 --> 00:17:31,230
так что просто подтвердите разумное ожидание в отношении

447
00:17:31,230 --> 00:17:33,270
политики, а не в отношении набора состояний, если

448
00:17:33,270 --> 00:17:34,740
вы говорите, что, возможно, GT - это

449
00:17:34,740 --> 00:17:38,190
единое состояние, так что это касается

450
00:17:38,190 --> 00:17:39,510
распределения состояний, которые вы не знаете.

451
00:17:39,510 --> 00:17:42,330
Ответом на этот вопрос в рамках обсуждения политики было

452
00:17:42,330 --> 00:17:44,130
то, что вы знаете, зачем делать это, а не то, что

453
00:17:44,130 --> 00:17:45,450
означает ожидание в данном случае, в

454
00:17:45,450 --> 00:17:47,040
данном случае это ожидаемое

455
00:17:47,040 --> 00:17:49,290
распределение состояний и значений, которые вы получите в соответствии с

456
00:17:49,290 --> 00:17:52,680
этой политикой, и это важный

457
00:17:52,680 --> 00:17:54,150
момент, который появится позже.

458
00:17:54,150 --> 00:17:56,280
вернемся позже с точки зрения того,

459
00:17:56,280 --> 00:17:57,750
каково распределение данных, с которым

460
00:17:57,750 --> 00:18:02,040
вы столкнетесь в соответствии с политикой,

461
00:18:02,040 --> 00:18:03,510
конечно, вы знаете, на самом деле у нас

462
00:18:03,510 --> 00:18:04,950
нет доступа к Oracle, чтобы

463
00:18:04,950 --> 00:18:06,600
сообщить нам истинную функцию значения  для любого

464
00:18:06,600 --> 00:18:08,520
состояния, если бы мы это сделали, мы бы уже знали

465
00:18:08,520 --> 00:18:09,810
функцию истинного значения, и нам не

466
00:18:09,810 --> 00:18:12,030
нужно было бы делать что-либо еще, поэтому

467
00:18:12,030 --> 00:18:13,650
сейчас мы собираемся поговорить о том, как мы делаем

468
00:18:13,650 --> 00:18:16,860
аппроксимацию свободной от модели функции

469
00:18:16,860 --> 00:18:18,560
, чтобы сделать ваш прогноз e  Оценка

470
00:18:18,560 --> 00:18:21,770
без модели — это

471
00:18:21,770 --> 00:18:26,070
хорошо, поэтому, если мы вернемся к тому,

472
00:18:26,070 --> 00:18:27,390
о чем мы говорили до того, как подумали

473
00:18:27,390 --> 00:18:29,040
либо об этих методах стиля Монте-Карло,

474
00:18:29,040 --> 00:18:32,220
либо об этих методах стиля обучения TD, где

475
00:18:32,220 --> 00:18:35,610
мы могли бы адаптивно изучать онлайн функцию ценности,

476
00:18:35,610 --> 00:18:37,530
чтобы представлять ценность

477
00:18:37,530 --> 00:18:41,280
следования определенному  политики, и мы сделали

478
00:18:41,280 --> 00:18:43,050
это, используя данные, и мы собираемся сделать

479
00:18:43,050 --> 00:18:44,850
то же самое сейчас, за исключением того, что

480
00:18:44,850 --> 00:18:46,500
нам придется всякий раз, когда мы

481
00:18:46,500 --> 00:18:49,830
делаем такой шаг обновления, обновлять

482
00:18:49,830 --> 00:18:51,660
нашу оценку новыми данными, которые мы также

483
00:18:51,660 --> 00:18:52,590
собираемся  должны выполнять аппроксимацию функции,

484
00:18:52,590 --> 00:18:54,920
поэтому вместо

485
00:18:54,920 --> 00:18:57,510
постепенного обновления нашей записи в таблице

486
00:18:57,510 --> 00:18:59,490
о значении состояния теперь мы также

487
00:18:59,490 --> 00:19:01,680
должны действительно выполнять нашу функцию всякий раз, когда мы

488
00:19:01,680 --> 00:19:06,570
получаем новые данные, поэтому, когда мы начнем

489
00:19:06,570 --> 00:19:07,710
делать это, нам нужно будет выбрать

490
00:19:07,710 --> 00:19:10,050
вектор признаков для представления состояния,

491
00:19:10,050 --> 00:19:11,580
позвольте мне просто понять, что это может

492
00:19:11,580 --> 00:19:13,440
означать, поэтому давайте представим, что мы

493
00:19:13,440 --> 00:19:16,140
думаем о роботе и нашем роботе,

494
00:19:16,140 --> 00:19:17,820
что у роботов есть тонны

495
00:19:17,820 --> 00:19:19,560
действительно удивительных датчиков, но давайте  представьте,

496
00:19:19,560 --> 00:19:21,360
что это старая школа, и у нее просто есть

497
00:19:21,360 --> 00:19:24,150
лазерный дальномер, многие лазерные

498
00:19:24,150 --> 00:19:26,280
дальномеры раньше в основном были на 180

499
00:19:26,280 --> 00:19:29,220
градусов, и поэтому вы могли бы получить расстояние

500
00:19:29,220 --> 00:19:31,800
до первого препятствия, которое вы наткнулись на

501
00:19:31,800 --> 00:19:35,160
все эти 180 градусов, так что, может быть, здесь

502
00:19:35,160 --> 00:19:38,160
это как два фута  и это одна целая

503
00:19:38,160 --> 00:19:41,610
пять футов, это семь футов, и это как

504
00:19:41,610 --> 00:19:43,350
бы дает вам приблизительное представление о том,

505
00:19:43,350 --> 00:19:47,280
как выглядит стена, например,

506
00:19:47,280 --> 00:19:49,320
вот наш робот, который он дает, на нем есть

507
00:19:49,320 --> 00:19:50,550
датчик, который является лазерным

508
00:19:50,550 --> 00:19:51,900
дальномером, и он сообщает нам

509
00:19:51,900 --> 00:19:53,670
расстояние  ко всем стенам, и таким образом, каким

510
00:19:53,670 --> 00:19:55,470
будет это представление функции в

511
00:19:55,470 --> 00:19:57,780
этом случае, это было бы совсем недавно для

512
00:19:57,780 --> 00:19:59,070
каждой из этих ста восьмидесяти

513
00:19:59,070 --> 00:20:02,610
градусов, какое расстояние в одном

514
00:20:02,610 --> 00:20:07,410
градусе степени, которое является примером

515
00:20:07,410 --> 00:20:10,800
представления функции сейчас, почему это

516
00:20:10,800 --> 00:20:12,690
звучит как красиво  хорошо, это может быть

517
00:20:12,690 --> 00:20:13,890
немного примитивно, но в целом

518
00:20:13,890 --> 00:20:15,870
довольно хорошее представление функций, но в

519
00:20:15,870 --> 00:20:17,810
чем проблема, ну,

520
00:20:17,810 --> 00:20:21,060
вероятно, это не Марков, поэтому во многих

521
00:20:21,060 --> 00:20:24,210
зданиях есть коридоры, которые могли бы

522
00:20:24,210 --> 00:20:26,460
Вы знаете, что слева от меня и справа от меня

523
00:20:26,460 --> 00:20:29,490
есть стена примерно в двух футах от

524
00:20:29,490 --> 00:20:30,930
меня, а затем передо мной ничего нет, по крайней мере,

525
00:20:30,930 --> 00:20:33,580
четыре, возможно, до моего лазерного дальномера,

526
00:20:33,580 --> 00:20:35,739
скажите, что вы знаете, вне досягаемости, и это было

527
00:20:35,739 --> 00:20:37,779
бы верно для многих разных частей

528
00:20:37,779 --> 00:20:39,549
один и тот же коридор, и это было бы верно для

529
00:20:39,549 --> 00:20:41,110
многих разных коридоров, и поэтому было

530
00:20:41,110 --> 00:20:43,119
бы много частичного наложения имен, так что это

531
00:20:43,119 --> 00:20:44,590
представление функции, которое, вероятно

532
00:20:44,590 --> 00:20:46,659
, не является Markoff, но может быть

533
00:20:46,659 --> 00:20:48,489
разумным, может быть разумным,

534
00:20:48,489 --> 00:20:50,559
на котором можно обусловливать решения, возможно  если

535
00:20:50,559 --> 00:20:51,610
вы находитесь в середине коридора, и

536
00:20:51,610 --> 00:20:52,659
это выглядит так, что вы всегда

537
00:20:52,659 --> 00:20:55,360
просто хотите идти вперед, это

538
00:20:55,360 --> 00:20:56,679
пример типа представления функции

539
00:20:56,679 --> 00:20:59,289
и еще раз просто подчеркивает

540
00:20:59,289 --> 00:21:01,149
тот момент, что выбор представления функции в

541
00:21:01,149 --> 00:21:02,769
конечном итоге будет действительно

542
00:21:02,769 --> 00:21:05,710
важно, и для тех из вас, кто

543
00:21:05,710 --> 00:21:06,970
посещал занятия по глубокому обучению,

544
00:21:06,970 --> 00:21:08,169
вы, вероятно, уже слышали это, но

545
00:21:08,169 --> 00:21:10,210
это как бы до глубокого обучения,

546
00:21:10,210 --> 00:21:11,950
там часто не было большого объема

547
00:21:11,950 --> 00:21:13,359
работы '  еще предстоит проделать огромный объем работы по

548
00:21:13,359 --> 00:21:15,009
разработке признаков, чтобы выяснить,

549
00:21:15,009 --> 00:21:16,480
как правильно записывать ваше

550
00:21:16,480 --> 00:21:18,369
пространство состояний, чтобы вы могли делать

551
00:21:18,369 --> 00:21:20,559
прогнозы или принимать решения, и одна

552
00:21:20,559 --> 00:21:21,519
из приятных особенностей глубоких нейронных

553
00:21:21,519 --> 00:21:24,009
сетей заключается в том, что они как бы отталкивают назад.

554
00:21:24,009 --> 00:21:25,779
эта проблема выбора функции, поэтому вы

555
00:21:25,779 --> 00:21:27,399
можете использовать вход датчика действительно большого размера,

556
00:21:27,399 --> 00:21:29,679
а затем выполнять меньше ручной

557
00:21:29,679 --> 00:21:32,200
настройки, так что я имею в виду под хорошей ручной настройкой,

558
00:21:32,200 --> 00:21:34,029
в этом случае вы знаете, что можете

559
00:21:34,029 --> 00:21:36,639
использовать необработанные функции о том, как далеко вы

560
00:21:36,639 --> 00:21:38,590
находитесь на каждом  из этих ста

561
00:21:38,590 --> 00:21:40,539
восьмидесяти градусов, или вы можете представить, что у вас

562
00:21:40,539 --> 00:21:42,399
есть абстрактные функции более высокого уровня, такие как

563
00:21:42,399 --> 00:21:43,899
попытка понять, есть ли

564
00:21:43,899 --> 00:21:46,029
углы, поэтому вы могли бы уже выполнить

565
00:21:46,029 --> 00:21:48,279
некоторую предварительную обработку этих необработанных данных, чтобы

566
00:21:48,279 --> 00:21:49,989
выяснить, какие функции, по вашему мнению, могут

567
00:21:49,989 --> 00:21:51,129
иметь значение, если вы  вы собираетесь принимать

568
00:21:51,129 --> 00:21:53,649
решения, и проблема с

569
00:21:53,649 --> 00:21:55,269
этим заключается в том, что если вы

570
00:21:55,269 --> 00:21:56,499
выберете неправильный набор, вы не сможете

571
00:21:56,499 --> 00:21:58,570
принимать решения, которые хотите, да, сначала имя,

572
00:21:58,570 --> 00:22:00,929
пожалуйста,

573
00:22:08,030 --> 00:22:10,610
да  поэтому вопрос: могу ли я уточнить, почему

574
00:22:10,610 --> 00:22:13,700
это не Марков I, если у вас просто есть

575
00:22:13,700 --> 00:22:16,310
180 градусов для робота, если вы думаете

576
00:22:16,310 --> 00:22:19,970
о чем-то, скажем, о длинном коридоре

577
00:22:19,970 --> 00:22:23,180
, скажем, это этаж один, это

578
00:22:23,180 --> 00:22:27,260
этаж - например, в воротах, так что если у

579
00:22:27,260 --> 00:22:28,550
вас есть  ваш маленький робот, который

580
00:22:28,550 --> 00:22:30,740
идет и направляет свой лазерный

581
00:22:30,740 --> 00:22:33,320
дальномер, он пытается сказать, что это

582
00:22:33,320 --> 00:22:36,560
расстояние до всех вещей, которые вы

583
00:22:36,560 --> 00:22:37,880
не сможете различить с помощью

584
00:22:37,880 --> 00:22:39,740
этого представления, находитесь ли вы на

585
00:22:39,740 --> 00:22:43,220
этаже 1 или на этаже 2, потому что ваша

586
00:22:43,220 --> 00:22:44,450
непосредственная  показания датчика будут

587
00:22:44,450 --> 00:22:46,430
выглядеть идентичными, и на самом деле

588
00:22:46,430 --> 00:22:47,360
вы не можете сказать, где вы находитесь в

589
00:22:47,360 --> 00:22:51,220
этом коридоре по его пути, да, так что

590
00:22:51,220 --> 00:22:54,620
мы можем обобщить, что если у вас есть

591
00:22:54,620 --> 00:22:59,230
постулат, то мы говорим, что это нормальный

592
00:22:59,230 --> 00:23:01,610
вопрос, можем ли мы  обобщить и сказать, что если

593
00:23:01,610 --> 00:23:03,290
у нас есть частичное наложение псевдонимов, это не Марков,

594
00:23:03,290 --> 00:23:05,900
да, как я имею в виду, вы можете изменить

595
00:23:05,900 --> 00:23:07,580
представление состояния на Марковское,

596
00:23:07,580 --> 00:23:10,160
включив историю, и тогда каждое

597
00:23:10,160 --> 00:23:11,840
отдельное наблюдение будет иметь псевдоним,

598
00:23:11,840 --> 00:23:13,610
но все состояние представляет  отправка

599
00:23:13,610 --> 00:23:15,260
не будет, но в целом я думаю, что если у вас

600
00:23:15,260 --> 00:23:16,910
есть государственное представительство, для которого

601
00:23:16,910 --> 00:23:19,810
есть Lea C, и это не Марков,

602
00:23:19,810 --> 00:23:21,830
все равно может быть, что вы все еще можете

603
00:23:21,830 --> 00:23:23,270
довольно хорошо с этим представлением,

604
00:23:23,270 --> 00:23:24,710
а может и нет, но просто хорошо

605
00:23:24,710 --> 00:23:26,540
знать  С точки зрения методов,

606
00:23:26,540 --> 00:23:30,980
можно применить хорошие вопросы, так что

607
00:23:30,980 --> 00:23:32,180
давайте подумаем о том, чтобы сделать это с

608
00:23:32,180 --> 00:23:35,210
приближением линейной функции значения, так что

609
00:23:35,210 --> 00:23:36,500
я имею в виду под линейной аппроксимацией функции значения,

610
00:23:36,500 --> 00:23:38,180
это означает, что у нас просто

611
00:23:38,180 --> 00:23:40,190
будет набор весов, и мы  Я

612
00:23:40,190 --> 00:23:43,640
собираюсь умножить это на набор

613
00:23:43,640 --> 00:23:46,160
функций, так что вы знаете, может быть, это показания моего

614
00:23:46,160 --> 00:23:48,290
датчика на сто восемьдесят градусов,

615
00:23:48,290 --> 00:23:49,700
а затем я просто получу

616
00:23:49,700 --> 00:23:52,000
вес для каждой из этих 180 функций,

617
00:23:52,000 --> 00:23:56,090
и мы можем либо представить функцию значения,

618
00:23:56,090 --> 00:23:58,190
либо вы можете  сделайте это для

619
00:23:58,190 --> 00:24:01,580
функции значения действия состояния. Те из вас, кто

620
00:24:01,580 --> 00:24:02,570
уже думает о функциях значения действия состояния,

621
00:24:02,570 --> 00:24:04,070
могут заметить, что

622
00:24:04,070 --> 00:24:05,360
есть по крайней мере два способа сделать это, как

623
00:24:05,360 --> 00:24:07,310
только вы начнете вникать в Q, просто

624
00:24:07,310 --> 00:24:09,200
упомяните, что bri  На самом деле вы могли бы либо

625
00:24:09,200 --> 00:24:11,120
иметь отдельный вектор весов для каждого

626
00:24:11,120 --> 00:24:13,910
действия, либо вы могли бы поместить действие как

627
00:24:13,910 --> 00:24:16,040
своего рода дополнительную функцию, по

628
00:24:16,040 --> 00:24:18,380
сути, несколько разных вариантов,

629
00:24:18,380 --> 00:24:20,720
вы получаете разные формы Шари,

630
00:24:20,720 --> 00:24:24,040
но сейчас мы просто думаем об

631
00:24:24,040 --> 00:24:25,850
оценке ценности конкретной

632
00:24:25,850 --> 00:24:27,320
политики.  поэтому мы просто подумаем о

633
00:24:27,320 --> 00:24:30,410
значениях и скажем, что помните, что

634
00:24:30,410 --> 00:24:34,610
W — это вектор, а X — это вектор, теперь X of

635
00:24:34,610 --> 00:24:36,290
s просто даст нам

636
00:24:36,290 --> 00:24:38,480
характеристики этого состояния, чтобы оно могло быть похоже на

637
00:24:38,480 --> 00:24:39,680
реальное состояние  мир находится там, где находится

638
00:24:39,680 --> 00:24:41,480
робот, и функции, которые вы получаете,

639
00:24:41,480 --> 00:24:44,750
- это эти 180 показаний, поэтому мы снова

640
00:24:44,750 --> 00:24:46,370
собираемся сосредоточиться на среднеквадратической ошибке, наша

641
00:24:46,370 --> 00:24:48,440
целевая функция - это среднеквадратическая

642
00:24:48,440 --> 00:24:49,880
ошибка, разница между значениями, которые

643
00:24:49,880 --> 00:24:52,090
были предсказаны, и истинными значениями, и

644
00:24:52,090 --> 00:24:55,460
это  это наше обновление веса, то есть мы

645
00:24:55,460 --> 00:24:57,080
хотим обновить наш вес на скорость обучения,

646
00:24:57,080 --> 00:24:59,000
умноженную на производную этой

647
00:24:59,000 --> 00:25:01,340
функции, так как это выглядит

648
00:25:01,340 --> 00:25:02,750
в случае аппроксимации функции линейного значения,

649
00:25:02,750 --> 00:25:05,570
так что мы собираемся делать я  s

650
00:25:05,570 --> 00:25:06,740
мы просто возьмем производную

651
00:25:06,740 --> 00:25:08,690
от J, используя тот факт, что мы знаем, что

652
00:25:08,690 --> 00:25:13,520
это на самом деле х раз W хорошо, так что

653
00:25:13,520 --> 00:25:15,290
мы собираемся получить в этом случае W

654
00:25:15,290 --> 00:25:21,770
дельта W равна его 1/2 альфа к  быть

655
00:25:21,770 --> 00:25:31,760
PI из s минус V да W умножить на X, потому

656
00:25:31,760 --> 00:25:33,980
что производная от x умножить на W по отношению

657
00:25:33,980 --> 00:25:41,840
к W равна X да большой вопрос у нее я

658
00:25:41,840 --> 00:25:45,110
союз еще раз да вопрос в том, является ли

659
00:25:45,110 --> 00:25:46,580
это ожидаемым значением или всех

660
00:25:46,580 --> 00:25:48,410
состояний или  конкретное состояние, когда мы

661
00:25:48,410 --> 00:25:50,360
делаем обновление W, мы

662
00:25:50,360 --> 00:25:53,030
собираемся оценивать это в одном состоянии,

663
00:25:53,030 --> 00:25:57,080
поэтому мы собираемся сделать это для каждого состояния, поэтому мы

664
00:25:57,080 --> 00:25:58,460
увидим разные алгоритмы для этого,

665
00:25:58,460 --> 00:26:00,110
но в целом мы собираемся  делать

666
00:26:00,110 --> 00:26:01,310
стохастический градиентный спуск, поэтому мы

667
00:26:01,310 --> 00:26:02,750
собираемся делать это в каждом состоянии,

668
00:26:02,750 --> 00:26:04,400
ожидаемое значение здесь, о котором вы можете подумать

669
00:26:04,400 --> 00:26:07,330
, действительно превышает распределение состояний,

670
00:26:07,330 --> 00:26:12,350
выбранное из этой политики, поэтому, если вы должны были

671
00:26:12,350 --> 00:26:14,210
выполнить эту политику в своем реальном MDP,

672
00:26:14,210 --> 00:26:16,550
вы столкнулись бы с некоторыми  состояния, и если

673
00:26:16,550 --> 00:26:18,530
вы и мы поговорим в ближайшее время о

674
00:26:18,530 --> 00:26:19,820
том, как выглядит этот дистрибутив  вроде,

675
00:26:19,820 --> 00:26:23,570
но это то, что мы хотим минимизировать нашу

676
00:26:23,570 --> 00:26:25,520
ошибку во всем распределении состояний, с которым

677
00:26:25,520 --> 00:26:27,020
мы столкнемся в соответствии с

678
00:26:27,020 --> 00:26:30,590
этой политикой, привет, хорошие вопросы, хорошо, так что, если

679
00:26:30,590 --> 00:26:32,030
мы посмотрим на этот форум,

680
00:26:32,030 --> 00:26:33,620
как это выглядит, похоже, что у нас есть размер шага, который

681
00:26:33,620 --> 00:26:34,520


682
00:26:34,520 --> 00:26:36,380
мы видели  раньше с TD-обучением, а

683
00:26:36,380 --> 00:26:38,960
затем у нас есть ошибка прогнозирования, которая представляет

684
00:26:38,960 --> 00:26:40,670
собой разницу между функцией значения,

685
00:26:40,670 --> 00:26:42,950
функцией истинного значения и

686
00:26:42,950 --> 00:26:44,120
функцией значения, которую мы прогнозируем в рамках

687
00:26:44,120 --> 00:26:45,770
оценки, а затем у нас есть значение признака,

688
00:26:45,770 --> 00:26:48,740
так что это один из приятных

689
00:26:48,740 --> 00:26:51,500
аспектов линейной линейной  Аппроксимация функции ценности

690
00:26:51,500 --> 00:26:53,660
заключается в том, что эти обновления

691
00:26:53,660 --> 00:26:55,850
формируют своего рода очень естественное представление о

692
00:26:55,850 --> 00:26:59,710
том, насколько вы были далеки от истинного значения.

693
00:27:20,920 --> 00:27:24,500


694
00:27:24,500 --> 00:27:26,840


695
00:27:26,840 --> 00:27:29,990


696
00:27:29,990 --> 00:27:32,000
выдвиньте этот негатив

697
00:27:32,000 --> 00:27:34,220
сюда, в общем, альфа - это константа, поэтому

698
00:27:34,220 --> 00:27:35,480
вы можете перевернуть его и быть положительным или

699
00:27:35,480 --> 00:27:37,100
отрицательным, как правило, вы захотите,

700
00:27:37,100 --> 00:27:39,020
если вы минимизируете это,

701
00:27:39,020 --> 00:27:41,060
это будет вы  будет вычитать

702
00:27:41,060 --> 00:27:42,350
это из весов, но вы просто

703
00:27:42,350 --> 00:27:43,580
хотите быть осторожным в зависимости от того, как вы

704
00:27:43,580 --> 00:27:46,370
определяете свою альфу, поэтому убедитесь, что вы

705
00:27:46,370 --> 00:27:47,780
принимаете градиенты, смысл градиента

706
00:27:47,780 --> 00:27:50,650
шагает в правильном направлении,

707
00:27:53,440 --> 00:27:56,690
хорошо, так что как бы мы это сделали, помня

708
00:27:56,690 --> 00:27:57,920
опять же, у нас на самом деле нет доступа

709
00:27:57,920 --> 00:28:00,170
к функции истинного значения, поэтому мы на

710
00:28:00,170 --> 00:28:02,390
самом деле не знаем, поэтому в этом уравнении правильно

711
00:28:02,390 --> 00:28:05,810
это предполагает, что это верно, как

712
00:28:05,810 --> 00:28:07,610
если бы Оракул дал вам

713
00:28:07,610 --> 00:28:09,620
значение состояния в соответствии с этой политикой, но  Конечно,

714
00:28:09,620 --> 00:28:12,290
у нас нет доступа к этому, поэтому

715
00:28:12,290 --> 00:28:13,550
мы собираемся использовать те же

716
00:28:13,550 --> 00:28:16,820
типы идей, которые мы видели в табличном

717
00:28:16,820 --> 00:28:18,830
обучении, теперь с приближением функции значения,

718
00:28:18,830 --> 00:28:22,850
поэтому доход, который является

719
00:28:22,850 --> 00:28:25,070
ожидаемым, или доход, который является

720
00:28:25,070 --> 00:28:27,560
сумма вознаграждений от временного шага T до

721
00:28:27,560 --> 00:28:30,200
конца эпизода представляет собой беспристрастную зашумленную

722
00:28:30,200 --> 00:28:32,510
выборку истинного ожидаемого дохода

723
00:28:32,510 --> 00:28:34,100
для текущего состояния прямо на временном шаге T,

724
00:28:34,100 --> 00:28:36,860
и поэтому мы можем думать о выполнении

725
00:28:36,860 --> 00:28:39,290
аппроксимации функции ценности Монте-Карло так же,

726
00:28:39,290 --> 00:28:40,760
как если бы мы  'р  Выполняя

727
00:28:40,760 --> 00:28:42,760
обучение с учителем на наборе пар возвратов состояния,

728
00:28:42,760 --> 00:28:45,230
мы сейчас делаем то, что

729
00:28:45,230 --> 00:28:47,400
подставляем в GT

730
00:28:47,400 --> 00:28:56,160
оценку истинного значения, поэтому мы не

731
00:28:56,160 --> 00:28:58,170
знаем, каково истинное значение, но мы знаем,

732
00:28:58,170 --> 00:29:00,150
что метод Монте-Карло вернул  является

733
00:29:00,150 --> 00:29:01,470
несмещенной оценкой, поэтому мы собираемся

734
00:29:01,470 --> 00:29:03,780
заменить ее на хорошо, так что

735
00:29:03,780 --> 00:29:05,309
это значит, если мы делаем аппроксимацию линейной функции значения,

736
00:29:05,309 --> 00:29:06,570


737
00:29:06,570 --> 00:29:08,520
это означает, что внутри нашего обновления веса у

738
00:29:08,520 --> 00:29:12,600
нас есть G здесь, поэтому мы должны были бы принять состояние, которое

739
00:29:12,600 --> 00:29:14,670
мы бы приняли  сумма наград в этом

740
00:29:14,670 --> 00:29:16,410
эпизоде, так что опять же, это может

741
00:29:16,410 --> 00:29:18,650
применяться только в эпизодических настройках, как

742
00:29:18,650 --> 00:29:21,120
обычно в Монте-Карло, а затем мы

743
00:29:21,120 --> 00:29:23,220
берем производную, и в этом случае

744
00:29:23,220 --> 00:29:25,380
это просто X наших функций, потому что мы

745
00:29:25,380 --> 00:29:26,520
используем приближение линейной функции ценности,

746
00:29:26,520 --> 00:29:28,530
а затем  в последней строке

747
00:29:28,530 --> 00:29:31,380
я просто подставляю то, что представляет собой наша

748
00:29:31,380 --> 00:29:35,460
оценка V шляпы, поэтому мы сравниваем нашу

749
00:29:35,460 --> 00:29:38,670
прибыль с нашей текущей оценкой, а затем

750
00:29:38,670 --> 00:29:40,080
мы умножаем ее на наши функции, и,

751
00:29:40,080 --> 00:29:42,390
как обычно, у нас есть проблема, что G

752
00:29:42,390 --> 00:29:43,860
может быть  очень шумно  imate по

753
00:29:43,860 --> 00:29:46,770
возвращении да имя сначала пожалуйста

754
00:29:46,770 --> 00:29:48,390
прочитайте первую оценку в первый раз неизбежно

755
00:29:48,390 --> 00:29:50,790
до этого мы различаем первый

756
00:29:50,790 --> 00:29:52,590
раз и каждый раз это как до

757
00:29:52,590 --> 00:29:55,559
великого видения мы различаем между

758
00:29:55,559 --> 00:29:57,420
первым посещением каждый раз при посещении да

759
00:29:57,420 --> 00:30:00,090
те же самые точные различия применяются к

760
00:30:00,090 --> 00:30:01,880
Монте  Обновление Карло, которое применялось ранее,

761
00:30:01,880 --> 00:30:07,020
поэтому здесь я показываю вариант первого посещения,

762
00:30:07,020 --> 00:30:09,960
но вы также

763
00:30:09,960 --> 00:30:13,920
можете делать каждое посещение, и оно будет иметь

764
00:30:13,920 --> 00:30:18,179
те же сильные стороны и ограничения, что и

765
00:30:18,179 --> 00:30:20,610
до каждого посещения.

766
00:30:20,610 --> 00:30:23,309


767
00:30:23,309 --> 00:30:24,600
веса выглядят так, как в этом

768
00:30:24,600 --> 00:30:27,480
случае мы бы сказали, что вес равен

769
00:30:27,480 --> 00:30:35,660
старым весам плюс альфа, умноженная на e T of s

770
00:30:35,660 --> 00:30:41,460
минус V.

771
00:30:41,460 --> 00:30:44,160


772
00:30:44,160 --> 00:30:49,820


773
00:30:50,880 --> 00:30:53,230
к тому, что мы видели

774
00:30:53,230 --> 00:30:56,950
раньше для Монте-Карло, паркует оценку политики Монте-

775
00:30:56,950 --> 00:30:59,950
Карло, что мы делаем, так это

776
00:30:59,950 --> 00:31:01,600
начинаем в этом случае сейчас, вместо того, чтобы

777
00:31:01,600 --> 00:31:03,490
иметь функцию ценности, у нас просто есть

778
00:31:03,490 --> 00:31:05,680
набор весов, который идет  ng теперь

779
00:31:05,680 --> 00:31:07,960
является нулевым вектором для начала, затем мы

780
00:31:07,960 --> 00:31:09,490
сэмплируем эпизод, который мы должны упростить

781
00:31:09,490 --> 00:31:11,110
до конца эпизода, используя

782
00:31:11,110 --> 00:31:13,900
политику, а затем мы проходим через этот

783
00:31:13,900 --> 00:31:15,970
эпизод, и если это первое посещение

784
00:31:15,970 --> 00:31:18,610
этого состояния, тогда мы вычисляем  вернитесь

785
00:31:18,610 --> 00:31:20,050
из этого состояния до конца

786
00:31:20,050 --> 00:31:23,940
эпизода, а затем мы обновим наши веса.

787
00:31:32,670 --> 00:31:36,430
Вопрос об альфе, где o с

788
00:31:36,430 --> 00:31:41,020
точки зрения отрицательного против положительного, да,

789
00:31:41,020 --> 00:31:43,440
так что в целом это будет выглядеть так.

790
00:31:43,440 --> 00:31:46,510


791
00:31:46,510 --> 00:31:49,210
альфа будет скоростью обучения

792
00:31:49,210 --> 00:31:51,730
, это выбор, как правило, мы будем

793
00:31:51,730 --> 00:31:53,650
пытаться минимизировать мою целевую функцию,

794
00:31:53,650 --> 00:31:57,070
мы собираемся сократить наши недели, и

795
00:31:57,070 --> 00:31:58,270
мы снова будем использовать Biel, будьте немного

796
00:31:58,270 --> 00:31:59,800
осторожны с тем, как мы выбираем альфу с течением

797
00:31:59,800 --> 00:32:04,690
времени и  и это оценивается в

798
00:32:04,690 --> 00:32:06,010
каждом из состояний, с которыми мы сталкиваемся

799
00:32:06,010 --> 00:32:08,370
на этом пути,

800
00:32:12,130 --> 00:32:14,780
и просто

801
00:32:14,780 --> 00:32:18,100
будьте осторожны на шагах, если вы знаете камеру

802
00:32:18,100 --> 00:32:23,810
или просто заметили хороший вопрос, и на шаге

803
00:32:23,810 --> 00:32:25,870
6

804
00:32:27,220 --> 00:32:29,590
я также сказал, нужна ли нам гамма-

805
00:32:29,590 --> 00:32:33,280
функция, это хороший вопрос  в

806
00:32:33,280 --> 00:32:36,070
эпизодическом  RL, вы всегда можете обойтись без

807
00:32:36,070 --> 00:32:38,770
гаммы, равной единице, поэтому, если это эпизодическое

808
00:32:38,770 --> 00:32:41,200
место, гамма всегда может быть равна единице,

809
00:32:41,200 --> 00:32:48,040
также можно включить сюда гамму, поэтому здесь,

810
00:32:48,040 --> 00:32:51,490
как правило, в эпизодических случаях вы

811
00:32:51,490 --> 00:32:54,190
устанавливаете гамму равной единице, потому что одна

812
00:32:54,190 --> 00:32:56,050
из причин  то, что наша гамма

813
00:32:56,050 --> 00:32:57,550
меньше единицы, означает, что вещи

814
00:32:57,550 --> 00:32:59,590
ограничены с точки зрения их функции ценности,

815
00:32:59,590 --> 00:33:01,720
но в эпизодическом случае всегда

816
00:33:01,720 --> 00:33:04,420
гарантируется ограниченность, но также

817
00:33:04,420 --> 00:33:08,040
совершенно нормально включать сюда гамму

818
00:33:08,250 --> 00:33:13,210
примерно в той же точке относительно G  поэтому, когда мы

819
00:33:13,210 --> 00:33:15,030
это делаем, кажется, что мы в конечном итоге получим

820
00:33:15,030 --> 00:33:19,240
разумные G, у которых есть награды

821
00:33:19,240 --> 00:33:21,850
за эпизоды разных вещей, верно,

822
00:33:21,850 --> 00:33:23,560
так что это не потому, что они

823
00:33:23,560 --> 00:33:28,150
распределены стационарно, нет

824
00:33:28,150 --> 00:33:30,130
проблемы с тем фактом, что доходы,

825
00:33:30,130 --> 00:33:32,740
которые вы получаете,  будет несколько, так что для

826
00:33:32,740 --> 00:33:36,820
разной длины это не так, поэтому я

827
00:33:36,820 --> 00:33:38,860
всегда пытаюсь оценить ценность

828
00:33:38,860 --> 00:33:42,430
пребывания в этом состоянии, которое само по себе в соответствии с

829
00:33:42,430 --> 00:33:45,640
этой политикой и в эпизодическом случае вы

830
00:33:45,640 --> 00:33:47,350
можете столкнуться с этим состоянием в

831
00:33:47,350 --> 00:33:48,760
начале пути.  ектории или конце траектории,

832
00:33:48,760 --> 00:33:51,460
и ваше ваше значение точно

833
00:33:51,460 --> 00:33:53,770
будет усреднено с вами в Канаде

834
00:33:53,770 --> 00:33:55,240
рано или поздно, и один из возвратов

835
00:33:55,240 --> 00:33:58,660
нет проблем с тем, что мы предполагаем, что

836
00:33:58,660 --> 00:34:00,280
все ваши эпизоды ограничены, они

837
00:34:00,280 --> 00:34:02,620
должны быть конечными, поэтому они  знаете ли вы, что

838
00:34:02,620 --> 00:34:04,270
должно быть с вероятностью один ваш

839
00:34:04,270 --> 00:34:06,910
эпизод должен закончиться, если это правда, то

840
00:34:06,910 --> 00:34:09,400
ваши награды всегда ограничены, и

841
00:34:09,400 --> 00:34:11,500
тогда вы всегда можете просто усреднить

842
00:34:11,500 --> 00:34:12,790
это, и это нормально, иногда вы можете

843
00:34:12,790 --> 00:34:14,739
столкнуться с состоянием очень рано в

844
00:34:14,739 --> 00:34:16,150
траектории и  иметь много наград в

845
00:34:16,150 --> 00:34:17,380
других случаях, с которыми вы можете столкнуться в

846
00:34:17,380 --> 00:34:20,168
конце, и иметь очень мало наград, и

847
00:34:20,168 --> 00:34:23,668
ценность этого просто ожидание, что у

848
00:34:25,969 --> 00:34:28,369
вас есть надлежащее образование, поэтому, по сути,

849
00:34:28,369 --> 00:34:30,619
этот аргумент вы обновляете этот

850
00:34:30,619 --> 00:34:33,109
маленький счастливый эпизод линейного приближения,

851
00:34:33,109 --> 00:34:34,940
поэтому иногда вы  дайте нам

852
00:34:34,940 --> 00:34:36,949
посмотреть, тогда вы берете, это немного новое

853
00:34:36,949 --> 00:34:40,940
обновление, но не только один раз, я полагаю,

854
00:34:40,940 --> 00:34:42,409
вы не просто обновляете ожидание один раз

855
00:34:42,409 --> 00:34:44,840
в эпизоде много раз, так что вы смотрите на все

856
00:34:44,840 --> 00:34:46,219
состояния, которые вы  сталкиваетесь с этим

857
00:34:46,219 --> 00:34:48,199
эпизодом, и для каждого из них вы обновляете

858
00:34:48,199 --> 00:34:53,210
свой вектор веса, генерируя все

859
00:34:53,210 --> 00:34:59,950
активы и пытаясь сохранить их, вот и все,

860
00:34:59,950 --> 00:35:02,180
вы знаете, что, если бы мы сделали это в пакетной

861
00:35:02,180 --> 00:35:03,770
настройке, так что, если бы вы сгенерировали весь

862
00:35:03,770 --> 00:35:05,330
облучатель, а затем попытались его

863
00:35:05,330 --> 00:35:06,680
подогнать  так что это постепенный

864
00:35:06,680 --> 00:35:08,300
подход к тому, чтобы сделать это, и они в

865
00:35:08,300 --> 00:35:13,570
конечном итоге сходятся к одному и тому же, да,

866
00:35:13,570 --> 00:35:16,880
просто когда вы нажимаете гамму при съемке изображения

867
00:35:16,880 --> 00:35:18,830
в степени J минус T, так что вы начинаете

868
00:35:18,830 --> 00:35:24,190
дисконтировать, как будто снова идете вперед,

869
00:35:32,900 --> 00:35:36,090
вам не нужно  гамма в этом

870
00:35:36,090 --> 00:35:39,480
случае так вообще в этом случае

871
00:35:39,480 --> 00:35:41,400
должно быть наверное знает что я

872
00:35:41,400 --> 00:35:42,630
там не было бы гаммы если в эпизодическом

873
00:35:42,630 --> 00:35:44,609
случае хорошо быть точным в этих

874
00:35:44,609 --> 00:35:48,690
настройках ладно ладно так что давайте подумаем

875
00:35:48,690 --> 00:35:51,990
об этом на конкретном примере

876
00:35:51,990 --> 00:35:53,550
оказывается, что когда мы начинаем комбинировать

877
00:35:53,550 --> 00:35:55,260
аппроксимацию функций с принятием

878
00:35:55,260 --> 00:35:57,840
решений и выполнением такого рода

879
00:35:57,840 --> 00:35:59,670
инкрементных обновлений в Интернете, все может

880
00:35:59,670 --> 00:36:02,910
пойти плохо, и есть то, что я

881
00:36:02,910 --> 00:36:04,530
имею в виду под плохим, это то, что мы можем не  rge

882
00:36:04,530 --> 00:36:06,180
и где вы можете не сойтись в местах,

883
00:36:06,180 --> 00:36:07,740
которые мы хотим с точки зрения представления

884
00:36:07,740 --> 00:36:10,170
функции оптимального значения, поэтому есть

885
00:36:10,170 --> 00:36:12,359
хороший пример, когда люди действительно

886
00:36:12,359 --> 00:36:13,590
начинают много думать об

887
00:36:13,590 --> 00:36:17,400
аппроксимации функции в начале 1990-х годов.

888
00:36:17,400 --> 00:36:19,980
может

889
00:36:19,980 --> 00:36:21,450
проиллюстрировать некоторые проблемы

890
00:36:21,450 --> 00:36:22,800
выполнения аппроксимации функций в

891
00:36:22,800 --> 00:36:24,930
сочетании с управлением и

892
00:36:24,930 --> 00:36:27,030
принятием решений, поэтому мы собираемся представить

893
00:36:27,030 --> 00:36:29,580
этот пример сейчас с оценкой политики MC,

894
00:36:29,580 --> 00:36:30,839
а затем мы увидим его несколько

895
00:36:30,839 --> 00:36:32,940
раз на уроке, так что это такое

896
00:36:32,940 --> 00:36:34,380
пример, показывающий, что в этом примере

897
00:36:34,380 --> 00:36:36,900
они будут двумя действиями, поэтому

898
00:36:36,900 --> 00:36:38,670
одно будет прямыми линиями, и

899
00:36:38,670 --> 00:36:40,320
все они будут детерминистически переходить к

900
00:36:40,320 --> 00:36:43,290
тому, что я собираюсь назвать состоянием s7

901
00:36:43,290 --> 00:36:49,890
состояние миссис s1 s2 s3 s4 s5 s6 и  то, что вы можете

902
00:36:49,890 --> 00:36:52,200
видеть внутри пузырьков, это то,

903
00:36:52,200 --> 00:36:54,540
каково представление значения функции, поэтому

904
00:36:54,540 --> 00:36:55,830
помните, я сказал, что у нас будет

905
00:36:55,830 --> 00:36:57,240
состояние, а затем мы можем записать его

906
00:36:57,240 --> 00:37:00,180
как набор функций, так что же делает s1 loo  k

907
00:37:00,180 --> 00:37:04,260
похоже, это выглядит как два два три четыре

908
00:37:04,260 --> 00:37:09,390
пять шесть семь, так что подожди один это два и

909
00:37:09,390 --> 00:37:12,300
подожди восемь это один так что s2

910
00:37:12,300 --> 00:37:17,180
выглядит как два выглядит как 0 2 1 2 3 4 5

911
00:37:17,180 --> 00:37:18,390
да

912
00:37:18,390 --> 00:37:24,660
это три выглядит так и так далее,

913
00:37:24,660 --> 00:37:29,750
пока мы  перейти к s7, который выглядит так

914
00:37:34,200 --> 00:37:37,280
[Музыка],

915
00:37:41,770 --> 00:37:44,420
так что s7 выглядит немного иначе,

916
00:37:44,420 --> 00:37:46,400
чем остальные, что является

917
00:37:46,400 --> 00:37:48,890
представлением функций этих состояний, теперь

918
00:37:48,890 --> 00:37:50,690
обратите внимание, что оно очень похоже на

919
00:37:50,690 --> 00:37:53,180
табличное представление, на самом деле

920
00:37:53,180 --> 00:37:56,030
функций больше, чем есть  состояний, так что

921
00:37:56,030 --> 00:37:57,530
здесь есть только семь состояний и

922
00:37:57,530 --> 00:37:59,240
есть восемь признаков, которые

923
00:37:59,240 --> 00:38:01,220
вполне возможны, как будто ваше

924
00:38:01,220 --> 00:38:03,290
будущее представление может быть больше,

925
00:38:03,290 --> 00:38:04,730
чем количество истинных состояний в

926
00:38:04,730 --> 00:38:08,060
мире, поэтому у нас есть действие a1, и на

927
00:38:08,060 --> 00:38:09,740
самом деле мы всегда детерминистически переводим нас из любого

928
00:38:09,740 --> 00:38:11,930
состояния в  состояние s7, а

929
00:38:11,930 --> 00:38:14,180
затем у нас есть действие a2, которое

930
00:38:14,180 --> 00:38:17,740
обозначается точкой, и то, что делает действие a2,

931
00:38:17,740 --> 00:38:23,000
с вероятностью один больше шести,

932
00:38:23,000 --> 00:38:27,440
вам нужно указать s I, где I находится в пределах от одного до

933
00:38:27,440 --> 00:38:27,800
шести,

934
00:38:27,800 --> 00:38:30,290
поэтому в основном равномерно распространяется на ваш

935
00:38:30,290 --> 00:38:33,530
в одном из первых шести состояний

936
00:38:33,530 --> 00:38:35,359
есть только два действия: либо вы

937
00:38:35,359 --> 00:38:37,970
определенно переходите в состояние s7, либо, если вы

938
00:38:37,970 --> 00:38:39,650
выполняете второе действие, то вы переходите в

939
00:38:39,650 --> 00:38:41,570
одно из первых шести состояний с равной

940
00:38:41,570 --> 00:38:43,910
вероятностью, и это довольно простая

941
00:38:43,910 --> 00:38:45,710
задача управления, потому что здесь присуждается

942
00:38:45,710 --> 00:38:50,119
ноль везде для всех действий, поэтому

943
00:38:50,119 --> 00:38:52,040
функция значения для этого равна нулю, потому

944
00:38:52,040 --> 00:38:55,609
что нигде нет наград, и все же

945
00:38:55,609 --> 00:38:57,080
в некоторых случаях мы можем столкнуться с проблемами,

946
00:38:57,080 --> 00:38:58,940
поэтому, прежде чем мы перейдем к этой части,

947
00:38:58,940 --> 00:39:01,220
давайте сначала просто подумаем о том, что, например,

948
00:39:01,220 --> 00:39:04,849
обновление Монте-Карло сделает  и давайте

949
00:39:04,849 --> 00:39:06,470
просто представим также, что здесь есть некоторая

950
00:39:06,470 --> 00:39:08,450
дополнительная небольшая вероятность того, что

951
00:39:08,450 --> 00:39:10,310
из s 7 мы действительно переходим в

952
00:39:10,310 --> 00:39:14,270
терминальное состояние, так что, скажем, вы

953
00:39:14,270 --> 00:39:16,550
знаете, с вероятностью 0,999 мы остаемся в

954
00:39:16,550 --> 00:39:20,180
a7 или как 0,99 мы остаемся в s7 и точка

955
00:39:20,180 --> 00:39:24,290
0 1 мы заканчиваем  и это небольшая

956
00:39:24,290 --> 00:39:25,820
модификация, но я делаю это только для того, чтобы

957
00:39:25,820 --> 00:39:27,770
мы могли сделать это для дела Монте-Карло, чтобы

958
00:39:27,770 --> 00:39:30,589
мы могли думать об окончании эпизодов, поэтому, если

959
00:39:30,589 --> 00:39:32,240
вы находитесь в состоянии с первого по шестой, вы можете

960
00:39:32,240 --> 00:39:33,890
либо перейти к s7 или  вы можете оставаться в

961
00:39:33,890 --> 00:39:35,830
состояниях с первого по шестой, если вы являетесь сообществом s7,

962
00:39:35,830 --> 00:39:38,030
переходите в состояния с первого по шестой,

963
00:39:38,030 --> 00:39:39,849
вы можете оставаться в s7, или вы можете завершить,

964
00:39:39,849 --> 00:39:42,200
все в порядке, так что как мой эпизод не

965
00:39:42,200 --> 00:39:43,609
выглядел в этом случае, так что давайте представим,

966
00:39:43,609 --> 00:39:45,870
что мы  были в состоянии как один

967
00:39:45,870 --> 00:39:48,090
к действию тот, который детерминистически

968
00:39:48,090 --> 00:39:50,610
приводит нас к состоянию s7 на самом деле, прежде чем я это сделаю

969
00:39:50,610 --> 00:39:53,060
, я уточню, что мы получили нулевое

970
00:39:53,060 --> 00:39:56,580
слово вознаграждения с нулем мы перешли к s7 мы предприняли

971
00:39:56,580 --> 00:40:00,660
действие a1 мы получили нулевое вознаграждение мы остались

972
00:40:00,660 --> 00:40:03,390
в s7 мы взяли  действие a1, которое мы получили, они были

973
00:40:03,390 --> 00:40:07,500
деревянными, затем мы завершаем, это наш

974
00:40:07,500 --> 00:40:10,980
эпизод, поэтому теперь мы можем подумать о том, каким

975
00:40:10,980 --> 00:40:13,470
будет наше обновление Монте-Карло, поэтому наше

976
00:40:13,470 --> 00:40:15,780
обновление Монте-Карло в этом случае будет

977
00:40:15,780 --> 00:40:18,570
давайте начнем с состояния s1 и попробуем выполнить

978
00:40:18,570 --> 00:40:21,420
обновление Монте-Карло, поэтому  для состояния

979
00:40:21,420 --> 00:40:27,090
s1 возврат - это то, сэр, поэтому возврат равен

980
00:40:27,090 --> 00:40:32,280
0, что такое x1, я должен сказать вам, поэтому давайте

981
00:40:32,280 --> 00:40:34,020
начнем с инициализации всех наших

982
00:40:34,020 --> 00:40:38,400
весов равными 1, так какова наша начальная

983
00:40:38,400 --> 00:40:40,890
оценка функции значения состояния

984
00:40:40,890 --> 00:40:51,210
s1, сколько, так что все  весов

985
00:40:51,210 --> 00:40:54,720
r1 состояние s1 представляет  on равно 2 0 0

986
00:40:54,720 --> 00:40:59,520
0 1 3, это правильно, ладно, и это просто

987
00:40:59,520 --> 00:41:07,830
равно R, итак, как выглядит наше обновление,

988
00:41:07,830 --> 00:41:09,030
и, конечно же, я должен

989
00:41:09,030 --> 00:41:10,410
сказать вам, что такое альфа, так что скажем,

990
00:41:10,410 --> 00:41:13,440
альфа равна 0,5, так что наши

991
00:41:13,440 --> 00:41:15,240
веса  мы

992
00:41:15,240 --> 00:41:16,740
собираемся изменить веса, будет равно 0,5

993
00:41:16,740 --> 00:41:21,090
умножить на 0 минус 3 раза наш вектор признаков

994
00:41:21,090 --> 00:41:25,740
для X наш вектор признаков для X равен 2 0 0

995
00:41:25,740 --> 00:41:29,450
1, так что это означает, что мы получим в

996
00:41:29,450 --> 00:41:34,880
основном минус 1,5 умножить на 0 или  1

997
00:41:34,880 --> 00:41:44,850
минус 3 раза минус 1,5, поэтому обратите внимание, что

998
00:41:44,850 --> 00:41:46,350
это даст нам обновление для каждого

999
00:41:46,350 --> 00:41:48,990
отдельного веса, но это даст

1000
00:41:48,990 --> 00:41:50,100
нам обновление только для весов, которые не равны

1001
00:41:50,100 --> 00:41:52,500
нулю в этом конкретном состоянии, которое

1002
00:41:52,500 --> 00:41:56,280
является первым весом и весом, и поэтому

1003
00:41:56,280 --> 00:41:58,080
, если бы мы были  чтобы на самом деле получить новые

1004
00:41:58,080 --> 00:41:59,050
веса, так что теперь

1005
00:41:59,050 --> 00:42:01,300
у нас будет W равно W плюс

1006
00:42:01,300 --> 00:42:05,230
Delta W, тогда наше новое представление

1007
00:42:05,230 --> 00:42:08,440
будет минус два один два три четыре

1008
00:42:08,440 --> 00:42:14,710
пять шесть девять целых пять десятых, так что это

1009
00:42:14,710 --> 00:42:17,740
будет одно обновление Монте-Карло для

1010
00:42:17,740 --> 00:42:19,810
первого  state теперь вы бы сделали это для

1011
00:42:19,810 --> 00:42:22,120
каждого отдельного состояния в этом эпизоде  так

1012
00:42:22,120 --> 00:42:23,620
что вы затем сделаете это после того, как

1013
00:42:23,620 --> 00:42:25,300
впервые увидите это и алгоритм, который я

1014
00:42:25,300 --> 00:42:26,680
определил ранее, поэтому мы затем сделаем это и

1015
00:42:26,680 --> 00:42:28,960
для состояния s семь, или возврат

1016
00:42:28,960 --> 00:42:30,790
также будет равен нулю, но значение

1017
00:42:30,790 --> 00:42:32,620
будет другим, поэтому мы получим

1018
00:42:32,620 --> 00:42:34,960
другой ну на самом деле в этом

1019
00:42:34,960 --> 00:42:37,420
конкретном случае значение также равно трем,

1020
00:42:37,420 --> 00:42:39,490
это зависит от того, обновили ли вы уже

1021
00:42:39,490 --> 00:42:41,380
свой W, тогда ваше значение уже

1022
00:42:41,380 --> 00:42:49,810
будет другим уже SGD за эпизод

1023
00:42:49,810 --> 00:42:55,120
наше состояние, которое мы взяли за состояние, да, на

1024
00:42:55,120 --> 00:42:57,310
предыдущем слайде у нас было  для каждого

1025
00:42:57,310 --> 00:43:00,010
состояния, что каждое столкновение

1026
00:43:00,010 --> 00:43:02,860
означает, что при первом посещении у него может

1027
00:43:02,860 --> 00:43:05,860
быть газировка, да, и это в рамках этого конкретного,

1028
00:43:05,860 --> 00:43:09,750
поэтому мы собираемся перейти к новому эпизоду,

1029
00:43:09,750 --> 00:43:11,710
о котором идет речь во время этого первого

1030
00:43:11,710 --> 00:43:13,630
посещения, мы в основном шагаем по этому

1031
00:43:13,630 --> 00:43:15,010
эпизоду, подобному  то, что мы делали с

1032
00:43:15,010 --> 00:43:16,720
Монте-Карло раньше, и когда мы впервые

1033
00:43:16,720 --> 00:43:18,460
сталкиваемся с состоянием в этом эпизоде, мы

1034
00:43:18,460 --> 00:43:21,130
обновляем веса, используя его возвращение, и

1035
00:43:21,130 --> 00:43:22,690
когда мы делаем это для каждого отдельного уникального

1036
00:43:22,690 --> 00:43:24,400
состояния в этом эпизоде в первый раз, когда 

1037
00:43:24,400 --> 00:43:26,320
ы  ee это, а затем, после всего этого, мы должны

1038
00:43:26,320 --> 00:43:31,300
получить новый эпизод, все в порядке, так вот

1039
00:43:31,300 --> 00:43:34,300
что произойдет, и вы можете видеть,

1040
00:43:34,300 --> 00:43:35,800
что изменения могут быть довольно большими, потому что

1041
00:43:35,800 --> 00:43:37,600
мы сравниваем как полный возврат к

1042
00:43:37,600 --> 00:43:39,700
нашей функции значения, и это зависит от

1043
00:43:39,700 --> 00:43:41,920
конечно, что такое наша альфа-альфа, и

1044
00:43:41,920 --> 00:43:43,600
альфа может меняться со временем, и, как правило,

1045
00:43:43,600 --> 00:43:44,920
мы хотим, чтобы альфа менялась с течением времени

1046
00:43:44,920 --> 00:43:47,560
, чтобы получить сходимость, это дает

1047
00:43:47,560 --> 00:43:49,060
пример того, сэр, как обновленный Монте-Карло

1048
00:43:49,060 --> 00:43:50,320
будет выглядеть в этом случае

1049
00:43:50,320 --> 00:43:53,430
с аппроксимацией линейной функции значения

1050
00:43:53,430 --> 00:43:57,790
хорошо  поэтому может возникнуть естественный вопрос: делает ли

1051
00:43:57,790 --> 00:43:59,380
это что-нибудь разумное, гарантируем ли мы,

1052
00:43:59,380 --> 00:44:00,760
что это

1053
00:44:00,760 --> 00:44:03,040
сойдется к правильной вещи, и что

1054
00:44:03,040 --> 00:44:04,900
здесь означает правильность? мы

1055
00:44:04,900 --> 00:44:06,610
ограничены нашим аппроксиматором функции линейного значения,

1056
00:44:06,610 --> 00:44:07,270


1057
00:44:07,270 --> 00:44:08,950
поэтому мы собираемся сказать, мы  собираемся

1058
00:44:08,950 --> 00:44:10,360
сойтись, чтобы что-то вроде лучшей вещи

1059
00:44:10,360 --> 00:44:10,870
в нашем

1060
00:44:10,870 --> 00:44:14,290
аппроксиматоре функции ценности хорошо, прежде чем

1061
00:44:14,290 --> 00:44:15,730
мы это сделаем, давайте просто поговорим на секунду

1062
00:44:15,730 --> 00:44:17,770
о распределении состояний и о

1063
00:44:17,770 --> 00:44:20,620
том, как это влияет на результат, так что я  Если вы

1064
00:44:20,620 --> 00:44:22,210
вспомните, может быть, первую или вторую

1065
00:44:22,210 --> 00:44:23,410
лекцию, мы говорили о взаимосвязи

1066
00:44:23,410 --> 00:44:27,190
между марковскими процессами, марковскими процессами вознаграждения

1067
00:44:27,190 --> 00:44:29,140
и марковскими процессами принятия решений,

1068
00:44:29,140 --> 00:44:31,090
и мы сказали, что как только вы определяете

1069
00:44:31,090 --> 00:44:33,160
конкретную политику, ваш марковский

1070
00:44:33,160 --> 00:44:34,960
процесс принятия решений на самом деле является марковским

1071
00:44:34,960 --> 00:44:37,480
процессом вознаграждения, в котором вы можете  подумайте об этом

1072
00:44:37,480 --> 00:44:40,060
как о цепочке, в которой следующее состояние

1073
00:44:40,060 --> 00:44:42,850
определяется вашей динамической моделью, где

1074
00:44:42,850 --> 00:44:44,800
вы используете действие только в соответствии с

1075
00:44:44,800 --> 00:44:45,810
вашей политикой,

1076
00:44:45,810 --> 00:44:48,820
поэтому, если вы запустите ее, если вы запустите своего

1077
00:44:48,820 --> 00:44:51,010
рода цепь Маркова, определенную MDP с

1078
00:44:51,010 --> 00:44:52,600
определенной политикой, вы в конечном итоге

1079
00:44:52,600 --> 00:44:54,280
сходятся к распределению вероятностей

1080
00:44:54,280 --> 00:44:57,730
по состояниям, и это распределение по

1081
00:44:57,730 --> 00:44:59,020
состояниям называется стационарным

1082
00:44:59,020 --> 00:45:00,700
распределением, это распределение вероятностей,

1083
00:45:00,700 --> 00:45:02,380
говорящее примерно так, какой

1084
00:45:02,380 --> 00:45:03,520
процент в то время, когда вы собираетесь

1085
00:45:03,520 --> 00:45:06,340
находиться в состоянии один в среднем по сравнению с T двумя и

1086
00:45:06,340 --> 00:45:08,530
т. д., должен суммироваться  один, потому что это

1087
00:45:08,530 --> 00:45:10,000
распределение вероятностей, вы всегда

1088
00:45:10,000 --> 00:45:12,250
должны быть в каком-то состоянии, и оно удовлетворяет

1089
00:45:12,250 --> 00:45:15,550
уравнению баланса, поэтому оно говорит, что

1090
00:45:15,550 --> 00:45:17,980
распределение вероятностей по штатам

1091
00:45:17,980 --> 00:45:25,510
до того, как я суммировал, да, я думаю, позвольте мне просто

1092
00:45:25,510 --> 00:45:26,560
перевернуть это, я думаю, что немного

1093
00:45:26,560 --> 00:45:28,480
легче думать об этом наоборот,

1094
00:45:28,480 --> 00:45:35,890
у нас есть D of S простое число

1095
00:45:35,890 --> 00:45:39,100
равно сумме по s сумме по a мы  просто

1096
00:45:39,100 --> 00:45:40,810
делаю это, я закончил прямо сейчас, чтобы

1097
00:45:40,810 --> 00:45:45,250
мы могли быть уверены, что мы позволяем

1098
00:45:45,250 --> 00:45:47,590
себе использовать стохастическую политику, поэтому мы

1099
00:45:47,590 --> 00:45:48,670
рассматриваем все действия, которые мы могли бы предпринять

1100
00:45:48,670 --> 00:45:50,740
в текущем состоянии, а затем мы смотрим

1101
00:45:50,740 --> 00:45:52,570
, куда мы могли бы перейти на

1102
00:45:52,570 --> 00:45:58,150
следующее состояние, так что мы находимся в некотором

1103
00:45:58,150 --> 00:46:00,670
распределении по состояниям, мы думаем обо

1104
00:46:00,670 --> 00:46:02,080
всех действиях, которые мы могли бы предпринять из каждого из

1105
00:46:02,080 --> 00:46:03,910
этих состояний, в которые мы могли бы перейти

1106
00:46:03,910 --> 00:46:06,610
, и тогда это дает нам новое

1107
00:46:06,610 --> 00:46:08,500
распределение по простым числам состояний, и

1108
00:46:08,500 --> 00:46:13,210
эти два должны быть идентичными, поэтому  об

1109
00:46:13,210 --> 00:46:14,680
этом часто также думают с точки

1110
00:46:14,680 --> 00:46:16,450
зрения свойства смешивания, когда ваша

1111
00:46:16,450 --> 00:46:18,940
цепь Маркова работает достаточно долго, это

1112
00:46:18,940 --> 00:46:20,680
уравнение границ в конечном итоге будет выполняться, и

1113
00:46:20,680 --> 00:46:21,670
это просто то, что ваше распределение

1114
00:46:21,670 --> 00:46:23,260
нервных состояний на предыдущем временном

1115
00:46:23,260 --> 00:46:24,610
шаге должно быть точно s  Например,

1116
00:46:24,610 --> 00:46:26,110
ваш номер распределения указывает на

1117
00:46:26,110 --> 00:46:28,690
следующем временном шаге после того, как этот процесс

1118
00:46:28,690 --> 00:46:31,090
полностью перемешан, и он просто говорит вам, что

1119
00:46:31,090 --> 00:46:32,440
в среднем вы знаете, сколько времени

1120
00:46:32,440 --> 00:46:35,080
вы тратите, и какова вероятность того, что

1121
00:46:35,080 --> 00:46:36,490
на любом конкретном временном шаге

1122
00:46:36,490 --> 00:46:38,830
вы окажетесь в определенном  заявите, что это не

1123
00:46:38,830 --> 00:46:40,540
говорит нам, сколько времени потребуется для этого

1124
00:46:40,540 --> 00:46:43,240
процесса, так что это во многом

1125
00:46:43,240 --> 00:46:45,070
зависит от базовой динамики системы,

1126
00:46:45,070 --> 00:46:47,890
поэтому может случиться так, что это займет

1127
00:46:47,890 --> 00:46:50,170
миллионы шагов, пока вы не достигнете стационарного

1128
00:46:50,170 --> 00:46:52,000
распределения, или он может довольно быстро смешиваться.

1129
00:46:52,000 --> 00:46:53,680
зависит от свойств

1130
00:46:53,680 --> 00:46:56,440
вашей матрицы перехода в соответствии с политикой.

1131
00:46:56,440 --> 00:46:58,480
Я не собираюсь вдаваться в подробности в

1132
00:46:58,480 --> 00:47:00,340
этом классе, просто важно знать,

1133
00:47:00,340 --> 00:47:02,260
что вы не можете, это не похоже на то, что вы можете

1134
00:47:02,260 --> 00:47:03,610
просто подождать сто шагов, и, безусловно,

1135
00:47:03,610 --> 00:47:04,540
вы  будет в стационарном

1136
00:47:04,540 --> 00:47:05,860
распределении, это зависит от проблемы

1137
00:47:05,860 --> 00:47:16,600
да, да, есть какие-либо доказанные ограничения

1138
00:47:16,600 --> 00:47:17,830
на время смешивания этих

1139
00:47:17,830 --> 00:47:19,570
методов Монте-Карло, о которых я не знаю,

1140
00:47:19,570 --> 00:47:22,240
могут быть некоторые, это действительно

1141
00:47:22,240 --> 00:47:23,800
часто сложный вопрос, потому что вы не знаете, сколько

1142
00:47:23,800 --> 00:47:25,870
времени потребуется, чтобы добраться до такого

1143
00:47:25,870 --> 00:47:27,940
стационарного распределения, есть действительно

1144
00:47:27,940 --> 00:47:29,260
классная статья, которая вышла

1145
00:47:29,260 --> 00:47:32,350
месяц назад в Наропе, в которой говорится о том, как,

1146
00:47:32,350 --> 00:47:33,970
когда мы думаем об оценке вне политики

1147
00:47:33,970 --> 00:47:35,290
о которых мы поговорим

1148
00:47:35,290 --> 00:47:39,060
позже сегодня, вместо того, чтобы думать о

1149
00:47:39,060 --> 00:47:42,430
пошаговых коэффициентах или о том, будете ли вы

1150
00:47:42,430 --> 00:47:44,260
выполнять определенное действие и определенную

1151
00:47:44,260 --> 00:47:45,820
политику или нет, вы можете подумать об этих

1152
00:47:45,820 --> 00:47:47,200
стационарных распределениях и

1153
00:47:47,200 --> 00:47:48,430
разнице между ними в различных

1154
00:47:48,430 --> 00:47:50,320
задачах политик.  вы часто не знаете,

1155
00:47:50,320 --> 00:47:52,300
как долго и попали ли ваши данные

1156
00:47:52,300 --> 00:47:54,280
в это стационарное распределение, поэтому

1157
00:47:54,280 --> 00:47:55,270
было бы очень хорошо, если бы были простые

1158
00:47:55,270 --> 00:47:56,980
тесты, чтобы определить, правда ли это, что

1159
00:47:56,980 --> 00:48:10,060
также очень трудно знать наверняка, что

1160
00:48:10,060 --> 00:48:12,910
это правильно, поэтому я как бы дал  длинное

1161
00:48:12,910 --> 00:48:14,380
чтение Тони, как вы знаете, вы дали длинную

1162
00:48:14,380 --> 00:48:15,940
прелюдию о том, что вещи

1163
00:48:15,940 --> 00:48:17,230
могут не сойтись, но там все выглядело

1164
00:48:17,230 --> 00:48:18,550
хорошо, мы должны углубиться в это,

1165
00:48:18,550 --> 00:48:20,020
да, и мы собираемся поговорить о факторе  на

1166
00:48:20,020 --> 00:48:21,640
самом деле в

1167
00:48:21,640 --> 00:48:23,080
настройках политики регистрировали оценку политики,

1168
00:48:23,080 --> 00:48:25,120
все будет хорошо, только

1169
00:48:25,120 --> 00:48:27,490
когда мы попадем в контрольный случай, где

1170
00:48:27,490 --> 00:48:29,560
мы будем использовать данные из одной

1171
00:48:29,560 --> 00:48:31,150
политики для оценки значения другой,

1172
00:48:31,150 --> 00:48:33,520
мы находимся в этом примере и во многих других случаях.  другие

1173
00:48:33,520 --> 00:48:35,380
вещи начинают идти наперекосяк, поэтому мы будем

1174
00:48:35,380 --> 00:48:36,850
использовать это как рабочий пример, но сейчас

1175
00:48:36,850 --> 00:48:37,740
нет причин

1176
00:48:37,740 --> 00:48:41,160
полагать, что это патология, хорошо, так

1177
00:48:41,160 --> 00:48:43,140
что это стационарное распределение, а

1178
00:48:43,140 --> 00:48:45,300
затем гарантии сходимости

1179
00:48:45,300 --> 00:48:46,980
связаны с этим хорошо, так что мы

1180
00:48:46,980 --> 00:48:48,810
Что я собираюсь сделать, так это определить среднеквадратичную ошибку

1181
00:48:48,810 --> 00:48:50,390
нашего аппроксиматора функции линейного значения

1182
00:48:50,390 --> 00:48:52,410
по отношению к стационарному

1183
00:48:52,410 --> 00:48:54,750
распределению. Почему это разумно?

1184
00:48:54,750 --> 00:48:56,369


1185
00:48:56,369 --> 00:48:58,350


1186
00:48:58,350 --> 00:49:00,240


1187
00:49:00,240 --> 00:49:01,740
вероятно,

1188
00:49:01,740 --> 00:49:03,210
это нормально иметь большую ошибку, вы

1189
00:49:03,210 --> 00:49:04,980
хотите, чтобы ваша общая среднеквадратическая ошибка

1190
00:49:04,980 --> 00:49:06,330
была определена в этом стационарном

1191
00:49:06,330 --> 00:49:09,869
распределении, так что это среднее значение s  квадрированный

1192
00:49:09,869 --> 00:49:13,500
вид ошибки прогнозирования значения, и он

1193
00:49:13,500 --> 00:49:15,300
сравнивает то, что мы предсказываем, с истинным

1194
00:49:15,300 --> 00:49:17,940
значением, взвешенным этим распределением

1195
00:49:17,940 --> 00:49:19,860
состояний, и то, что мы предполагаем прямо

1196
00:49:19,860 --> 00:49:21,270
сейчас, заключается в том, что приближение, которое мы

1197
00:49:21,270 --> 00:49:22,770
используем, является аппроксиматором линейной функции значения,

1198
00:49:22,770 --> 00:49:25,140
позвольте мне просто отметить для

1199
00:49:25,140 --> 00:49:27,600
исторические причины, по которым Джон делает это

1200
00:49:27,600 --> 00:49:30,300
велосипедист, а Бен Бен Рой Джон работает в Массачусетском технологическом институте

1201
00:49:30,300 --> 00:49:32,250
и имел удовольствие преподавать мне

1202
00:49:32,250 --> 00:49:34,440
вероятность, что было здорово, а потом Бен

1203
00:49:34,440 --> 00:49:36,810
Бен Рой был здесь и был одним из, я думаю

1204
00:49:36,810 --> 00:49:39,360
, аспирантов Джона или постдоков, так или иначе,

1205
00:49:39,360 --> 00:49:42,450
они в  В 1997 году людей стало

1206
00:49:42,450 --> 00:49:43,770
действительно интересовать,

1207
00:49:43,770 --> 00:49:45,060
сочетаете ли вы

1208
00:49:45,060 --> 00:49:47,400
аппроксимацию функции с подкреплением,

1209
00:49:47,400 --> 00:49:48,840
узнавая, что произошло, и были ли

1210
00:49:48,840 --> 00:49:50,280
вещи хорошими или плохими, и они

1211
00:49:50,280 --> 00:49:53,910
несут ответственность за этот хороший анализ, так

1212
00:49:53,910 --> 00:49:55,410
что это то, что у нас есть аппроксиматор функции линейного значения,

1213
00:49:55,410 --> 00:49:57,600
что вы можете  доказательство

1214
00:49:57,600 --> 00:49:59,580
заключается в том, что если вы выполняете

1215
00:49:59,580 --> 00:50:01,740
оценку линейной функции стоимости

1216
00:50:01,740 --> 00:50:03,270
парков по методу Монте-Карло, вы собираетесь сходиться

1217
00:50:03,270 --> 00:50:05,130
к заработной плате, которая имеет минимальное значение me

1218
00:50:05,130 --> 00:50:07,740
квадратичная ошибка, возможно, это лучшее, на что

1219
00:50:07,740 --> 00:50:10,170
вы могли надеяться, так что это говорит о том, что

1220
00:50:10,170 --> 00:50:11,760
в пределе у вас много-много

1221
00:50:11,760 --> 00:50:15,570
данных, и вы запускаете это много-

1222
00:50:15,570 --> 00:50:17,880
много раз, тогда вы можете настроить конвергенцию

1223
00:50:17,880 --> 00:50:20,940
до наилучших возможных весов, теперь

1224
00:50:20,940 --> 00:50:22,560
этот воздух может  не быть нулем, потому что

1225
00:50:22,560 --> 00:50:24,090
может случиться так, что ваша функция значения не может быть

1226
00:50:24,090 --> 00:50:26,250
аппроксимирована с вашим линейным набором

1227
00:50:26,250 --> 00:50:28,859
весов, но она будет делать лучшую работу, которую я

1228
00:50:28,859 --> 00:50:31,080
могу, поэтому просто найду лучшее, это в

1229
00:50:31,080 --> 00:50:32,280
основном просто лучшая линейная

1230
00:50:32,280 --> 00:50:34,320
регрессия, которую вы не могли сделать

1231
00:50:34,320 --> 00:50:37,410
на ваших данных, так что это хорошо, что вы

1232
00:50:37,410 --> 00:50:39,030
знаете, что это своего рода хорошая проверка работоспособности,

1233
00:50:39,030 --> 00:50:40,230
это сойдется лучшее, что вы

1234
00:50:40,230 --> 00:50:44,160
могли бы надеяться сделать, некоторые

1235
00:50:44,160 --> 00:50:46,770
люди спрашивали об этом, хорошо, я

1236
00:50:46,770 --> 00:50:48,840
буду своего рода инкрементным методом и, возможно,

1237
00:50:48,840 --> 00:50:50,250
в некоторых случаях это разумно, может быть,

1238
00:50:50,250 --> 00:50:51,330
вы работаете как система рекомендаций клиентов,

1239
00:50:51,330 --> 00:50:52,740
и вы получаете

1240
00:50:52,740 --> 00:50:54,210
данные с течением времени, и вы обновляете этот

1241
00:50:54,210 --> 00:50:56,250
оценщик, но в некоторых случаях у вас может

1242
00:50:56,250 --> 00:50:57,600
быть доступ только к целому набору

1243
00:50:57,600 --> 00:50:59,280
данных f  из этой политики, и не могли бы вы

1244
00:50:59,280 --> 00:51:01,050
просто сделать это более прямо,

1245
00:51:01,050 --> 00:51:03,540
и ответ - да, так что это часто

1246
00:51:03,540 --> 00:51:06,570
называют пакетным аппроксиматором функции значения Монте-Карло,

1247
00:51:06,570 --> 00:51:08,040
и идея состоит в том, что у вас

1248
00:51:08,040 --> 00:51:09,750
есть целая куча эпизодов из

1249
00:51:09,750 --> 00:51:12,540
политики и приятная вещь  теперь вы можете

1250
00:51:12,540 --> 00:51:13,950
просто аналитически решить для

1251
00:51:13,950 --> 00:51:17,520
лучшего аппроксиматора, поэтому снова наша ГИС

1252
00:51:17,520 --> 00:51:19,080
будет нашей непредвзятой выборкой, которую вы

1253
00:51:19,080 --> 00:51:21,780
ожидали получить, и что вы можете сделать, так это то, что

1254
00:51:21,780 --> 00:51:27,390
теперь n - это просто наш набор данных, это

1255
00:51:27,390 --> 00:51:29,370
действительно проблема линейной регрессии, которую мы  мы

1256
00:51:29,370 --> 00:51:32,190
собираемся использовать наши несмещенные выборки с

1257
00:51:32,190 --> 00:51:33,660
оценками функции истинного значения

1258
00:51:33,660 --> 00:51:35,100
мы просто найдем веса,

1259
00:51:35,100 --> 00:51:36,810
которые минимизируют эту среднеквадратичную ошибку

1260
00:51:36,810 --> 00:51:38,430
вы берете производную вы устанавливаете ее

1261
00:51:38,430 --> 00:51:39,840
равной нулю это линейная регрессия вы можете

1262
00:51:39,840 --> 00:51:44,160
решить это аналитически так немного

1263
00:51:44,160 --> 00:51:45,390
точно так же, как мы говорили о том, что вы можете

1264
00:51:45,390 --> 00:51:47,220
проводить оценку политики аналитически в

1265
00:51:47,220 --> 00:51:48,540
некоторых случаях, вы также можете сделать это

1266
00:51:48,540 --> 00:51:50,130
аналитически в этом случае для линейного

1267
00:51:50,130 --> 00:51:52,950
значения аппроксиматора функции и снова обратите внимание, что

1268
00:51:52,950 --> 00:51:54,510
это Монте-Кар  вот, мы не

1269
00:51:54,510 --> 00:51:56,460
делаем никаких марковских предположений, мы просто

1270
00:51:56,460 --> 00:51:59,190
используем полный возврат, это тоже нормально,

1271
00:51:59,190 --> 00:52:13,920
и немарковские среды в порядке, поэтому то, что

1272
00:52:13,920 --> 00:52:15,000
мы хотели бы сделать, особенно

1273
00:52:15,000 --> 00:52:16,530
другое внутреннее, это обычно имеет

1274
00:52:16,530 --> 00:52:18,990
более высокие вычислительные затраты X может быть

1275
00:52:18,990 --> 00:52:20,820
очень большая матрица, может быть

1276
00:52:20,820 --> 00:52:24,090
невозможно даже записать xx, это все ваши

1277
00:52:24,090 --> 00:52:25,290
данные в

1278
00:52:25,290 --> 00:52:27,150
форме представления признаков, и для этого требуется

1279
00:52:27,150 --> 00:52:29,730
взять обратную матрицу, поэтому это может

1280
00:52:29,730 --> 00:52:31,620
быть неосуществимо, если вы знаете огромные

1281
00:52:31,620 --> 00:52:35,070
векторы признаков и  вы знаете, что миллионы

1282
00:52:35,070 --> 00:52:37,530
миллиардов клиентов Facebook не могут сделать

1283
00:52:37,530 --> 00:52:42,120
это и через это напрямую, а также

1284
00:52:42,120 --> 00:52:43,290
вы знаете, что если вы делаете это, вы можете

1285
00:52:43,290 --> 00:52:44,760
делать это постепенно, но вы

1286
00:52:44,760 --> 00:52:45,960
всегда обновляете все свои данные,

1287
00:52:45,960 --> 00:52:47,940
что также может быть очень  дорого, так что

1288
00:52:47,940 --> 00:52:49,110
большая часть этого связана с памятью и

1289
00:52:49,110 --> 00:52:51,840
вычислениями, если у вас действительно маленький

1290
00:52:51,840 --> 00:52:53,190
корпус, это, вероятно, хорошо,

1291
00:52:53,190 --> 00:52:54,480
а также зависит от того, есть ли у вас уже

1292
00:52:54,480 --> 00:52:58,320
все ваши данные или нет, да, некоторые партии

1293
00:52:58,320 --> 00:52:59,700
также правы, и это может помочь с

1294
00:52:59,700 --> 00:53:01,970
преобразованием  rgence и отсутствие ваших

1295
00:53:01,970 --> 00:53:04,740
оценок градиента, колеблющихся в ценах,

1296
00:53:04,740 --> 00:53:06,930
конечно, есть промежуточный вариант, поэтому вы

1297
00:53:06,930 --> 00:53:08,430
могли бы сделать, что вам не нужно, если у вас есть

1298
00:53:08,430 --> 00:53:10,140
доступ к довольно большому количеству данных, вы могли бы

1299
00:53:10,140 --> 00:53:11,970
либо делать это полностью постепенно, либо

1300
00:53:11,970 --> 00:53:14,329
все партии, или вы могли бы сделать  подпакеты,

1301
00:53:14,329 --> 00:53:17,940
и мои коллеги проделали хорошую работу,

1302
00:53:17,940 --> 00:53:19,559
а также мы показали, что

1303
00:53:19,559 --> 00:53:22,440
с точки зрения глубокого обучения

1304
00:53:22,440 --> 00:53:23,849
может быть много преимуществ в том, чтобы сделать

1305
00:53:23,849 --> 00:53:25,859
какой-то объем этого аналитического аспекта

1306
00:53:25,859 --> 00:53:27,510
по сравнению с тем, как вы знаете подпакет данных,

1307
00:53:27,510 --> 00:53:30,930
потому что  когда

1308
00:53:30,930 --> 00:53:32,220
вы начинаете обучение TD, вы как бы

1309
00:53:32,220 --> 00:53:33,480
распространяете информацию намного

1310
00:53:33,480 --> 00:53:35,250
быстрее, чем если бы

1311
00:53:35,250 --> 00:53:36,480
вы просто выполняли постепенное медленное

1312
00:53:36,480 --> 00:53:38,609
обновление, потому что помните, что в обучении по телевидению

1313
00:53:38,609 --> 00:53:39,960
мы также как бы только делаем  как один

1314
00:53:39,960 --> 00:53:41,520
шаг резервного копирования по сравнению с своего рода

1315
00:53:41,520 --> 00:53:43,049
распространением всей нашей информации обратно,

1316
00:53:43,049 --> 00:53:47,880
как мы делаем с Монте-Карло, хорошо, так что

1317
00:53:47,880 --> 00:53:48,809
теперь мы собираемся дать вам

1318
00:53:48,809 --> 00:53:50,339
изучение временной разницы, и поэтому

1319
00:53:50,339 --> 00:53:51,690
помните во временной разнице  при обучении

1320
00:53:51,690 --> 00:53:53,730
мы собираемся использовать как бутстрэппинг, так и

1321
00:53:53,730 --> 00:53:55,770
семплирование. Монте-Карло использует сэмплирование только

1322
00:53:55,770 --> 00:53:58,380
для приближения к ожиданию. ТВ-

1323
00:53:58,380 --> 00:53:59,970
обучение также использует бутстрэппинг, потому что

1324
00:53:59,970 --> 00:54:01,140
нам не нужно ждать конца

1325
00:54:01,140 --> 00:54:04,049
эпизода, мы просто бутстрэпим и

1326
00:54:04,049 --> 00:54:06,329
объединяем в нашей оценке ожидаемого

1327
00:54:06,329 --> 00:54:08,099
дисконтированная сумма возвратов с использованием нашей

1328
00:54:08,099 --> 00:54:11,309
функции текущего значения, поэтому в этом

1329
00:54:11,309 --> 00:54:13,799
случае мы использовали для начальной загрузки

1330
00:54:13,799 --> 00:54:19,829
это часть начальной загрузки, и

1331
00:54:19,829 --> 00:54:21,390
наша цель, которую мы часто называем нашей целью, — это

1332
00:54:21,390 --> 00:54:23,339
вознаграждение плюс гамма, умноженная на значение

1333
00:54:23,339 --> 00:54:25,200
следующего состояния, и я  помните, причина, по которой

1334
00:54:25,200 --> 00:54:28,470
это выборка, заключается в том, что мы делаем выборку,

1335
00:54:28,470 --> 00:54:31,020
чтобы аппроксимировать наше ожидание, мы не

1336
00:54:31,020 --> 00:54:32,849
берем полную вероятность s простого числа при

1337
00:54:32,849 --> 00:54:35,990
заданном si и не суммируем по всем s простым числам,

1338
00:54:35,990 --> 00:54:38,880
поэтому, прежде чем мы сделали это, и мы представили

1339
00:54:38,880 --> 00:54:41,579
все в виде таблицы, теперь мы  не

1340
00:54:41,579 --> 00:54:43,039
хочу больше этого делать,

1341
00:54:43,039 --> 00:54:46,140
поэтому позвольте мне, прежде чем мы перейдем к этому, позвольте

1342
00:54:46,140 --> 00:54:47,819
мне просто напомнить нам о трех формах яйца,

1343
00:54:47,819 --> 00:54:49,890
или они являются формами приближения, которые

1344
00:54:49,890 --> 00:54:51,210
у нас будут сейчас, теперь мы

1345
00:54:51,210 --> 00:54:53,390
собираемся  есть аппроксимация функции,

1346
00:54:53,390 --> 00:55:04,619
начальная загрузка и выборка, но мы все

1347
00:55:04,619 --> 00:55:06,119
еще в политике, что я имею в виду под этим,

1348
00:55:06,119 --> 00:55:07,680
прямо сейчас мы все еще просто делаем оценку политики,

1349
00:55:07,680 --> 00:55:09,510
что означает, что мы получаем

1350
00:55:09,510 --> 00:55:11,099
данные из политики, которую мы

1351
00:55:11,099 --> 00:55:13,170
пытаемся оценить, ее значение превращается

1352
00:55:13,170 --> 00:55:14,850
В этом случае все намного проще,

1353
00:55:14,850 --> 00:55:16,890
когда вы придерживаетесь политики, и, возможно,

1354
00:55:16,890 --> 00:55:18,720
они должны быть несколько интуитивными, это

1355
00:55:18,720 --> 00:55:20,010
очень похоже на контролируемое обучение.

1356
00:55:20,010 --> 00:55:22,140


1357
00:55:22,140 --> 00:55:23,850


1358
00:55:23,850 --> 00:55:25,560


1359
00:55:25,560 --> 00:55:29,130
сложнее этого, но то, что наши

1360
00:55:29,130 --> 00:55:31,020
данные ближе к этому в этом случае, потому что

1361
00:55:31,020 --> 00:55:32,640
у нас есть единственная политика, она не обслуживается

1362
00:55:32,640 --> 00:55:34,380
этим нестационарным аспектом, который возникает,

1363
00:55:34,380 --> 00:55:36,360
когда мы начинаем менять политику, поэтому

1364
00:55:36,360 --> 00:55:37,740
прямо сейчас у нас есть эти три формы

1365
00:55:37,740 --> 00:55:39,300
аппроксимации функции аппроксимации

1366
00:55:39,300 --> 00:55:41,310
начальной загрузки  выборка, но мы все

1367
00:55:41,310 --> 00:55:42,960
еще придерживаемся политики, и в основном все

1368
00:55:42,960 --> 00:55:44,400
будет в порядке с точки зрения конвергенции,

1369
00:55:44,400 --> 00:55:47,790
так что это похоже на то, что мы снова

1370
00:55:47,790 --> 00:55:50,580
собираемся подумать о том, что делать.  g

1371
00:55:50,580 --> 00:55:52,110
эквивалент обучения с учителем, мы

1372
00:55:52,110 --> 00:55:54,120
хотели бы просто иметь наши состояния, и

1373
00:55:54,120 --> 00:55:55,830
Oracle сообщает нам, каково значение и соответствует

1374
00:55:55,830 --> 00:55:57,750
нашей функции, вместо того, чтобы иметь

1375
00:55:57,750 --> 00:55:59,430
Oracle, мы собираемся использовать наши оценки TD,

1376
00:55:59,430 --> 00:56:02,010
поэтому мы собираемся использовать наше слово

1377
00:56:02,010 --> 00:56:04,920
плюс гамма-время - это приблизительное

1378
00:56:04,920 --> 00:56:07,170
значение следующей даты, и это сформирует

1379
00:56:07,170 --> 00:56:10,140
нашу оценку того, что истинное значение в

1380
00:56:10,140 --> 00:56:12,720
порядке, а затем мы найдем

1381
00:56:12,720 --> 00:56:14,070
веса, чтобы минимизировать среднеквадратичную

1382
00:56:14,070 --> 00:56:19,520
ошибку в этой настройке, поэтому, если мы сделаем это,

1383
00:56:19,520 --> 00:56:21,660
что мы увидим  заключается в том, что если мы делаем

1384
00:56:21,660 --> 00:56:24,330
это через линейный случай, мы записываем

1385
00:56:24,330 --> 00:56:29,150
это, это просто цель TD,

1386
00:56:29,540 --> 00:56:31,950
просто в качестве быстрого примечания. Я буду часто

1387
00:56:31,950 --> 00:56:34,080
использовать слово TD ноль, мы не говорили

1388
00:56:34,080 --> 00:56:35,310
об этом в этом классе  но на

1389
00:56:35,310 --> 00:56:36,890
самом деле существует целая куча различных

1390
00:56:36,890 --> 00:56:40,650
вариантов TD, которые часто называют TV-

1391
00:56:40,650 --> 00:56:42,780
гаммой, и поэтому, если вы читаете

1392
00:56:42,780 --> 00:56:43,590
книгу, это может немного

1393
00:56:43,590 --> 00:56:44,850
сбить вас с толку, поэтому я просто хочу прояснить,

1394
00:56:44,850 --> 00:56:46,650
что мы делаем нулевой вариант TD,

1395
00:56:46,650 --> 00:56:47,720
который  вероятно, самый популярный,

1396
00:56:47,720 --> 00:56:50,310
есть много других расширений  ионный трюк

1397
00:56:50,310 --> 00:56:51,270
с простотой, мы сейчас просто

1398
00:56:51,270 --> 00:56:54,090
сосредоточимся на нулевом TD, так что это

1399
00:56:54,090 --> 00:56:57,900
цель TD I, это наша текущая оценка,

1400
00:56:57,900 --> 00:57:00,750
а затем мы берем производную в этом

1401
00:57:00,750 --> 00:57:02,250
случае, что означает, что мы собираемся в конечном

1402
00:57:02,250 --> 00:57:04,380
итоге подключить наш  аппроксиматор функции линейного значения

1403
00:57:04,380 --> 00:57:05,040


1404
00:57:05,040 --> 00:57:07,290
как для нашего текущего состояния, так и для следующего

1405
00:57:07,290 --> 00:57:09,510
состояния и рассмотрения этой разницы,

1406
00:57:09,510 --> 00:57:13,440
взвешенной вектором признаков, поэтому он

1407
00:57:13,440 --> 00:57:14,820
должен выглядеть почти идентично

1408
00:57:14,820 --> 00:57:16,950
обновлению Монте-Карло, за исключением того факта,

1409
00:57:16,950 --> 00:57:19,950
что теперь мы загружаемся, поэтому

1410
00:57:19,950 --> 00:57:24,710
вместо G как  являясь возвратом G того,

1411
00:57:24,710 --> 00:57:27,970
что мы видели раньше для конкретного,

1412
00:57:27,970 --> 00:57:29,650
так что теперь мы загружаемся и

1413
00:57:29,650 --> 00:57:31,869
получаем немедленное вознаграждение плюс

1414
00:57:31,869 --> 00:57:33,070
оценку летних вознаграждений со скидкой,

1415
00:57:33,070 --> 00:57:34,660
которые использовали наш

1416
00:57:34,660 --> 00:57:39,430
аппроксиматор функции ценности и оценивали, так что

1417
00:57:39,430 --> 00:57:42,820
это то, что TD  изучение

1418
00:57:42,820 --> 00:57:44,500
аппроксимации функции линейного значения для

1419
00:57:44,500 --> 00:57:46,240
алгоритма оценки политики выглядит так, как будто

1420
00:57:46,240 --> 00:57:47,770
мы снова инициализируем наш вектор весов,

1421
00:57:47,770 --> 00:57:49,930
мы собираемся сэмплировать кортеж, а затем

1422
00:57:49,930 --> 00:57:51,790
мы собираемся обновить наши веса  так что

1423
00:57:51,790 --> 00:57:53,080
теперь мы можем обновлять наши веса после

1424
00:57:53,080 --> 00:57:54,880
каждого отдельного кортежа, точно так же, как мы видели

1425
00:57:54,880 --> 00:57:57,580
для обучения TD, и здесь мы видим,

1426
00:57:57,580 --> 00:58:00,540
что мы просто подключаем

1427
00:58:00,540 --> 00:58:03,520
конкретную оценку - наша старая оценка умножается на

1428
00:58:03,520 --> 00:58:10,119
X, так что давайте посмотрим, как это

1429
00:58:10,119 --> 00:58:12,160
выглядит на  пример Барретта, так что снова у нас

1430
00:58:12,160 --> 00:58:13,330
есть то же

1431
00:58:13,330 --> 00:58:15,790
представление функции состояния, что и раньше, состояние один равно

1432
00:58:15,790 --> 00:58:19,000
двум ноль ноль ноль ноль ноль один

1433
00:58:19,000 --> 00:58:21,400
у нас все еще есть ноль слов для везде

1434
00:58:21,400 --> 00:58:24,910
давайте установим нашу альфу равной 0,5 теперь

1435
00:58:24,910 --> 00:58:26,830
мы находимся в том случае, когда мы можем сказать, что

1436
00:58:26,830 --> 00:58:29,230
нет конечного состояния, потому что телевизионное

1437
00:58:29,230 --> 00:58:31,000
обучение может обрабатывать только непрерывное

1438
00:58:31,000 --> 00:58:33,640
онлайн-обучение, поэтому мы просто

1439
00:58:33,640 --> 00:58:36,970
предполагаем, что s 7 всегда остается вместо s 7

1440
00:58:36,970 --> 00:58:41,800
под действием a1, поэтому a1 — сплошная линия,

1441
00:58:41,800 --> 00:58:46,390
а a2 — пунктирная, и мы собираемся

1442
00:58:46,390 --> 00:58:48,400
инициализировать  наши веса равны 1 1 1 1, а

1443
00:58:48,400 --> 00:58:51,400
затем давайте посмотрим на этот кортеж, так же,

1444
00:58:51,400 --> 00:58:52,869
как и в первой паре, которую мы видели раньше,

1445
00:58:52,869 --> 00:58:54,880
давайте представим, что мы находимся в состоянии 1, мы предприняли

1446
00:58:54,880 --> 00:58:56,830
действие a1, мы получили вознаграждение 0, мы перешли

1447
00:58:56,830 --> 00:59:00,339
в состояние s7, так почему бы не  мы возьмем

1448
00:59:00,339 --> 00:59:02,109
минуту, и вы посчитаете, что  новые

1449
00:59:02,109 --> 00:59:04,089
веса будут после того, как мы сделаем это обновление

1450
00:59:04,089 --> 00:59:06,070
и, возможно, сравним с делом Монте-

1451
00:59:06,070 --> 00:59:08,380
Карло с точки зрения того, насколько они

1452
00:59:08,380 --> 00:59:12,640
изменились, не стесняйтесь поговорить с

1453
00:59:12,640 --> 00:59:14,820
соседом

1454
00:59:19,800 --> 00:59:23,099
[музыка]

1455
00:59:30,680 --> 00:59:32,880
просто сделайте это немного больше, чтобы

1456
00:59:32,880 --> 00:59:36,680
было легко запомнить, что  s7

1457
01:00:32,319 --> 01:00:34,969
в порядке, они немного сдвинулись,

1458
01:00:34,969 --> 01:00:36,769
насколько изменились веса по сравнению

1459
01:00:36,769 --> 01:00:40,779
с тем, что мы видели с TD с Монте-Карло,

1460
01:00:42,969 --> 01:00:45,739
видели, как некоторые люди указывают меньше, да

1461
01:00:45,739 --> 01:00:48,200
, это правильно, хм, хорошо, так что

1462
01:00:48,200 --> 01:00:50,869
действительное начальное значение состояний это

1463
01:00:50,869 --> 01:00:55,549
будет  быть так 4x от s1 умноженное на W, это все

1464
01:00:55,549 --> 01:01:00,650
равно будет 3/4 X s простое число s простое равно 7, если

1465
01:01:00,650 --> 01:01:02,210
мы посмотрим, что это такое, это тоже

1466
01:01:02,210 --> 01:01:06,170
будет 3, но теперь

1467
01:01:06,170 --> 01:01:08,509
у нас будет дельта W  равно

1468
01:01:08,509 --> 01:01:14,289
альфа, умноженной на 0 плюс 0,9 умножить на 3 минус 3,

1469
01:01:14,289 --> 01:01:18,200
что будет равно альфа, умноженной на

1470
01:01:18,200 --> 01:01:23,059
минус 0,3, поэтому помните, что до того, как на

1471
01:01:23,059 --> 01:01:24,979
самом деле было минус 3, это было гораздо большее

1472
01:01:24,979 --> 01:01:28,579
обновление, и поэтому, когда мы добавим это в

1473
01:01:28,579 --> 01:01:31,430
наши новые веса, мы  мы собираемся перемещать наши

1474
01:01:31,430 --> 01:01:32,900
веса, но мы собираемся перемещать их намного

1475
01:01:32,900 --> 01:01:35,329
меньше, чем w  мы видели раньше, что это

1476
01:01:35,329 --> 01:01:37,369
не должно быть слишком удивительным, это в некотором роде

1477
01:01:37,369 --> 01:01:39,829
согласуется с тем, что мы видели для Монте-

1478
01:01:39,829 --> 01:01:42,079
Карло, Дэмиена и TD обучения ТВ-

1479
01:01:42,079 --> 01:01:44,269
обучение только обновляет такого рода

1480
01:01:44,269 --> 01:01:46,729
небольшие локальные изменения, такие как одно

1481
01:01:46,729 --> 01:01:49,430
действие состояния или где следующее самое высокое

1482
01:01:49,430 --> 01:01:52,640
состояние Монте-Карло  говорит, что это

1483
01:01:52,640 --> 01:01:55,339
эпизод, полный эпизодический возврат, это не

1484
01:01:55,339 --> 01:01:57,259
самозагрузка, так что на самом деле нет,

1485
01:01:57,259 --> 01:02:00,410
возврат от начала в состоянии s1 равен нулю,

1486
01:02:00,410 --> 01:02:02,779
поэтому мы собираемся переместить его намного дальше,

1487
01:02:02,779 --> 01:02:04,160
он говорит, хорошо, я собираюсь притвориться, что

1488
01:02:04,160 --> 01:02:06,979
их возвращение из состояния  s1 составляет две целых

1489
01:02:06,979 --> 01:02:09,769
семь десятых, что близко к трем, это не

1490
01:02:09,769 --> 01:02:12,799
ноль, поэтому, когда мы переместим наши веса

1491
01:02:12,799 --> 01:02:14,630
сюда, разница будет

1492
01:02:14,630 --> 01:02:16,279
намного меньше, чем то, что мы видели для Монте-

1493
01:02:16,279 --> 01:02:17,900
Карло, что похоже на то, что мы видели

1494
01:02:17,900 --> 01:02:19,950
без функции, кроме

1495
01:02:19,950 --> 01:02:22,240
всего, что угодно.  теоретические

1496
01:02:22,240 --> 01:02:25,630
свойства в этом случае довольно хороши, так

1497
01:02:25,630 --> 01:02:30,190
что они также, если вы посмотрите на ноль TV,

1498
01:02:30,190 --> 01:02:31,720
вы собираетесь сойтись двумя весами

1499
01:02:31,720 --> 01:02:33,160
, которые на самом деле не так хороши, как

1500
01:02:33,160 --> 01:02:34,930
Монте-Карло, но они находятся в пределах

1501
01:02:34,930 --> 01:02:38,020
постоянного коэффициента s  o они будут 1

1502
01:02:38,020 --> 01:02:40,480
на 1 минус гамма минимально

1503
01:02:40,480 --> 01:02:44,710
возможного, поэтому они не так хороши, как

1504
01:02:44,710 --> 01:02:48,970
Монте-Карло, но они довольно хороши, и в

1505
01:02:48,970 --> 01:02:51,609
зависимости от вашего коэффициента дисконтирования

1506
01:02:51,609 --> 01:02:54,039
и возможного аппроксиматора функции это

1507
01:02:54,039 --> 01:02:56,680
различается с точки зрения преимуществ, поэтому  просто чтобы

1508
01:02:56,680 --> 01:02:58,119
проверить наше понимание на секунду,

1509
01:02:58,119 --> 01:03:00,280
я представил оба этих результата, так что один

1510
01:03:00,280 --> 01:03:02,559
говорит, что оценщик политики Монте-Карло

1511
01:03:02,559 --> 01:03:04,240
сходится к минимальной среднеквадратической

1512
01:03:04,240 --> 01:03:06,099
ошибке, возможной при вашем

1513
01:03:06,099 --> 01:03:08,500
аппроксиматоре функции линейного значения, а td0

1514
01:03:08,500 --> 01:03:10,630
сходится к женщинам один на один минус

1515
01:03:10,630 --> 01:03:13,780
гамма  этой минимальной кривой, и еще раз,

1516
01:03:13,780 --> 01:03:15,549
какова эта минимальная ошибка, которая говорит, что если бы

1517
01:03:15,549 --> 01:03:17,829
вы могли выбрать любой аппроксиматор функции линейного значения,

1518
01:03:17,829 --> 01:03:20,530
насколько хорошо он мог бы

1519
01:03:20,530 --> 01:03:22,780
представлять вашу истинную ценность вашей

1520
01:03:22,780 --> 01:03:26,529
политики, так что давайте уделим еще минуту,

1521
01:03:26,529 --> 01:03:28,119
и это хорошо, чтобы поговорить с

1522
01:03:28,119 --> 01:03:29,829
сосед о том, является ли

1523
01:03:29,829 --> 01:03:31,420
аппроксиматор функции ценности табличным

1524
01:03:31,420 --> 01:03:35,079
представлением, что является их PE

1525
01:03:35,079 --> 01:03:38,520
как для Монте-Карло, так и для TD,

1526
01:03:45,310 --> 01:03:48,320
мы гарантируем сходимость к оптимальным

1527
01:03:48,320 --> 01:03:51,560
решениям, оптимальным  значение для истинного

1528
01:03:51,560 --> 01:04:07,880
значения для круговой диаграммы или нет, если

1529
01:04:07,880 --> 01:04:09,230
неясно, в чем вопрос, не стесняйтесь

1530
01:04:09,230 --> 01:04:25,880
спрашивать тип представления, что я

1531
01:04:25,880 --> 01:04:27,440
имею в виду под этим, я имею в виду, что есть одна

1532
01:04:27,440 --> 01:04:28,940
функция для каждого состояния, это как одна

1533
01:04:28,940 --> 01:04:30,710
горячая кодировка, так что это  как те же

1534
01:04:30,710 --> 01:04:32,390
представления, которые мы видели на первых нескольких

1535
01:04:32,390 --> 01:04:34,640
лекциях, где, например, для каждого штата у вас

1536
01:04:34,640 --> 01:04:36,410
есть табличный поиск значения

1537
01:04:36,410 --> 01:04:52,420
этого состояния I все, что мы видели в

1538
01:04:52,420 --> 01:04:54,860
России, знает о телевидении по сравнению с t0

1539
01:04:54,860 --> 01:04:56,120
все, о чем мы говорим в классе,

1540
01:04:56,120 --> 01:04:57,530
верно  сейчас td0,

1541
01:04:57,530 --> 01:04:59,480
я использую это, потому что есть

1542
01:04:59,480 --> 01:05:01,250
несколько версий TT, и если вы посмотрите

1543
01:05:01,250 --> 01:05:03,050
в книге, у них будет лямбда TT

1544
01:05:03,050 --> 01:05:05,660
иногда 2, поэтому я просто удостоверяюсь, что это

1545
01:05:05,660 --> 01:05:07,100
понятно, поэтому, если вы прочитаете другие ресурсы,

1546
01:05:07,100 --> 01:05:08,810
вы узнаете, какие  версии TD они

1547
01:05:08,810 --> 01:05:14,300
не являются - хорошо, хорошо, первый вопрос для

1548
01:05:14,300 --> 01:05:16,520
того, если мы используем табличное

1549
01:05:16,520 --> 01:05:19,130
представление, можем ли мы точно

1550
01:05:19,130 --> 01:05:29,900
представить значение политики, если мы используем,

1551
01:05:29,900 --> 01:05:31,820
если мы для каждого отдельного состояния в

1552
01:05:31,820 --> 01:05:34,220
мире, которое вы можете иметь  другая другая

1553
01:05:34,220 --> 01:05:36,440
таблица в представлении  Можем ли мы точно

1554
01:05:36,440 --> 01:05:41,960
представить значение политики? Да,

1555
01:05:41,960 --> 01:05:45,290
мы можем, поэтому, если у вас есть одна

1556
01:05:45,290 --> 01:05:46,940
функция для каждого штата в

1557
01:05:46,940 --> 01:05:48,230
мире, это не будет практично, мы на

1558
01:05:48,230 --> 01:05:49,820
самом деле не можем этого сделать, но вы можете

1559
01:05:49,820 --> 01:05:51,440
точно представить значение  политика,

1560
01:05:51,440 --> 01:05:53,180
как вы могли бы это сделать, вы могли бы просто

1561
01:05:53,180 --> 01:05:55,960
запустить политику для каждого отдельного штата, который

1562
01:05:55,960 --> 01:05:58,780
я делаю, Монте-Карло возвращает среднее значение, и

1563
01:05:58,780 --> 01:05:59,800
это даст вам истинную

1564
01:05:59,800 --> 01:06:01,420
стоимость штата, чтобы вы могли сделать это, вы могли бы

1565
01:06:01,420 --> 01:06:02,980
представить ожидать, что вы обесценили летние

1566
01:06:02,980 --> 01:06:04,839
доходы, представив это  в каждом

1567
01:06:04,839 --> 01:06:07,290
отдельном расписании, значит,

1568
01:06:07,290 --> 01:06:15,730
эта ошибка равна нулю, потому что ваших

1569
01:06:15,730 --> 01:06:18,940
функциональных возможностей достаточно, чтобы

1570
01:06:18,940 --> 01:06:37,720
представить значение в ожидании в

1571
01:06:37,720 --> 01:06:39,640
нуле, но в любых эпизодах оно

1572
01:06:39,640 --> 01:06:42,339
отличается в этом случае, если у вас есть

1573
01:06:42,339 --> 01:06:44,230
табличное представление, а это

1574
01:06:44,230 --> 01:06:45,730
в  предел, так что с бесконечными объемами

1575
01:06:45,730 --> 01:06:49,119
данных и т. д., тогда это будет

1576
01:06:49,119 --> 01:06:52,560
ноль для каждого отдельного состояния, поэтому это

1577
01:06:52,560 --> 01:06:55,839
равно нулю для каждого состояния, которое вы

1578
01:06:55,839 --> 01:06:57,790
сойдете к правильному значению для каждого

1579
01:06:57,790 --> 01:06:59,770
отдельного  состояние, если вы используете табличное

1580
01:06:59,770 --> 01:07:02,740
представление, и это потому, что если вы

1581
01:07:02,740 --> 01:07:03,940
думаете о буквально

1582
01:07:03,940 --> 01:07:05,950
бесконечном количестве данных и запускаете свою

1583
01:07:05,950 --> 01:07:07,420
политику, просто вы знаете бесконечное бесконечное

1584
01:07:07,420 --> 01:07:08,950
количество раз, то для каждого состояния у вас

1585
01:07:08,950 --> 01:07:10,420
есть бесконечное количество траекторий,

1586
01:07:10,420 --> 01:07:13,000
начиная с  это состояние, и вы можете

1587
01:07:13,000 --> 01:07:15,099
записать это значение отдельно в

1588
01:07:15,099 --> 01:07:17,680
таблицу, так что это будет сироп, так что это

1589
01:07:17,680 --> 01:07:19,720
означает, что ошибка среднего квадрата значения

1590
01:07:19,720 --> 01:07:21,460
для оценки Монте-Карло равна

1591
01:07:21,460 --> 01:07:23,290
нулю, если вы используете табличное

1592
01:07:23,290 --> 01:07:25,450
представление и потому что это ноль

1593
01:07:25,450 --> 01:07:28,060
это точно то же самое, что и

1594
01:07:28,060 --> 01:07:30,130
оценка среднего квадрата значения для TD, за

1595
01:07:30,130 --> 01:07:34,540
исключением того, что это просто равно M

1596
01:07:34,540 --> 01:07:37,510
SBE Монте-Карло, умноженному на 1 на 1 минус

1597
01:07:37,510 --> 01:07:41,410
гамма, так что это означает, что это также

1598
01:07:41,410 --> 01:07:44,200
равно нулю, поэтому, если это табличное представление,

1599
01:07:44,200 --> 01:07:47,890
просто для сортировки  подключиться к этому нет,

1600
01:07:47,890 --> 01:07:50,520
ни один из этих методов не имеет никакого ER, да,

1601
01:07:50,520 --> 01:07:53,880
и соседи,

1602
01:07:58,789 --> 01:08:00,960
да, и вопрос в том, вы знаете, откуда берется

1603
01:08:00,960 --> 01:08:02,490
эта 1 на 1 минус гамма-постоянная

1604
01:08:02,490 --> 01:08:04,349
в интересах времени, я не

1605
01:08:04,349 --> 01:08:05,630
г  Чтобы пройти через это слишком много, я

1606
01:08:05,630 --> 01:08:07,589
призываю вас прочитать это, так как это

1607
01:08:07,589 --> 01:08:08,900
закрытая статья,

1608
01:08:08,900 --> 01:08:11,099
интуитивно здесь есть ошибка, которая

1609
01:08:11,099 --> 01:08:12,990
распространяется здесь из-за

1610
01:08:12,990 --> 01:08:15,000
того, что мы загружаемся, и поэтому,

1611
01:08:15,000 --> 01:08:17,310
если у вас есть функция, что это,

1612
01:08:17,310 --> 01:08:18,779
что это за результат  своего рода попытка

1613
01:08:18,779 --> 01:08:20,250
подчеркнуть, что если ваш аппроксиматор функции на

1614
01:08:20,250 --> 01:08:23,069
самом деле не имеет ошибки, то

1615
01:08:23,069 --> 01:08:24,089
не будет никакой разницы между

1616
01:08:24,089 --> 01:08:26,819
Монте-Карло и TD, потому что для

1617
01:08:26,819 --> 01:08:29,670
них обоих среднеквадратическая ошибка значения

1618
01:08:29,670 --> 01:08:31,649
внутри этой суммы минимум по W

1619
01:08:31,649 --> 01:08:33,060
будет равен нулю, поэтому  не имеет значения,

1620
01:08:33,060 --> 01:08:35,189
используете ли вы TD или Монте-Карло, но если

1621
01:08:35,189 --> 01:08:36,630
это не так, например, если вы не можете

1622
01:08:36,630 --> 01:08:38,250
точно представить функцию значения,

1623
01:08:38,250 --> 01:08:40,198
тогда вы получите ошибку, и

1624
01:08:40,198 --> 01:08:43,139
эта ошибка будет похожа на то, что в основном вы

1625
01:08:43,139 --> 01:08:44,639
можете думать о 1  более 1 минус гамма - это

1626
01:08:44,639 --> 01:08:46,620
примерно горизонт H, и в

1627
01:08:46,620 --> 01:08:48,779
основном это умножается,

1628
01:08:48,779 --> 01:08:50,549
потому что вы суммируете эти ошибки,

1629
01:08:50,549 --> 01:08:52,620
и причина, по которой они складываются, заключается в том,

1630
01:08:52,620 --> 01:08:54,960
что вы загружаетесь, поэтому вы

1631
01:08:54,960 --> 01:08:56,759
распространяете это  ошибка назад, в то время как

1632
01:08:56,759 --> 01:09:01,859
Монте-Карло не страдает от того, что, как

1633
01:09:01,859 --> 01:09:03,509
правило, среднеквадратическая ошибка берется

1634
01:09:03,509 --> 01:09:06,389
за распределение состояний, которые

1635
01:09:06,389 --> 01:09:09,389
я не применяю, да, да, при

1636
01:09:09,389 --> 01:09:11,219
определенной политике, но единственное конкретное,

1637
01:09:11,219 --> 01:09:12,689
которое мы видели как стационарное

1638
01:09:12,689 --> 01:09:15,770
распределение, не так ли?  когда-либо использовать другой,

1639
01:09:15,770 --> 01:09:18,330
как отличный вопрос,

1640
01:09:18,330 --> 01:09:19,408
мое имя в порядке прямо сейчас, мы видим

1641
01:09:19,408 --> 01:09:20,609
это в стационарном

1642
01:09:20,609 --> 01:09:22,439
распределении состояний, которых вы собираетесь достичь в

1643
01:09:22,439 --> 01:09:24,299
соответствии с политикой, которую вы покидаете, которую

1644
01:09:24,299 --> 01:09:25,738
вы заботитесь об оценке для этого, я

1645
01:09:25,738 --> 01:09:26,880
думаю, что это  правильный выбор, потому

1646
01:09:26,880 --> 01:09:28,560
что это действительно состояния, в которые вы

1647
01:09:28,560 --> 01:09:30,330
попадете в соответствии с этой политикой, когда мы начнем

1648
01:09:30,330 --> 01:09:31,529
думать о контроле, вы можете захотеть, чтобы

1649
01:09:31,529 --> 01:09:33,330
другие хотели, если вы собираетесь изменить свою

1650
01:09:33,330 --> 01:09:38,069
политику, хорошо, так что давайте

1651
01:09:38,069 --> 01:09:40,319
я думаю, просто кратко подробнее об этом я

1652
01:09:40,319 --> 01:09:42,149
они быстрее, это один из них лучше, насколько мне

1653
01:09:42,149 --> 01:09:43,290
известно, это не совсем понятно,

1654
01:09:43,290 --> 01:09:44,549
если вы столкнетесь с какой-либо литературой, о

1655
01:09:44,549 --> 01:09:45,810
которой я хотел бы услышать, что

1656
01:09:45,810 --> 01:09:48,948
практически телевидение часто лучше просто

1657
01:09:48,948 --> 01:09:51,210
эмпирически часто загрузка отключена

1658
01:09:51,210 --> 01:09:53,759
и помогает  вы много, хорошо, давайте

1659
01:09:53,759 --> 01:09:57,150
вкратце перейдем к управлению, это будет

1660
01:09:57,150 --> 01:09:58,830
очень похоже, поэтому вместо

1661
01:09:58,830 --> 01:10:00,389
представления функции значения

1662
01:10:00,389 --> 01:10:01,710
мы собираемся представить функцию значения действия состояния,

1663
01:10:01,710 --> 01:10:03,449
которую мы видели

1664
01:10:03,449 --> 01:10:05,489
раньше, когда мы хотели часто переходить от

1665
01:10:05,489 --> 01:10:08,040
оценки политики к  контроль,

1666
01:10:08,040 --> 01:10:09,090
и теперь то, что мы собираемся сделать, мы

1667
01:10:09,090 --> 01:10:10,290
собираемся чередовать

1668
01:10:10,290 --> 01:10:11,760
оценку политики с аппроксиматором функции ценности

1669
01:10:11,760 --> 01:10:13,890
с

1670
01:10:13,890 --> 01:10:18,000
улучшением политики, например, с жадностью, здесь

1671
01:10:18,000 --> 01:10:20,400
все может начать становиться нестабильным, что

1672
01:10:20,400 --> 01:10:22,110
мы делаем в этом случае  мы обычно

1673
01:10:22,110 --> 01:10:23,430
используем аппроксимацию функции,

1674
01:10:23,430 --> 01:10:26,310
мы часто также делаем

1675
01:10:26,310 --> 01:10:30,030
выборку, но на самом деле действительно большая проблема,

1676
01:10:30,030 --> 01:10:32,700
кажется, заключается в обучении вне политики, но

1677
01:10:32,700 --> 01:10:34,290
когда мы думаем о том, что раньше у нас было это

1678
01:10:34,290 --> 01:10:36,030
хорошее стационарное распределение или

1679
01:10:36,030 --> 01:10:37,350
сходимость к стационарному распределению

1680
01:10:37,350 --> 01:10:39,780
по состояниям, мы не собираемся  делать

1681
01:10:39,780 --> 01:10:40,890
это больше, потому что мы собираемся

1682
01:10:40,890 --> 01:10:42,690
использовать нашу изменяющуюся политику управления с

1683
01:10:42,690 --> 01:10:44,370
течением времени, и это меняет

1684
01:10:44,370 --> 01:10:46,200
распределение s

1685
01:10:46,200 --> 01:10:49,110
Я часто называю

1686
01:10:49,110 --> 01:10:50,910
это смертельной триадой. Я говорю, что как только вы начнете

1687
01:10:50,910 --> 01:10:52,590
комбинировать аппроксимацию функций и

1688
01:10:52,590 --> 01:10:54,420
самонастройку, а также изучение политики,

1689
01:10:54,420 --> 01:10:57,540
все начнет получаться понемногу, они

1690
01:10:57,540 --> 01:10:59,160
могут не сойтись или сойтись к

1691
01:10:59,160 --> 01:11:01,440
чему-то хорошему, но прежде чем мы получим

1692
01:11:01,440 --> 01:11:02,400
в это давайте подумаем об этом

1693
01:11:02,400 --> 01:11:05,940
процедурно, так что теперь у нас будут

1694
01:11:05,940 --> 01:11:08,100
функции Q, которые параметризованы W,

1695
01:11:08,100 --> 01:11:10,350
и мы снова можем выполнить стохастический градиентный

1696
01:11:10,350 --> 01:11:12,210
спуск, это будет выглядеть почти

1697
01:11:12,210 --> 01:11:13,890
идентично тому, что у нас было раньше,

1698
01:11:13,890 --> 01:11:15,870
и снова стохастический градиентный

1699
01:11:15,870 --> 01:11:17,730
спуск может отобразить  градиент, который

1700
01:11:17,730 --> 01:11:19,850
означает, что для конкретной пары действий состояния

1701
01:11:19,850 --> 01:11:27,140
мы будем делать эти обновления, поэтому здесь мы собираемся

1702
01:11:27,140 --> 01:11:29,190


1703
01:11:29,190 --> 01:11:32,910
представить нашу Q-функцию набором

1704
01:11:32,910 --> 01:11:36,540
линейных весов действий состояния, так что это

1705
01:11:36,540 --> 01:11:38,130
означает, что мы собираемся  есть функции, которые

1706
01:11:38,130 --> 01:11:39,750
как бы кодируют состояние в

1707
01:11:39,750 --> 01:11:42,990
действии, например, то, что я видел, когда

1708
01:11:42,990 --> 01:11:45,450
поворачивал налево в роли моего робота,

1709
01:11:45,450 --> 01:11:48,120
так что это будет комбинация этих

1710
01:11:48,120 --> 01:11:50,130
двух, а затем один раз  у нас есть это, тогда

1711
01:11:50,130 --> 01:11:51,810
у нас будет просто вектор весов

1712
01:11:51,810 --> 01:11:55,200
поверх этого для Q, поэтому у нас

1713
01:11:55,200 --> 01:11:56,640
нет отдельных векторов весов для каждого

1714
01:11:56,640 --> 01:11:58,140
действия, и мы сказали, что у нас есть функции,

1715
01:11:58,140 --> 01:11:59,850
которые пытаются охватить как состояние, так и

1716
01:11:59,850 --> 01:12:02,550
само действие и  затем мы можем сделать наш

1717
01:12:02,550 --> 01:12:04,320
стохастический градиентный спуск поверх

1718
01:12:04,320 --> 01:12:11,910
этого, так как это работает, как в

1719
01:12:11,910 --> 01:12:14,130
Монте-Карло, он будет выглядеть почти

1720
01:12:14,130 --> 01:12:16,350
идентично тому, как до того, как мы просто снова будем

1721
01:12:16,350 --> 01:12:19,050
использовать наш возврат, как сейчас, мы

1722
01:12:19,050 --> 01:12:20,550
собираемся определять возвраты из

1723
01:12:20,550 --> 01:12:21,780
определенного состояния

1724
01:12:21,780 --> 01:12:23,909
chené мы делаем первое посещение, когда

1725
01:12:23,909 --> 01:12:25,320
впервые достигаем состояния действия в этом

1726
01:12:25,320 --> 01:12:27,809
эпизоде, мы смотрим на возврат

1727
01:12:27,809 --> 01:12:29,010
некоторых наград до конца эпизода,

1728
01:12:29,010 --> 01:12:30,840
и мы используем это в качестве нашей цели, потому

1729
01:12:30,840 --> 01:12:32,699
что это наша оценка ключа данных Oracle

1730
01:12:32,699 --> 01:12:35,360
функция, и мы обновляем ее в соответствии с тем, что

1731
01:12:35,360 --> 01:12:39,210
в sarsa мы собираемся использовать цель TD,

1732
01:12:39,210 --> 01:12:40,920
поэтому мы собираемся посмотреть на немедленную

1733
01:12:40,920 --> 01:12:43,889
награду нашего кортежа плюс гамма-кратность

1734
01:12:43,889 --> 01:12:45,539
Q следующего состояния, с которым мы столкнулись,

1735
01:12:45,539 --> 01:12:51,210
и действие, которое мы предприняли, и затем сказать

1736
01:12:51,210 --> 01:12:56,179
мы собираемся  просто подключите это, а

1737
01:12:56,179 --> 01:12:58,829
затем для обучения Q это будет выглядеть

1738
01:12:58,829 --> 01:13:00,690
почти идентично обучению Q, за исключением

1739
01:13:00,690 --> 01:13:01,650
того, что мы снова собираемся подключить

1740
01:13:01,650 --> 01:13:03,750
аппроксиматор функций повсюду, поэтому

1741
01:13:03,750 --> 01:13:07,619
мы собираемся подключить это, помните, что

1742
01:13:07,619 --> 01:13:10,380
это будет функция нашего X, которая

1743
01:13:10,380 --> 01:13:12,119
будет функцией s Prime и

1744
01:13:12,119 --> 01:13:15,000
простого x RW, где здесь это

1745
01:13:15,000 --> 01:13:17,719
будет функцией состояния в действии,

1746
01:13:17,719 --> 01:13:19,980
все линейно, и мы просто

1747
01:13:19,980 --> 01:13:21,210
делаем разные формы начальной загрузки

1748
01:13:21,210 --> 01:13:23,099
и сравниваем, берем ли мы это

1749
01:13:23,099 --> 01:13:28,619
максимально или нет  хорошо, так что я прошел

1750
01:13:28,619 --> 01:13:29,699
это немного быстро, но это в

1751
01:13:29,699 --> 01:13:31,980
основном точно аналогично первой

1752
01:13:31,980 --> 01:13:33,150
части, которую мы как бы прошли

1753
01:13:33,150 --> 01:13:35,250
более тщательно, это всегда все

1754
01:13:35,250 --> 01:13:38,219
с функциями Q теперь, почему это может

1755
01:13:38,219 --> 01:13:41,130
стать странным или сложным, так что TD с

1756
01:13:41,130 --> 01:13:42,750
приближением функции значения не  действительно

1757
01:13:42,750 --> 01:13:45,179
следуя градиенту, у меня нет времени

1758
01:13:45,179 --> 01:13:46,619
сегодня вдаваться в тонны деталей,

1759
01:13:46,619 --> 01:13:48,239
но

1760
01:13:48,239 --> 01:13:50,789
в главе 11 есть несколько хороших объяснений по этому поводу, так что,

1761
01:13:50,789 --> 01:13:55,800
несомненно, Умберто, глава 11, это отличный

1762
01:13:55,800 --> 01:13:58,230
ресурс и w  У нас также есть конспекты лекций,

1763
01:13:58,230 --> 01:13:59,369
доступные в Интернете,

1764
01:13:59,369 --> 01:14:03,480
хм, и поэтому неформально мы делаем

1765
01:14:03,480 --> 01:14:04,920
это чередование, делая это, например,

1766
01:14:04,920 --> 01:14:06,780
примерную резервную копию Беллмана в

1767
01:14:06,780 --> 01:14:08,550
сочетании с тем, что часто называют

1768
01:14:08,550 --> 01:14:10,409
шагом проекции, потому что мы пытаемся как

1769
01:14:10,409 --> 01:14:12,719
бы спроецировать нашу функцию значения назад.

1770
01:14:12,719 --> 01:14:14,190
в пространство представляемых

1771
01:14:14,190 --> 01:14:17,159
функций, и интуитивно, почему это

1772
01:14:17,159 --> 01:14:20,039
может стать проблемой, заключается в том, что

1773
01:14:20,039 --> 01:14:21,449
показанный нами оператор посыльного является

1774
01:14:21,449 --> 01:14:23,219
сокращением, например, когда мы занимаемся

1775
01:14:23,219 --> 01:14:24,960
динамическим программированием, мы показали, что если

1776
01:14:24,960 --> 01:14:26,909
вы выполняете операционный счет и резервное копирование посыльного,

1777
01:14:26,909 --> 01:14:28,590
вы гарантированно  чтобы сходиться к фиксированной

1778
01:14:28,590 --> 01:14:31,349
точке, когда вы выполняете аппроксимацию функции значения,

1779
01:14:31,349 --> 01:14:35,120
это может быть расширение

1780
01:14:35,120 --> 01:14:36,650
расширения, что означает сокращение,

1781
01:14:36,650 --> 01:14:38,330
просто напоминание о том, что такое

1782
01:14:38,330 --> 01:14:40,190
сторона сжатия, скажем, для оператора, который

1783
01:14:40,190 --> 01:14:43,960
является сокращением, если вы применяете этот оператор,

1784
01:14:43,960 --> 01:14:46,490
это оператор  как уравнение Беллмана,

1785
01:14:46,490 --> 01:14:48,800
возвращающееся обратно, если вы примените его

1786
01:14:48,800 --> 01:14:50,930
к двум разным функциям значений,

1787
01:14:50,930 --> 01:14:52,730
расстояние между ними может быть похоже на

1788
01:14:52,730 --> 01:14:54,800
максимальную норму или что-то в этом роде.  например, это

1789
01:14:54,800 --> 01:14:56,690
меньше или равно предыдущему расстоянию,

1790
01:14:56,690 --> 01:14:58,940
что означает, что, когда вы применяете этот оператор,

1791
01:14:58,940 --> 01:15:00,980
расстояние между вашей старой

1792
01:15:00,980 --> 01:15:02,270
функцией значения, которую вы выполняете,

1793
01:15:02,270 --> 01:15:03,530
становится все меньше и меньше и меньше

1794
01:15:03,530 --> 01:15:06,140
и в конечном итоге достигает фиксированной точки,

1795
01:15:06,140 --> 01:15:07,730
проблема в том, что теперь мы  больше этого не делать,

1796
01:15:07,730 --> 01:15:08,420


1797
01:15:08,420 --> 01:15:12,140
это больше похоже на то, что мы делаем как V, а

1798
01:15:12,140 --> 01:15:13,940
затем мы делаем какой-то оператор проецирования,

1799
01:15:13,940 --> 01:15:16,490
я просто назову его

1800
01:15:16,490 --> 01:15:18,950
странным P, так что это оператор проецирования,

1801
01:15:18,950 --> 01:15:22,100
который означает, когда вы вычисляете

1802
01:15:22,100 --> 01:15:24,170
новое значение  функции, он может больше не находиться

1803
01:15:24,170 --> 01:15:25,730
в пространстве аппроксиматора функции значения,

1804
01:15:25,730 --> 01:15:28,640
вам придется переустановить его обратно

1805
01:15:28,640 --> 01:15:30,830
в это пространство, и когда вы это сделаете, сам

1806
01:15:30,830 --> 01:15:34,120
этот оператор может быть расширением

1807
01:15:34,120 --> 01:15:36,200
для тех из вас, кто интересуется

1808
01:15:36,200 --> 01:15:37,970
некоторыми из ранних видов  Обсуждения

1809
01:15:37,970 --> 01:15:40,880
этого У Джеффа Гордона есть действительно хорошая статья

1810
01:15:40,880 --> 01:15:45,800
о средних значениях за 1995 год, в которой они говорили

1811
01:15:45,800 --> 01:15:47,210
о том, что аппроксиматор линейной функции значения

1812
01:15:47,210 --> 01:15:50,180
может быть расширением,

1813
01:15:50,180 --> 01:15:52,010
поэтому резервная копия посыльного в порядке, это

1814
01:15:52,010 --> 01:15:53,270
сокращение, но когда y  Если вы сделаете это

1815
01:15:53,270 --> 01:15:54,740
приближение, вы можете увеличить

1816
01:15:54,740 --> 01:15:56,980
расстояние, и это одна из проблем.

1817
01:15:56,980 --> 01:16:00,260
Итак, если мы вернемся к нашему

1818
01:16:00,260 --> 01:16:02,870
примеру Бэрда и подумаем об этом

1819
01:16:02,870 --> 01:16:06,440
немного больше с точки зрения контрольного случая, так что

1820
01:16:06,440 --> 01:16:07,790
давайте представим, что у нас есть настройка, в

1821
01:16:07,790 --> 01:16:10,850
которой у вас есть  две разные политики

1822
01:16:10,850 --> 01:16:12,650
и первая политика, и это

1823
01:16:12,650 --> 01:16:16,850
политика, которую вы хотите оценить, вы

1824
01:16:16,850 --> 01:16:19,370
всегда берете сплошную линию, поэтому вы всегда

1825
01:16:19,370 --> 01:16:23,060
берете 1, и в ваших данных о поведении

1826
01:16:23,060 --> 01:16:24,440
это данные, которые вы используете, это

1827
01:16:24,440 --> 01:16:26,810
политика, которую вы используете  чтобы собрать данные, вы

1828
01:16:26,810 --> 01:16:30,290
берете 2 с 6/7 времени, и вы

1829
01:16:30,290 --> 01:16:35,060
берете 1 1/7 времени, гамма равна 0,99,

1830
01:16:35,060 --> 01:16:38,120
и что вы делаете, так это генерируете целую

1831
01:16:38,120 --> 01:16:43,820
кучу данных, поэтому вы генерируете данные в соответствии с

1832
01:16:43,820 --> 01:16:47,170
вашей политикой поведения,

1833
01:16:50,050 --> 01:16:52,940
так что есть  некоторые действительно крутые работы о том, как

1834
01:16:52,940 --> 01:16:55,010
вы справляетесь с этим, я как бы

1835
01:16:55,010 --> 01:16:57,080
исправляю день, который вы получаете, по сравнению с

1836
01:16:57,080 --> 01:16:58,370
данными, которые вы хотите оценить, давайте представим, что

1837
01:16:58,370 --> 01:17:00,320
мы не будем вдаваться в то, что я

1838
01:17:00,320 --> 01:17:01,910
считаю супер крутым, и вместо этого мы

1839
01:17:01,910 --> 01:17:03,110
просто собираемся сделать что-то очень простое,

1840
01:17:03,110 --> 01:17:04,460
что мы собираемся  выбросить все

1841
01:17:04,460 --> 01:17:06,800
данные, которые не совпадают, поэтому представьте, что вы

1842
01:17:06,800 --> 01:17:15,260
просто выбрасываете данные, если они не

1843
01:17:15,260 --> 01:17:20,060
равны PI of s, поэтому вы сгенерировали все эти

1844
01:17:20,060 --> 01:17:21,920
точки данных, так что это значит, что я

1845
01:17:21,920 --> 01:17:24,620
имею в виду под точками данных здесь, у нас было si R  как

1846
01:17:24,620 --> 01:17:27,560
Prime, поэтому вы берете все эти кортежи, если

1847
01:17:27,560 --> 01:17:28,820
выяснится, что предпринятое

1848
01:17:28,820 --> 01:17:31,280
там действие не совпадает с политикой, которую вы

1849
01:17:31,280 --> 01:17:32,900
хотите оценить, где вы

1850
01:17:32,900 --> 01:17:34,520
когда-либо берете только 1, просто выбросьте этот

1851
01:17:34,520 --> 01:17:37,370
кортеж, который вы не обновляете  так что теперь все

1852
01:17:37,370 --> 01:17:39,170
ваши оставшиеся данные согласуются с

1853
01:17:39,170 --> 01:17:41,960
вашей политикой, так что давайте представим, что вы

1854
01:17:41,960 --> 01:17:43,840
пытались провести TD-обучение с этими данными,

1855
01:17:43,840 --> 01:17:47,630
проблема в том, что вы можете расходиться, и что

1856
01:17:47,630 --> 01:17:49,280
я имею в виду, что это означает, что ваши

1857
01:17:49,280 --> 01:17:52,280
веса могут взорваться очень интересно,

1858
01:17:52,280 --> 01:17:53,510
почему это  случается,

1859
01:17:53,510 --> 01:17:55,730
что основная интуиция заключается в том, что ваши

1860
01:17:55,730 --> 01:17:58,160
данные о распределении не совпадают с

1861
01:17:58,160 --> 01:17:59,210
данными, которые вы получили бы в соответствии с

1862
01:17:59,210 --> 01:18:02,840
желаемой целевой политикой, в частности, если бы

1863
01:18:02,840 --> 01:18:05,840
вы на самом деле запускали политику, которая

1864
01:18:05,840 --> 01:18:07,790
вам небезразлична. pi что произойдет

1865
01:18:07,790 --> 01:18:10,250
, скажем, вы начнете  в состоянии s1 вы

1866
01:18:10,250 --> 01:18:12,110
берете  e тот, который определенно заставляет вас

1867
01:18:12,110 --> 01:18:14,510
заявить s7, они будут оставаться в a7 в

1868
01:18:14,510 --> 01:18:15,920
течение очень долгого времени, потому что это

1869
01:18:15,920 --> 01:18:20,000
детерминировано, поэтому вы получите как s1 я

1870
01:18:20,000 --> 01:18:21,560
сказал уведомление я был скажем даже

1871
01:18:21,560 --> 01:18:23,090
ты сделал это может быть ты может быть это было

1872
01:18:23,090 --> 01:18:24,410
эпизодический случай, и у вас есть несколько

1873
01:18:24,410 --> 01:18:25,820
эпизодов, у вас все равно будут случаи, когда

1874
01:18:25,820 --> 01:18:27,710
вы хотели бы иметь очень небольшое

1875
01:18:27,710 --> 01:18:30,770
количество данных об этих SS и много

1876
01:18:30,770 --> 01:18:34,370
данных о s7, но в дату, которую вы получаете

1877
01:18:34,370 --> 01:18:35,930
из своей политики поведения, потому что

1878
01:18:35,930 --> 01:18:37,910
куча  времени, которое требуется - он будет

1879
01:18:37,910 --> 01:18:40,400
продолжать телепортировать вас обратно к одному из s1-

1880
01:18:40,400 --> 01:18:43,400
s6, что означает, что

1881
01:18:43,400 --> 01:18:45,110
распределение ваших данных, которые у вас есть, выглядит

1882
01:18:45,110 --> 01:18:46,700
совсем иначе, распределение

1883
01:18:46,700 --> 01:18:48,470
состояний, которые вы посещаете, выглядит совсем иначе,

1884
01:18:48,470 --> 01:18:50,420
чем данные, которые вы получаете.  состояния, которые

1885
01:18:50,420 --> 01:18:53,660
вы бы посетили в PI, и это

1886
01:18:53,660 --> 01:18:56,210
проблема, если вы не учитываете

1887
01:18:56,210 --> 01:18:57,830
это несоответствие, тогда значения могут

1888
01:18:57,830 --> 01:18:59,040
расходиться,

1889
01:18:59,040 --> 01:19:00,450
даже если они все вроде

1890
01:19:00,450 --> 01:19:02,610
совместимы в том смысле, что вы

1891
01:19:02,610 --> 01:19:05,700
только когда-либо используете действие состояния  пара, если вы

1892
01:19:05,700 --> 01:19:07,110
предприняли действие под  ваша желаемая

1893
01:19:07,110 --> 01:19:10,110
политика, и такого рода проблемы также могут

1894
01:19:10,110 --> 01:19:13,320
возникнуть при использовании обучения с помощью подсказок, и

1895
01:19:13,320 --> 01:19:14,580
вы, как правило, обновляете

1896
01:19:14,580 --> 01:19:19,440
эту политику с течением времени, поэтому с точки зрения

1897
01:19:19,440 --> 01:19:21,900
этого просто кратко подведем итоги, прежде чем

1898
01:19:21,900 --> 01:19:24,030
мы закончим в табличном случае, все

1899
01:19:24,030 --> 01:19:26,040
сходится, это красиво

1900
01:19:26,040 --> 01:19:34,110
в  линейный случай, который я имею в виду, я имею в виду,

1901
01:19:34,110 --> 01:19:39,270
что вы можете разрушить, вы в основном сходитесь,

1902
01:19:39,270 --> 01:19:42,360
но вы могли бы, я мог бы иметь некоторые

1903
01:19:42,360 --> 01:19:45,690
колебания, но q-обучение, например, когда

1904
01:19:45,690 --> 01:19:47,790
вы делаете этот аспект вне политики, может

1905
01:19:47,790 --> 01:19:50,910
расходиться, и как только мы попадаем в нелинейную

1906
01:19:50,910 --> 01:19:52,500
аппроксимацию функции ценности, все

1907
01:19:52,500 --> 01:19:53,550
как в основном все ставки сняты,

1908
01:19:53,550 --> 01:19:55,680
нет, это немного

1909
01:19:55,680 --> 01:19:58,860
упрощение, было

1910
01:19:58,860 --> 01:20:00,270
проделано огромное количество работы и огромный

1911
01:20:00,270 --> 01:20:01,560
интерес к этому, потому что все

1912
01:20:01,560 --> 01:20:03,840
хотят выполнять аппроксимацию функций с помощью RL, чтобы

1913
01:20:03,840 --> 01:20:05,760
мы могли решать реальные проблемы и

1914
01:20:05,760 --> 01:20:07,590
так далее  около одного или двух десятилетий

1915
01:20:07,590 --> 01:20:09,270
над этим была проделана огромная работа, и

1916
01:20:09,270 --> 01:20:10,980
теперь есть некоторые алгоритмы, которые действительно

1917
01:20:10,980 --> 01:20:13,650
имеют гарантии сходимости, и есть

1918
01:20:13,650 --> 01:20:16,320
некоторые очень крутые на самом деле  y недавняя работа, в которой

1919
01:20:16,320 --> 01:20:18,360
они рассматривают пакетное RL, которое может

1920
01:20:18,360 --> 01:20:20,220
сходиться с нелинейным аппроксиматором x',

1921
01:20:20,220 --> 01:20:22,800
так что определенно есть много работы по этому вопросу, к

1922
01:20:22,800 --> 01:20:24,510
которому мы не собираемся приступать. Я

1923
01:20:24,510 --> 01:20:25,830
просто хочу подчеркнуть, что это

1924
01:20:25,830 --> 01:20:27,000
действительно важный вопрос, а не просто

1925
01:20:27,000 --> 01:20:28,950
сходится ли оно, но к чему оно сходится,

1926
01:20:28,950 --> 01:20:31,020
как вы могли бы сходиться к точке, которая

1927
01:20:31,020 --> 01:20:32,760
является действительно плохим приближением,

1928
01:20:32,760 --> 01:20:34,890
поэтому оно стабильно, это не так, вы

1929
01:20:34,890 --> 01:20:36,510
удваиваете свои веса, но это

1930
01:20:36,510 --> 01:20:39,480
просто очень плохой приближение, и некоторые

1931
01:20:39,480 --> 01:20:40,530
из  критический выбор здесь ваша

1932
01:20:40,530 --> 01:20:41,640
целевая функция в вашем будущем

1933
01:20:41,640 --> 01:20:44,130
представлении, поэтому, прежде чем мы закончим, я

1934
01:20:44,130 --> 01:20:46,050
думаю, что это действительно хорошая фигура из

1935
01:20:46,050 --> 01:20:48,570
набора и умберто, что они показывают

1936
01:20:48,570 --> 01:20:49,890
здесь, вы можете думать об этом, как будто у вас

1937
01:20:49,890 --> 01:20:51,840
есть этот самолет, где вы можете

1938
01:20:51,840 --> 01:20:53,640
представляют все ваши

1939
01:20:53,640 --> 01:20:55,410
аппроксиматоры функции линейного значения z — и что

1940
01:20:55,410 --> 01:20:58,230
происходит, когда вы выполняете обновление Бельмонта или,

1941
01:20:58,230 --> 01:20:59,970
как вы делаете резервную копию TD, так это то, что теперь у вас

1942
01:20:59,970 --> 01:21:01,230
будет своего рода функция значения,

1943
01:21:01,230 --> 01:21:02,940
которая может быть непредставима

1944
01:21:02,940 --> 01:21:04,920
в вашем  плоскость, и вы собираетесь

1945
01:21:04,920 --> 01:21:07,410
спроецировать ее обратно, и эти разные

1946
01:21:07,410 --> 01:21:09,540
вы можете количественно определить разные формы

1947
01:21:09,540 --> 01:21:12,060
ошибок, в основном это позволяет

1948
01:21:12,060 --> 01:21:12,840
вам бороться с

1949
01:21:12,840 --> 01:21:14,700
различными целевыми функциями, которые

1950
01:21:14,700 --> 01:21:16,380
вы пытаетесь минимизировать, чтобы

1951
01:21:16,380 --> 01:21:18,750
найти лучший аппроксиматор, и мы

1952
01:21:18,750 --> 01:21:20,100
сегодня видел один, который является своего рода аппроксиматором

1953
01:21:20,100 --> 01:21:21,420
с минимальной среднеквадратичной ошибкой, по

1954
01:21:21,420 --> 01:21:24,390
сути, по сравнению с

1955
01:21:24,390 --> 01:21:26,100
этими ошибками Беллмана, но это не

1956
01:21:26,100 --> 01:21:28,020
единственный выбор, и это не обязательно

1957
01:21:28,020 --> 01:21:30,720
даже лучший выбор, потому что может быть так,

1958
01:21:30,720 --> 01:21:31,830
что тот, у которого есть наименьшая

1959
01:21:31,830 --> 01:21:33,420
ошибка, не  тот же самый, который имеет

1960
01:21:33,420 --> 01:21:36,270
наилучшую производительность в вашей реальной задаче, так

1961
01:21:36,270 --> 01:21:38,040
что это немного быстро, но это очень

1962
01:21:38,040 --> 01:21:39,780
интересно, это описано в наборах номер

1963
01:21:39,780 --> 01:21:41,250
два и одиннадцать, если вы хотите вдаваться в

1964
01:21:41,250 --> 01:21:42,990
подробности, просто очень быстро,

1965
01:21:42,990 --> 01:21:44,130
какие вещи вы должны понять, вы

1966
01:21:44,130 --> 01:21:45,870
должны  быть в состоянии реализовать их

1967
01:21:45,870 --> 01:21:47,190
на аппроксиматоре функции линейного значения

1968
01:21:47,190 --> 01:21:48,780
как для оценки политики, так и для контроля,

1969
01:21:48,780 --> 01:21:51,390
должен понимать, могут ли вещи сойтись или нет

1970
01:21:51,390 --> 01:21:54,360
в случае оценки политики,

1971
01:21:54,360 --> 01:21:56,760
когда решение имеет нулевую ошибку,

1972
01:21:56,760 --> 01:21:59,160
ненулевую ошибку, и вы должны просто

1973
01:21:59,160 --> 01:22:00,690
качественно понять, какие

1974
01:22:00,690 --> 01:22:03,390
проблемы могут возникнуть, так что некоторые из

1975
01:22:03,390 --> 01:22:05,130
этих решений могут не всегда сходиться,

1976
01:22:05,130 --> 01:22:06,900
это эта комбинация

1977
01:22:06,900 --> 01:22:08,640
аппроксимации функции и политики

1978
01:22:08,640 --> 01:22:11,310
обучения все в порядке  так что этого достаточно,

1979
01:22:11,310 --> 01:22:12,510
чтобы начать с домашнего задания

1980
01:22:12,510 --> 01:22:14,340
два, с которым мы собираемся выпустить

1981
01:22:14,340 --> 01:22:16,110
это сегодня, а затем на следующей неделе мы

1982
01:22:16,110 --> 01:22:17,490
начнем говорить об углублении.

1983
01:22:17,490 --> 01:22:20,480
Спасибо.

