# 9\. Архитектуры CNN

На прошлом уроке мы узнали о наиболее популярных библиотеках и фреймворках для глубокого обучения, рассмотрели их особенности и области применения. В этой лекции мы поговорим об истории развития свёрточных нейросетей (CNN) и разберём наиболее популярные архитектуры.

## AlexNet

Мы уже упоминали нейросеть AlexNet в первой лекции, когда рассказывали о [соревновании](http://www.image-net.org/challenges/LSVRC/) ImageNet, где она достигла прорывных для своего времени результатов. Её архитектура состоит из пяти свёрточных слоёв, между которыми располагаются pooling-слои и слои нормализации, а завершают нейросеть три полносвязных слоя.

```
CONV1 — первый свёрточный слой
MAX POOL1 — первый pooling-слой
NORM1 — первая нормализация
CONV2 — второй свёрточный слой
MAX POOL2 — второй pooling-слой
NORM2 — вторая нормализация
CONV3 — третий свёрточный слой
CONV4 — четвёртый свёрточный слой
CONV5 — пятый свёрточный слой
Max POOL3 — третий pooling-слой
FC6 — полносвязный слой
FC7 — полносвязный слой
FC8 — полносвязный слой
```

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0018.jpg)

_Архитектура AlexNet_


На схеме архитектуры все выходные изображения делятся на два одинаковых участка — это связано с тем, что нейросеть обучалась на старых GPU GTX580, у которых было всего 3 ГБ видеопамяти. Для обработки использовались две видеокарты, чтобы параллельно выполнять операции над двумя частями изображения.

Изначально на вход подаётся фотография размером 227×227×3, и размер свёрточных фильтров первого слоя — 11×11\. Всего применяется 96 фильтров с шагом 4.

**Попробуйте догадаться, каким будет размер выходного изображения после первого слоя? Подсказка: (227 − 11) / 4 + 1 = 55**

_**Ответ:** Выражение выше находит ширину и высоту изображения, исходя из размера и шага фильтров. Поскольку их общее число равно 96, итоговый размер будет 55×55×96\. Кстати, его можно заметить на рисунке выше._

**А каким будет число параметров?**

_**Ответ:** (11×11×3)×96 = 34848\. Каждый из фильтров будет занимать локальную область 11x11x3, так как глубина входного изображения равнялась 3._

Если мы посмотрим на второй слой Max pooling, то в нём применяются фильтры 3×3 с шагом 2\. Используя те же вычисления, что и выше, получим размер выходного снимка 27×27×96\. Внимание, новый вопрос:

**Чему равно число параметров в pooling-слое?**

_**Ответ:** 0! Помните, что мы передаём веса в свёрточные слои, чтобы обучить нейросеть. Но в pooling-слоях мы просто уменьшаем размер изображения, поэтому в них нет изучаемых параметров._

Вы можете поупражняться и повторить процесс для каждого последующего слоя, выяснив выходные размеры и число параметров. Мы выписали готовые значения:

```
INPUT
 CONV1: 96 фильтров 11×11с шагом 4, отступ 0
 MAX POOL1: фильтры 3×3 с шагом 2
 NORM1: слой нормализации
 CONV2: 256 фильтров 5×5 с шагом 1, отступ 2
 MAX POOL2: фильтры 3×3 с шагом 2
 NORM2: слой нормализации
 CONV3: 384 фильтра 3×3 с шагом 1, отступ 1
 CONV4: 384 фильтра 3×3 с шагом, отступ 1
 CONV5: 256 фильтров 3×3 с шагом 1, отступ 1
 MAX POOL3: фильтры 3×3 с шагом 2
 FC6: 4096 нейронов
 FC7: 4096 нейронов
 FC8: 1000 нейронов (метки класса)
```

Также стоит упомянуть о нескольких важных параметрах нейросети.

*   AlexNet — первая архитектура, в которой применяется нелинейность ReLU.
*   Для нормализации используются отдельные слои. Как выяснилось позднее, они не дают значительного улучшающего эффекта и поэтому не распространены в современных архитектурах.
*   На этапе предварительной обработки используется очень большое дополнение данных.
*   Dropout 50% (то есть при регуляризации отсеивается половина нейронов).
*   Размер пакета — 128.
*   SGD Momentum 0.9.
*   Скорость обучения — 1e−2, снижается в 10 раз вручную, если точность в какой-то момент перестаёт меняться.
*   Затухание весов L2 — 5e−4.
*   В архитектуре используется ансамбль из 7 CNN — это позволило снизить процент ошибок с 18,2% до 16,4%.

AlexNet была первой свёрточной нейросетью, выигравшей соревнование по классификации ImageNet в 2012 году. Она до сих пор используется в некоторых проектах в качестве базовой архитектуры или для передачи обучения. Но с момента её создания появилось множество других моделей с гораздо лучшей точностью. Например, уже в 2013 году нейросеть ZFnet смогла достичь результата 11.7% — в ней AlexNet использовалась в качестве основы, но с изменёнными параметрами и слоями. О других архитектурах речь пойдёт ниже.

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0022.jpg)

## VGGNet

На диаграмме выше вы можете увидеть, что в 2014 году VGGNet достигла более чем в два раза лучшего результата по сравнению с AlexNet. Основная идея VGG-архитектур — использование большего числа слоёв с фильтрами меньшего размера. Существуют версии VGG-16 и VGG-19 с 16 и 19 слоями соответственно.

С маленькими фильтрами мы получим не так много параметров, но при этом сможем гораздо эффективнее обрабатывать их.

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0026.jpg)

Попробуем посчитать размер выходных изображений и число параметров точно так же, как мы это делали для AlexNet. Если вычислить объём памяти, необходимый для обработки одного изображения, то он будет равен примерно 100 МБ (только для прямого прохода). Это означает, что видеокарта с 5 ГБ памяти сможет обрабатывать всего 50 фотографий за раз.

```
INPUT:  memory: 224*224*3=150K params: 0
CONV3-64:  memory: 224*224*64=3.2M params: (3*3*3)*64 = 1,728
CONV3-64:  memory: 224*224*64=3.2M params: (3*3*64)*64 = 36,864
POOL2:  memory: 112*112*64=800K params: 0
CONV3-128:  memory: 112*112*128=1.6M params: (3*3*64)*128 = 73,728
CONV3-128:  memory: 112*112*128=1.6M params: (3*3*128)*128 = 147,456
POOL2:  memory: 56*56*128=400K params: 0
CONV3-256:  memory: 56*56*256=800K params: (3*3*128)*256 = 294,912
CONV3-256:  memory: 56*56*256=800K params: (3*3*256)*256 = 589,824
CONV3-256:  memory: 56*56*256=800K params: (3*3*256)*256 = 589,824
POOL2:  memory: 28*28*256=200K params: 0
CONV3-512:  memory: 28*28*512=400K params: (3*3*256)*512 = 1,179,648
CONV3-512:  memory: 28*28*512=400K params: (3*3*512)*512 = 2,359,296
CONV3-512:  memory: 28*28*512=400K params: (3*3*512)*512 = 2,359,296
POOL2:  memory: 14*14*512=100K params: 0
CONV3-512:  memory: 14*14*512=100K params: (3*3*512)*512 = 2,359,296
CONV3-512:  memory: 14*14*512=100K params: (3*3*512)*512 = 2,359,296
CONV3-512:  memory: 14*14*512=100K params: (3*3*512)*512 = 2,359,296
POOL2:  memory: 7*7*512=25K params: 0
FC:  memory: 4096 params: 7*7*512*4096 = 102,760,448
FC:  memory: 4096 params: 4096*4096 = 16,777,216
FC:  memory: 1000 params: 4096*1000 = 4,096,000
TOTAL memory: 24M * 4 bytes ~= 96MB / image (only forward! ~*2 for bwd)
TOTAL params: 138M parameters
```

Несколько фактов об архитектуре VGGNet:

*   Нейросеть заняла 2 место в задаче классификации и 1 место в локализации на соревновании ImageNet (при локализации необходимо не только классифицировать объект, но и обвести его в ограничивающие рамки).
*   Процедура обучения такая же, как у AlexNet.
*   Слои нормализации отсутствуют.

В прикладных задачах обычно используются архитектуры VGG16 или VGG19 (VGG19 работает лучше, но расходует больше памяти).

## GoogleNet

GoogleNet — ещё более глубокая архитектура с 22 слоями. Целью Google было разработать нейросеть с наибольшей вычислительной эффективностью. Для этого они придумали так называемый модуль Inception — вся архитектура состоит из множества таких модулей, следующих друг за другом.

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0037.jpg)

_Архитектура GoogleNet (Нажмите на картинку для увеличения)_


Также в GoogleNet нет полносвязных слоёв, и она содержит всего 5 миллионов параметров — в 12 раз меньше, чем у AlexNet.

В составе GoogleNet есть небольшая подсеть — Stem Network. Она состоит из трёх свёрточных слоёв с двумя pooling-слоями и располагается в самом начале архитектуры.

На схеме нейросети можно увидеть небольшие промежуточные «отростки» — это вспомогательные классификационные выходы для введения дополнительного градиента на начальных слоях.

Идея основного модуля Inception заключается в том, что он сам по себе является небольшой локальной сетью. Вся его работа состоит в параллельном применении нескольких фильтров на исходное изображение. Данные фильтров объединяются, и создаётся выходной сигнал, который переходит на следующий слой.

Но здесь же кроется проблема. Рассмотрим пример: возьмём упрощённую версию модуля Inception и попробуем посчитать размеры выходных изображений после применения каждого фильтра. При исходной фотографии 28×28×256 получим следующее:

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0048.jpg)

В результате вычислений мы обнаружили, что наш небольшой блок выполняет 854 миллиона операций! При этом pooling-слои не уменьшают размер объекта — это означает, что после каждого объединения фильтров он будет только расти, и вычисления станут очень дорогостоящими.

Чтобы этого избежать, введены так называемые «узкие места» — слои с фильтром 1×1, уменьшающие глубину изображения.

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0051.jpg)

_Уменьшение глубины изображения с помощью 32 фильтров 1×1_

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0054.jpg)

_Добавление дополнительных слоёв в модуль Inception_


Если мы вернёмся к нашему примеру и добавим к нему несколько дополнительных слоёв, то увидим, что вычислительная сложность уменьшилась почти в 2,5 раза.

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0055.jpg)

Использование таких модулей и отсутствие полносвязных слоёв делают GoogleNet очень эффективной и достаточно точной сетью. Но на этом развитие свёрточных архитектур не остановилось.

## ResNet

В 2015 году ResNet произвела настоящую революцию глубины нейросетей. Она состояла из 152 слоёв и снизила процент ошибок до 3,57% в соревновании классификации ImageNet. Это сделало её почти в два раза эффективнее GoogleNet.

Что же происходит с нейросетью, когда мы увеличиваем число слоёв? Можно ли, взяв обычную архитектуру вроде VGG, просто складывать всё больше и больше слоёв друг на друга и достигать лучшей точности? 

Нет, нельзя. Скорее всего, более глубокая нейросеть покажет даже худшие результаты как при обучении, так и при тестировании. И переобучение здесь не при чём, поскольку тогда тренировочная ошибка была бы низкой.

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0064.jpg)

Создатели ResNet предположили, что загвоздка кроется в оптимизации — более глубокие модели гораздо хуже поддаются настройке. Тогда они решили не складывать слои друг на друга для изучения отображения нужной функции напрямую, а использовать остаточные блоки, которые пытаются «подогнать» это отображение. Так ResNet стала первой [остаточной нейронной сетью](https://en.wikipedia.org/wiki/Residual_neural_network). Говоря простыми словами, она «перепрыгивает» через некоторые слои. Они больше не содержат признаков и используются для нахождения остаточной функции **_H(x) = F(x) + x_** вместо того, чтобы искать **_H(x)_** напрямую.

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0065.jpg)

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0067.jpg)

Нейросеть состоит из большого стека одинаковых остаточных блоков, каждый из которых имеет два свёрточных слоя 3×3\. Периодически число фильтров удваивается, а их размерность уменьшается с шагом 2 (/ 2 в каждом измерении). В самом начале архитектуры присутствует дополнительный свёрточный слой. Также у ResNet нет полносвязных слоёв в конце — используется только один слой с выходными классами. С увеличением числа слоёв для уменьшения размерности изображения применяются точно такие же дополнительные слои, как и в GoogleNet. 

И, наконец, несколько важных параметров:

*   После каждого свёрточного слоя используется пакетная нормализация.
*   SGD + Momentum 0.9.
*   Скорость обучения — 0.1, делится на 10 при затухании скорости изменения ошибки.
*   Размер мини-пакета — 256.
*   Затухание весов — 1e−5.
*   Dropout не используется.

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0073.jpg)

_Архитектура ResNet_


В результате экспериментов с ResNet выяснилось, что очень глубокие сети действительно можно обучить без ухудшения точности. Нейросеть достигла наименьшей ошибки в задачах классификации, которая превзошла даже человеческий результат.

## И ещё немного

Совершенствование свёрточных архитектур не закончилось — появились новые версии ResNet, достигающие лучших результатов ([Wide ResNet](https://arxiv.org/abs/1605.07146) и [ResNeXT](https://arxiv.org/abs/1611.05431)). В 2017 году представлена глубокая нейросеть [FractalNet](https://arxiv.org/abs/1605.07648), в которой уже нет остаточных соединений. Вместо них применяются более сложные конструкции, похожие на разветвлённые деревья.

![](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/cs231n_2017_lecture9_page-0097.jpg)

_Архитектура FractialNet_


CNN продолжают развиваться и активно используются в задачах классификации изображений.

А теперь попробуйте попрактиковаться и самостоятельно написать код для обучения нейронных сетей и CNN. Вам понадобится Python > 3.6 и среда Jupyter Notebook или Jupyter Lab. Задание включает в себя материал, который мы изучили на последних нескольких лекциях: реализация обратного распространения ошибки (back propagation), оптимизация, пакетная нормализация, Dropout и обучение свёрточных нейросетей. Можете выбрать только те упражнения, которые кажутся вам наиболее полезными и интересными. Все инструкции и необходимые файлы можно скачать [отсюда](https://raw.githubusercontent.com/AlexandrParkhomenko/ai/main/Stanford/class/cs231n/ru/images/assignment2.zip).

Мы рассмотрели популярные свёрточные архитектуры и познакомились с их устройством. Обязательно выполните практическое задание: оно позволит глубже погрузиться в процесс обучения нейросетей и посмотреть на него изнутри.

А в следующий раз поговорим о рекуррентных нейронных сетях. 

С оригинальной лекцией можно ознакомиться на [YouTube](https://youtu.be/DAOcjicFr1Y).
