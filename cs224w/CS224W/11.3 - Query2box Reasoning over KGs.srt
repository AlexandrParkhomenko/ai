1
00:00:04,910 --> 00:00:08,609
So what I want to talk about next is a solution,

2
00:00:08,609 --> 00:00:10,635
uh, to- to these questions.

3
00:00:10,635 --> 00:00:11,880
And in- in particular,

4
00:00:11,880 --> 00:00:14,520
the method we'll talk about is called Query2box,

5
00:00:14,520 --> 00:00:20,175
that allows us to reason over knowledge graphs using what is called, uh, Box Embeddings.

6
00:00:20,175 --> 00:00:21,300
So let me first,, uh,

7
00:00:21,300 --> 00:00:24,855
motivate the setting, and then give you how this method works.

8
00:00:24,855 --> 00:00:30,995
So we said we wanna answer more complex predictive queries on, uh, graphs.

9
00:00:30,995 --> 00:00:34,565
And let's say that we wanna be able to also include conjunctions,

10
00:00:34,565 --> 00:00:37,850
so not just sets, but also intersections.

11
00:00:37,850 --> 00:00:42,500
We wanna be able to take an intersection of two sets in the embedding space.

12
00:00:42,500 --> 00:00:45,290
What we need to be able to do is two things.

13
00:00:45,290 --> 00:00:48,680
We need to be able to now figure out how are we going to

14
00:00:48,680 --> 00:00:53,605
represent a set of entities in the embedding space?

15
00:00:53,605 --> 00:00:58,775
And then, how are we going to define the intersection operator in the embedding space?

16
00:00:58,775 --> 00:01:00,720
How do we quickly take, uh,

17
00:01:00,720 --> 00:01:02,465
two sets of entities and say,

18
00:01:02,465 --> 00:01:06,365
what are the entities that are in the intersection, uh, between them?

19
00:01:06,365 --> 00:01:08,990
So let's see how to do that.

20
00:01:08,990 --> 00:01:11,445
The key inside that, uh,

21
00:01:11,445 --> 00:01:15,610
will allow us to do this is the concept of a box eEmbedding.

22
00:01:15,610 --> 00:01:20,450
What this means is that we're going to embed all the entities,

23
00:01:20,450 --> 00:01:25,700
and the relations in our space as boxes,

24
00:01:25,700 --> 00:01:30,030
as, uh, multidimen- dimensional, uh, rectangles.

25
00:01:30,030 --> 00:01:32,640
And the intuition would be that every box is

26
00:01:32,640 --> 00:01:36,225
defined by two points where it's defined by the center,

27
00:01:36,225 --> 00:01:38,010
and is defined by the corner.

28
00:01:38,010 --> 00:01:39,100
We'll call the center,

29
00:01:39,100 --> 00:01:41,650
center, and we'll call the corner, offset.

30
00:01:41,650 --> 00:01:43,180
So this basically tells me, you know,

31
00:01:43,180 --> 00:01:45,670
what is the offset in, uh, one dimension?

32
00:01:45,670 --> 00:01:47,360
What is the offset in the other dimension?

33
00:01:47,360 --> 00:01:49,965
This basically tells me what is the size of the box.

34
00:01:49,965 --> 00:01:52,645
And intuitively, we want to,

35
00:01:52,645 --> 00:01:55,525
uh, let say, in our case of Fulvestrant,

36
00:01:55,525 --> 00:02:02,385
we wanna embed all of its side effects in a- in a box, uh, that is,

37
00:02:02,385 --> 00:02:04,380
uh- so that in basically, uh,

38
00:02:04,380 --> 00:02:08,675
all the side effects caused by Fulvestrant will be- will be embedded close together,

39
00:02:08,675 --> 00:02:10,880
and they will be enclosed in this,

40
00:02:10,880 --> 00:02:12,515
uh, in this box.

41
00:02:12,515 --> 00:02:14,495
So that's the- that's the idea.

42
00:02:14,495 --> 00:02:16,100
So let me now tell you,

43
00:02:16,100 --> 00:02:18,140
uh, keep kind of building on this.

44
00:02:18,140 --> 00:02:21,380
So, um, the reason why we wanna embed things as

45
00:02:21,380 --> 00:02:25,580
boxes is because intersection of boxes is well-defined.

46
00:02:25,580 --> 00:02:27,530
Right? Basically, what I mean by that is,

47
00:02:27,530 --> 00:02:29,165
uh, if you take two boxes,

48
00:02:29,165 --> 00:02:30,560
and take an intersection,

49
00:02:30,560 --> 00:02:32,710
intersection of two boxes is a box.

50
00:02:32,710 --> 00:02:34,700
It can be an empty box,

51
00:02:34,700 --> 00:02:37,070
right, a box of size 0.

52
00:02:37,070 --> 00:02:39,845
But if there is any non-trivial overlap,

53
00:02:39,845 --> 00:02:41,420
that overlap will be a box.

54
00:02:41,420 --> 00:02:45,575
So it means we can now think about how are we going to define

55
00:02:45,575 --> 00:02:48,979
trans-geometric transformations over these boxes

56
00:02:48,979 --> 00:02:52,360
that corresponds to logical, uh, operators.

57
00:02:52,360 --> 00:02:55,790
Right? So when we traverse the knowledge graph to find answers,

58
00:02:55,790 --> 00:02:58,145
each step will basically, uh,

59
00:02:58,145 --> 00:03:00,485
produce a set of reachable entities,

60
00:03:00,485 --> 00:03:04,285
a set of entities that the query covers, uh, so far.

61
00:03:04,285 --> 00:03:08,180
Um, and we are going to now model this set of

62
00:03:08,180 --> 00:03:12,080
entities with a box that encloses all of them. All right.

63
00:03:12,080 --> 00:03:15,000
So, um, this means that we can,

64
00:03:15,000 --> 00:03:20,160
uh- that box provide a powerful obstruction because boxes kind of enclose,

65
00:03:20,160 --> 00:03:22,530
uh, sets of, uh, entities.

66
00:03:22,530 --> 00:03:26,180
And then we can define geometric intersection operator,

67
00:03:26,180 --> 00:03:27,785
uh, over, uh, let's say,

68
00:03:27,785 --> 00:03:29,540
two, or multiple boxes,

69
00:03:29,540 --> 00:03:31,285
and when- when we intersect them,

70
00:03:31,285 --> 00:03:33,195
the intersection is still a box.

71
00:03:33,195 --> 00:03:36,945
So we- it's very easy again to have this compositional property,

72
00:03:36,945 --> 00:03:38,250
where we can take boxes,

73
00:03:38,250 --> 00:03:40,300
intersect them in arbitrary ways,

74
00:03:40,300 --> 00:03:44,115
but, uh, we always are left of- are left out with a box,

75
00:03:44,115 --> 00:03:46,250
which we can further kind of manipulate,

76
00:03:46,250 --> 00:03:48,295
and change in shape however we like.

77
00:03:48,295 --> 00:03:50,010
So that's why this is kind of cool,

78
00:03:50,010 --> 00:03:52,740
um, and, uh, exciting.

79
00:03:52,740 --> 00:03:58,275
So, uh, what does it mean to be a- to be able to embed with boxes?

80
00:03:58,275 --> 00:04:01,585
Here is what we need to figure out or here's what we need to learn.

81
00:04:01,585 --> 00:04:03,235
We need to learn uh,

82
00:04:03,235 --> 00:04:05,755
opa- uh, we need to learn entity embeddings.

83
00:04:05,755 --> 00:04:08,500
So every embedding, entity will have an embedding,

84
00:04:08,500 --> 00:04:09,640
and it will be a box,

85
00:04:09,640 --> 00:04:12,430
but it will be a- a- a trivial box.

86
00:04:12,430 --> 00:04:13,995
So basically, it will be a point, right?

87
00:04:13,995 --> 00:04:18,675
It will be a box of a- a size 0, or volume 0.

88
00:04:18,675 --> 00:04:20,704
Then we'll have relation embeddings,

89
00:04:20,704 --> 00:04:22,460
which will basically, um,

90
00:04:22,460 --> 00:04:24,460
generalize the notion of params,

91
00:04:24,460 --> 00:04:28,365
where we are going to take- now learn how to move around,

92
00:04:28,365 --> 00:04:31,155
and, er, expand, or shrink boxes.

93
00:04:31,155 --> 00:04:34,680
So the relation embeddings will be like vectors,

94
00:04:34,680 --> 00:04:36,945
that are going to take boxes,

95
00:04:36,945 --> 00:04:38,385
and move them around.

96
00:04:38,385 --> 00:04:42,360
Then intersection operator is something that is- that is new.

97
00:04:42,360 --> 00:04:44,480
Uh, the intersection operator will take, uh,

98
00:04:44,480 --> 00:04:46,315
multiple boxes on the input,

99
00:04:46,315 --> 00:04:48,300
and will output a single box.

100
00:04:48,300 --> 00:04:52,290
And intuitively, this will be an intersection of, uh, boxes.

101
00:04:52,290 --> 00:04:55,770
But we are going to learn this, uh, intersection operator.

102
00:04:55,770 --> 00:04:58,850
Um, so it'll have some parameters so that our,

103
00:04:58,850 --> 00:05:01,055
uh, approach will be even more,

104
00:05:01,055 --> 00:05:03,235
uh, expressive, and more robust.

105
00:05:03,235 --> 00:05:05,370
So how will this work?

106
00:05:05,370 --> 00:05:07,050
Let me just kind of give you a cartoon.

107
00:05:07,050 --> 00:05:09,480
Again, we are talking about, uh, you know,

108
00:05:09,480 --> 00:05:12,480
what are drugs that cause shortness of breath,

109
00:05:12,480 --> 00:05:16,680
and treat diseases associated with protein, uh, ESR2?

110
00:05:16,680 --> 00:05:18,140
Uh, the way we do this,

111
00:05:18,140 --> 00:05:19,730
right, in terms of query plan,

112
00:05:19,730 --> 00:05:22,840
we say a-ha, we start with a anchor entity, ESR2.

113
00:05:22,840 --> 00:05:24,915
We wanna move across the, um,

114
00:05:24,915 --> 00:05:28,605
across the relationship called associated, uh, with.

115
00:05:28,605 --> 00:05:31,550
And the way we are going to do this is that we are going to define

116
00:05:31,550 --> 00:05:34,970
this relation projection operator P. Uh,

117
00:05:34,970 --> 00:05:36,125
here is how it's defined.

118
00:05:36,125 --> 00:05:38,540
We'll have one for every relation.

119
00:05:38,540 --> 00:05:41,570
And essentially what this will do is it will take one box,

120
00:05:41,570 --> 00:05:45,004
and it will kind of move it according to our given relation,

121
00:05:45,004 --> 00:05:47,780
and also, um, expand its,

122
00:05:47,780 --> 00:05:49,160
uh, or shrink its size.

123
00:05:49,160 --> 00:05:52,440
So basically, we will have, um,

124
00:05:52,440 --> 00:05:57,450
this learned, uh, ve- this learned operator for every relation.

125
00:05:57,450 --> 00:05:59,265
It's going to move the center,

126
00:05:59,265 --> 00:06:01,590
and it's going to change the offset.

127
00:06:01,590 --> 00:06:05,180
So basically, it will change the size as well as the location,

128
00:06:05,180 --> 00:06:06,290
uh, of the box.

129
00:06:06,290 --> 00:06:08,835
So I can start with, uh, q,

130
00:06:08,835 --> 00:06:10,695
and then I apply this, uh,

131
00:06:10,695 --> 00:06:14,640
projection r to it to get a new box, uh, q prime.

132
00:06:14,640 --> 00:06:17,265
So that's the projection operator.

133
00:06:17,265 --> 00:06:21,240
So how would this look in our case if I started the ESR2,

134
00:06:21,240 --> 00:06:24,395
and I wanna move across the associated relation?

135
00:06:24,395 --> 00:06:27,790
I would take this trivial box, apply my, uh,

136
00:06:27,790 --> 00:06:29,200
r- r- r associated,

137
00:06:29,200 --> 00:06:31,200
and basically, this would move it, uh,

138
00:06:31,200 --> 00:06:33,135
and expand it to include, uh,

139
00:06:33,135 --> 00:06:38,505
all the- all the diseases associated with, uh, ESR2.

140
00:06:38,505 --> 00:06:41,925
Now, um- now that I have a new box,

141
00:06:41,925 --> 00:06:44,660
I can again, simply kind of follow the query plan.

142
00:06:44,660 --> 00:06:47,820
Now I wanna traverse over a TreatedBy,

143
00:06:47,820 --> 00:06:51,585
which again, I would take this box, apply TreatedBy, uh,

144
00:06:51,585 --> 00:06:55,060
projection operator, the transformation to the box, which would, you know,

145
00:06:55,060 --> 00:06:56,605
further move it, and you know,

146
00:06:56,605 --> 00:06:57,910
expand or shrink it,

147
00:06:57,910 --> 00:06:59,620
depends what the model we learn.

148
00:06:59,620 --> 00:07:05,765
Uh, and then the idea is that whatever the answers to this path to a predictive query,

149
00:07:05,765 --> 00:07:07,130
those are the entities, uh,

150
00:07:07,130 --> 00:07:09,280
inside, uh, the box.

151
00:07:09,280 --> 00:07:11,955
And that's essentially the idea, right?

152
00:07:11,955 --> 00:07:15,380
Now, I can also try to answer the second part of the query,

153
00:07:15,380 --> 00:07:18,410
which is shortness of breath CausedBy.

154
00:07:18,410 --> 00:07:20,450
So I start with the shortness of breath entity,

155
00:07:20,450 --> 00:07:24,790
apply this CausedBy box transformation to get another box.

156
00:07:24,790 --> 00:07:28,410
And now, uh, what are the entities that are,

157
00:07:28,410 --> 00:07:30,530
uh, in the intersection of the two boxes?

158
00:07:30,530 --> 00:07:33,980
Uh, those will be basically the answers to my query.

159
00:07:33,980 --> 00:07:36,840
In our, uh- in our case, uh,

160
00:07:36,840 --> 00:07:39,240
this would be these, uh- these two entities,

161
00:07:39,240 --> 00:07:41,505
uh, fulvestrant, uh, and the other drug.

162
00:07:41,505 --> 00:07:43,260
Right? So that's essentially the idea.

163
00:07:43,260 --> 00:07:46,010
I have one box, I have the other box I'm interested

164
00:07:46,010 --> 00:07:49,390
in, what is the intersection, uh, of them?

165
00:07:49,390 --> 00:07:55,520
So that's, um, the idea about how would I do the embedding grid boxes?

166
00:07:55,520 --> 00:08:01,400
Now, let me talk about how does- how is this intersection operator, uh, really defined?

167
00:08:01,400 --> 00:08:06,230
Uh, one approach would be to simply define it as kind of hardcore,

168
00:08:06,230 --> 00:08:08,900
or just mathematically as intersection of boxes,

169
00:08:08,900 --> 00:08:11,125
almost like as- as in a Venn diagram.

170
00:08:11,125 --> 00:08:14,880
Uh, we wanna be a bit more, um, flexible.

171
00:08:14,880 --> 00:08:17,400
And we wanna do, uh, uh,

172
00:08:17,400 --> 00:08:20,849
and learn a geometric intersection operator,

173
00:08:20,849 --> 00:08:22,050
we'll call it J.

174
00:08:22,050 --> 00:08:25,140
Where the idea is we wanna take multiple boxes as input,

175
00:08:25,140 --> 00:08:26,760
and produce the intersection,

176
00:08:26,760 --> 00:08:28,210
uh, of these boxes.

177
00:08:28,210 --> 00:08:30,100
We'll call it the intersection box.

178
00:08:30,100 --> 00:08:31,480
Uh, and the intuition,

179
00:08:31,480 --> 00:08:34,179
we are going to use this to say the center of

180
00:08:34,179 --> 00:08:38,399
the new box should be close to the centers of the input boxes.

181
00:08:38,400 --> 00:08:41,690
So these are the three input boxes and the centers.

182
00:08:41,690 --> 00:08:45,840
Um, so we would like to take kind of intuitively the intersection between them.

183
00:08:45,840 --> 00:08:50,080
So we want the new center to be kind of a function of these three centers,

184
00:08:50,080 --> 00:08:53,250
and we want the intersection to be kind of close to- to them.

185
00:08:53,250 --> 00:08:54,935
And then the offset,

186
00:08:54,935 --> 00:08:56,465
so the size of the box,

187
00:08:56,465 --> 00:08:58,360
should shrink, since, uh,

188
00:08:58,360 --> 00:09:02,150
the size of the intersection is smaller than the size of,

189
00:09:02,150 --> 00:09:04,220
uh, any of the input sets,

190
00:09:04,220 --> 00:09:05,795
or any of the input boxes.

191
00:09:05,795 --> 00:09:07,220
So formally, we'll have

192
00:09:07,220 --> 00:09:11,315
this intersection operator that will take an arbitrary set of boxes,

193
00:09:11,315 --> 00:09:13,095
and produce a new box.

194
00:09:13,095 --> 00:09:19,264
Now the way we define this operator is we need to say what is happening to the center,

195
00:09:19,264 --> 00:09:22,780
and what is happening to the offset of the intersection.

196
00:09:22,780 --> 00:09:27,255
The way we are going to find the center of the intersection is,

197
00:09:27,255 --> 00:09:30,875
we are going to do this through a learned oper- operation.

198
00:09:30,875 --> 00:09:32,855
Our learning operation will take the following,

199
00:09:32,855 --> 00:09:36,630
it will take the centers of the boxes that are on

200
00:09:36,630 --> 00:09:41,115
the input and then we are going to learn this function, f,

201
00:09:41,115 --> 00:09:44,825
that takes a center of the box and, um,

202
00:09:44,825 --> 00:09:52,245
and transforms it and then we will apply softmax to this, uh, to dysfunctions.

203
00:09:52,245 --> 00:09:55,395
What this will allow us to do is that,

204
00:09:55,395 --> 00:09:59,735
basically the - the intuition is that the center of the intersection would be

205
00:09:59,735 --> 00:10:04,805
somewhere in this green region defined by the centers of the input boxes.

206
00:10:04,805 --> 00:10:09,400
We define the center as a weighted sum of the input box centers,

207
00:10:09,400 --> 00:10:12,230
where W is this weight,

208
00:10:12,230 --> 00:10:18,165
the importance of our- of our given box on the intersection of boxes.

209
00:10:18,165 --> 00:10:20,295
So, W represents, in some sense,

210
00:10:20,295 --> 00:10:24,060
a self attention score on the cen- how much a center of

211
00:10:24,060 --> 00:10:28,360
each input box affects the center of the intersection box.

212
00:10:28,360 --> 00:10:32,730
Uh, and this funny operator is called Hadamard product,

213
00:10:32,730 --> 00:10:34,865
which is basically element-wise product, right?

214
00:10:34,865 --> 00:10:36,620
It's just you - you uh - uh,

215
00:10:36,620 --> 00:10:38,955
take product of cells uh,

216
00:10:38,955 --> 00:10:41,610
that correspond, uh, to each other.

217
00:10:41,610 --> 00:10:45,170
So this is how center uh,

218
00:10:45,170 --> 00:10:46,640
is defined and of course,

219
00:10:46,640 --> 00:10:50,025
f is a function that we are going to learn.

220
00:10:50,025 --> 00:10:53,790
Similarly now, we also have to define the offset.

221
00:10:53,790 --> 00:10:57,180
And the way we are going to define the offset of the intersection is to

222
00:10:57,180 --> 00:11:00,900
take- is we'll take the min- smallest of all the input boxes,

223
00:11:00,900 --> 00:11:04,080
so we take the minimum in terms of the offsets.

224
00:11:04,080 --> 00:11:08,385
And then we are going to also learn this offset function,

225
00:11:08,385 --> 00:11:13,005
f offset, that is going to aggregate and transform the offsets.

226
00:11:13,005 --> 00:11:15,850
So here, the - the intuition is that if we first take

227
00:11:15,850 --> 00:11:20,160
the minimum of the offsets of input boxes and then make the model more

228
00:11:20,160 --> 00:11:25,830
expressive by introducing- introducing this new function f_off for extracting

229
00:11:25,830 --> 00:11:32,265
the representation of the input boxes with the sigmoid function to guarantee shrinking,

230
00:11:32,265 --> 00:11:34,470
uh, of the- of the offset.

231
00:11:34,470 --> 00:11:38,205
Again this f_off will have some trainable parameters uh,

232
00:11:38,205 --> 00:11:40,350
that will uh, that we are going to learn

233
00:11:40,350 --> 00:11:43,840
through the training process uh, of the entire model.

234
00:11:43,840 --> 00:11:46,480
So, uh, you know, intuitively,

235
00:11:46,480 --> 00:11:49,455
the idea is that once I have two boxes on the input,

236
00:11:49,455 --> 00:11:54,530
I wanna- I wanna produce the intersection of the two boxes and in our case,

237
00:11:54,530 --> 00:11:56,615
the intersection of the two boxes, for example,

238
00:11:56,615 --> 00:11:59,580
would be this, uh, shaded, uh, area here.

239
00:11:59,580 --> 00:12:04,685
Uh, and that- and whatever entities are enclosed or are close to this box,

240
00:12:04,685 --> 00:12:05,920
uh, those are the answers,

241
00:12:05,920 --> 00:12:08,580
uh, to our, uh, query.

242
00:12:08,580 --> 00:12:11,415
So now, what we need to do is,

243
00:12:11,415 --> 00:12:13,605
so far I said, oh, um,

244
00:12:13,605 --> 00:12:17,205
entities that are the answer that are included in the box,

245
00:12:17,205 --> 00:12:19,775
they have to be kind of inside the box, right?

246
00:12:19,775 --> 00:12:22,930
In reality, this might be uh, harder,

247
00:12:22,930 --> 00:12:26,190
because, uh, data is noisy, um, uh,

248
00:12:26,190 --> 00:12:28,050
there might be inconsistencies,

249
00:12:28,050 --> 00:12:29,785
contradictions in the knowledge graph,

250
00:12:29,785 --> 00:12:35,025
so we need to define the notion of distance between the box and a point.

251
00:12:35,025 --> 00:12:39,645
And the idea will be that, uh, we are going to define this distance to have two parts.

252
00:12:39,645 --> 00:12:43,470
We're going to define the distance from the center to the point,

253
00:12:43,470 --> 00:12:45,835
if the point is inside the box,

254
00:12:45,835 --> 00:12:47,220
and if it's outside the box,

255
00:12:47,220 --> 00:12:51,389
then we'll take the distance between the center and the corner and the corner,

256
00:12:51,389 --> 00:12:52,830
uh, and the point.

257
00:12:52,830 --> 00:12:57,490
Um, and the point here is that we wanna be able to uh,

258
00:12:57,490 --> 00:13:00,030
account for the distance differently.

259
00:13:00,030 --> 00:13:03,095
We wanna measure distance, uh, uh,

260
00:13:03,095 --> 00:13:05,140
from the center if, uh,

261
00:13:05,140 --> 00:13:09,300
when the- when the point is inside the box in some set of units.

262
00:13:09,300 --> 00:13:11,415
And then we are going to have this, uh,

263
00:13:11,415 --> 00:13:14,460
weight scalar Alpha that will, uh, uh,

264
00:13:14,460 --> 00:13:17,790
be less than one so that basically we- we are going to

265
00:13:17,790 --> 00:13:21,755
penalize the- the- the distance from the center of the box,

266
00:13:21,755 --> 00:13:23,805
uh, more if the point is, uh,

267
00:13:23,805 --> 00:13:25,605
inside than if it is,

268
00:13:25,605 --> 00:13:26,885
uh, outside the box.

269
00:13:26,885 --> 00:13:30,465
Uh, and the intuition is that if the point is enclosing the box,

270
00:13:30,465 --> 00:13:32,775
it should- the box should be, uh,

271
00:13:32,775 --> 00:13:34,185
it should be very close, uh,

272
00:13:34,185 --> 00:13:39,945
to the center of the box so that we get more robustness from our- from our approach.

273
00:13:39,945 --> 00:13:44,700
We don't want the point to be kind of close to the border or the edge of the box,

274
00:13:44,700 --> 00:13:48,570
we want it towards the center of the box.

275
00:13:48,570 --> 00:13:53,765
So that's how we now define the- the distance between the entity and the box.

276
00:13:53,765 --> 00:13:56,765
So now when we have the final embedding of the query,

277
00:13:56,765 --> 00:14:00,020
all we do is basically apply this distance, um,

278
00:14:00,020 --> 00:14:04,020
and say who are the points that are closest according to this distance,

279
00:14:04,020 --> 00:14:05,345
uh, to the center,

280
00:14:05,345 --> 00:14:07,245
uh, of the box.

281
00:14:07,245 --> 00:14:11,235
So now we have discussed two things.

282
00:14:11,235 --> 00:14:13,995
We discussed how we can embed everything, uh,

283
00:14:13,995 --> 00:14:15,630
all the entities as boxes,

284
00:14:15,630 --> 00:14:19,470
how we learn the- the box transformation operation,

285
00:14:19,470 --> 00:14:23,565
the projection operation that is one per relation,

286
00:14:23,565 --> 00:14:25,355
and then we talked about how we learn

287
00:14:25,355 --> 00:14:31,905
these intersection conjunction operator that takes the- as an input,

288
00:14:31,905 --> 00:14:32,985
a set of boxes,

289
00:14:32,985 --> 00:14:35,685
and produces the intersection box.

290
00:14:35,685 --> 00:14:39,065
Of course, our natural question next is,

291
00:14:39,065 --> 00:14:43,050
could I- could I have these predictive queries,

292
00:14:43,050 --> 00:14:45,575
uh, even with a union operator?

293
00:14:45,575 --> 00:14:49,215
So, for example, to be able to answer queries like OR.

294
00:14:49,215 --> 00:14:52,485
Um, and so next what we are going to look at is,

295
00:14:52,485 --> 00:14:56,295
how would you be able to answer what we will call AND-OR queries?

296
00:14:56,295 --> 00:15:01,890
Or what is technically called existential positive first-order queries.

297
00:15:01,890 --> 00:15:06,795
So basically, these are queries with conjunction and disjunction operator, right?

298
00:15:06,795 --> 00:15:10,325
So the question is, how would we be able to dis- are we able to

299
00:15:10,325 --> 00:15:13,800
design a disjunction operator and embed

300
00:15:13,800 --> 00:15:17,700
AND-OR queries in low dimensional vector space and be able to

301
00:15:17,700 --> 00:15:21,965
answer predictive AND-OR queries in the,

302
00:15:21,965 --> 00:15:23,805
uh, space as well.

303
00:15:23,805 --> 00:15:26,070
So the question is,

304
00:15:26,070 --> 00:15:30,590
can we embed AND- AND-OR queries in a low-dimensional space?

305
00:15:30,590 --> 00:15:32,775
The answer is actually no.

306
00:15:32,775 --> 00:15:36,485
The reason for that is that allowing union over

307
00:15:36,485 --> 00:15:40,890
arbitrary sets requires high dimensional embeddings.

308
00:15:40,890 --> 00:15:45,440
So let me quickly give you a sense why we need a lot of dimensions.

309
00:15:45,440 --> 00:15:48,390
Imagine I'm given three queries, q1, q2,

310
00:15:48,390 --> 00:15:51,915
q3, and each one of them has one answer.

311
00:15:51,915 --> 00:15:54,280
Uh, you know, q1 has v1 as an entity,

312
00:15:54,280 --> 00:15:55,865
v1 has answer q2,

313
00:15:55,865 --> 00:15:58,155
v2, and q3,

314
00:15:58,155 --> 00:16:00,045
v3 entity has the answer.

315
00:16:00,045 --> 00:16:03,740
So now, imagine I- I allow an entity operation, right,

316
00:16:03,740 --> 00:16:06,010
which basically means I can take, uh,

317
00:16:06,010 --> 00:16:08,940
any pair of queries and do an OR between them.

318
00:16:08,940 --> 00:16:11,145
So the answer set will be, uh,

319
00:16:11,145 --> 00:16:14,640
the answer set for the first query union the answer set,

320
00:16:14,640 --> 00:16:16,455
uh, of the second query.

321
00:16:16,455 --> 00:16:19,335
So given that we have two queries,

322
00:16:19,335 --> 00:16:22,530
sorry, given that we have three queries, the question is,

323
00:16:22,530 --> 00:16:26,770
uh, can- would we be able to model union operation when we embed them,

324
00:16:26,770 --> 00:16:29,055
let's say on a two-dimensional plane?

325
00:16:29,055 --> 00:16:30,880
And yes, you could, right?

326
00:16:30,880 --> 00:16:33,720
Basically, you say for every individual query,

327
00:16:33,720 --> 00:16:38,140
I can simply put a box around the entity and this would mean, uh,

328
00:16:38,140 --> 00:16:39,305
for a given query,

329
00:16:39,305 --> 00:16:44,085
I want the entity that is the answer to it to be inside the box and that's,

330
00:16:44,085 --> 00:16:45,930
uh, you know, easy to achieve.

331
00:16:45,930 --> 00:16:50,715
We can space these entities apart and put a box around each one of them and say,

332
00:16:50,715 --> 00:16:53,430
uh-huh, the box is the embedding of the query and

333
00:16:53,430 --> 00:16:56,420
the answer to the query is embedded inside the box.

334
00:16:56,420 --> 00:16:57,935
You know, all good.

335
00:16:57,935 --> 00:17:00,645
How about the unions?

336
00:17:00,645 --> 00:17:02,745
Um, in this case,

337
00:17:02,745 --> 00:17:04,954
I can easily, uh, do the union.

338
00:17:04,954 --> 00:17:08,494
This is, for example, how a box of union 1,

339
00:17:08,494 --> 00:17:12,299
query 1, union query 2 would look like so, uh,

340
00:17:12,300 --> 00:17:15,065
q1 or q2, this is how, uh,

341
00:17:15,065 --> 00:17:17,569
q2 or q3 would look like,

342
00:17:17,569 --> 00:17:18,779
and this is how uh,

343
00:17:18,780 --> 00:17:21,579
q1, uh, or q3, uh, would look like.

344
00:17:21,579 --> 00:17:28,039
So it seems it all works for three queries in two dimensions. However-

345
00:17:28,040 --> 00:17:30,730
What if we have four points?

346
00:17:30,730 --> 00:17:32,620
So imagine now I have four queries.

347
00:17:32,620 --> 00:17:36,235
I have four queries each one with one entity as the answer.

348
00:17:36,235 --> 00:17:40,795
Can I now use a two-dimensional space to embed them,

349
00:17:40,795 --> 00:17:46,750
um, and be able to do arbitrary unions between arbitrary queries?

350
00:17:46,750 --> 00:17:51,940
Uh, and it turns out I cannot design a box embedding such that, for example,

351
00:17:51,940 --> 00:17:58,330
in this case, that would represent the union of q, q_2, or q_4.

352
00:17:58,330 --> 00:18:03,190
Because there will always be some other kind of box or some other entity,

353
00:18:03,190 --> 00:18:05,950
um, uh, in- in between them, right?

354
00:18:05,950 --> 00:18:08,740
And if I move this entity away, perhaps here,

355
00:18:08,740 --> 00:18:13,315
then I won't be able to- to- to model the union between v_1 and v_4.

356
00:18:13,315 --> 00:18:17,800
So basically, um, there will always be, um, some issue.

357
00:18:17,800 --> 00:18:21,220
And, uh, what is the conclusion, or if you,

358
00:18:21,220 --> 00:18:24,745
um, if you do the, uh, mathematics carefully,

359
00:18:24,745 --> 00:18:29,335
what turns out is that if you have M, uh,

360
00:18:29,335 --> 00:18:34,945
queries or M entities with non-overlapping answers um,

361
00:18:34,945 --> 00:18:40,945
then you need the dimensionality of order M to handle arbitrary OR queries, right?

362
00:18:40,945 --> 00:18:44,725
So in our case, we said if I have three queries, I need two-dimensions,

363
00:18:44,725 --> 00:18:47,905
if I have four queries I need three-dimensions,

364
00:18:47,905 --> 00:18:49,135
and so on and so forth.

365
00:18:49,135 --> 00:18:55,105
So because real- real world knowledge graph have a lot of entities, for example,

366
00:18:55,105 --> 00:19:01,420
you know, FB15k has 15,000 entities and it's considered a small knowledge graph.

367
00:19:01,420 --> 00:19:04,450
This would mean that if we want to be able to- to uh,

368
00:19:04,450 --> 00:19:10,750
model arbitrary OR operation between arbitrary sets of entities,

369
00:19:10,750 --> 00:19:13,960
this would mean we need an embedding dimension of 15,000.

370
00:19:13,960 --> 00:19:15,610
And uh, that's far uh,

371
00:19:15,610 --> 00:19:18,835
far too much for us to be able to do this.

372
00:19:18,835 --> 00:19:23,050
So, um, it seems, um, hopeless, right?

373
00:19:23,050 --> 00:19:28,570
Since we cannot embed AND-OR queries in low-dimensional space can we still handle them?

374
00:19:28,570 --> 00:19:30,970
And actually, the answer is yes.

375
00:19:30,970 --> 00:19:36,730
And the answer is yes because we can rewrite the query to, um, in uh,

376
00:19:36,730 --> 00:19:41,365
into a different form so that the query is kind of logically equivalent,

377
00:19:41,365 --> 00:19:45,720
but the union operation happens all at the end, right?

378
00:19:45,720 --> 00:19:49,080
So the idea is if I have the original query plan, where I,

379
00:19:49,080 --> 00:19:50,865
you know take two projections,

380
00:19:50,865 --> 00:19:53,549
take the union, take one more projection,

381
00:19:53,549 --> 00:19:55,530
and take- then take an intersection,

382
00:19:55,530 --> 00:20:01,645
I can rewrite this into a different query plan that gives me the identical answer,

383
00:20:01,645 --> 00:20:06,085
it's logically equivalent, but the union only happens at the end.

384
00:20:06,085 --> 00:20:08,560
So why is this beneficial?

385
00:20:08,560 --> 00:20:12,100
Because I already know how to answer this part to get a box.

386
00:20:12,100 --> 00:20:15,610
I know how to answer this- this part up to here to get a box.

387
00:20:15,610 --> 00:20:18,835
So now, uh, write these the answer to my query?

388
00:20:18,835 --> 00:20:23,860
Is simply entities included in the first box and entities included in the second box.

389
00:20:23,860 --> 00:20:28,045
So that's very easy to do because the union occurs,

390
00:20:28,045 --> 00:20:31,705
uh, at, uh, always as- as a last step.

391
00:20:31,705 --> 00:20:37,015
So what is important is any AND-OR query can be transformed into uh,

392
00:20:37,015 --> 00:20:39,520
an equivalent what is called, um,

393
00:20:39,520 --> 00:20:44,395
disjunctive normal form, which is a disjunction of conjunctive queries.

394
00:20:44,395 --> 00:20:50,875
Um, and this means that if I have a query that's now a disjunction of conjunctions,

395
00:20:50,875 --> 00:20:53,560
I can simply first answer these conjunctions,

396
00:20:53,560 --> 00:20:57,820
and then take the OR or the union at the end.

397
00:20:57,820 --> 00:20:59,770
So it means, um,

398
00:20:59,770 --> 00:21:04,195
we can aggregate these unions uh, at the last step.

399
00:21:04,195 --> 00:21:10,780
That is one caveat is that when you do this transformation into disjunctive normal form,

400
00:21:10,780 --> 00:21:14,125
so from the original query to the disjunctive normal form,

401
00:21:14,125 --> 00:21:17,305
the size of the query can increase exponentially.

402
00:21:17,305 --> 00:21:18,640
Um, but in our case,

403
00:21:18,640 --> 00:21:21,265
this is not the problem because answering queries um,

404
00:21:21,265 --> 00:21:23,530
is so uh, is so fast,

405
00:21:23,530 --> 00:21:24,985
it's just kind of uh,

406
00:21:24,985 --> 00:21:26,740
navigating the embedding space.

407
00:21:26,740 --> 00:21:29,950
So this doesn't, uh, doesn't sound like too big,

408
00:21:29,950 --> 00:21:31,900
uh, of a problem.

409
00:21:31,900 --> 00:21:35,140
So now that we have um,

410
00:21:35,140 --> 00:21:41,250
defined the uh, the disjunctive normal form and we have rewritten the uh,

411
00:21:41,250 --> 00:21:47,020
the query as a set of conjunctive queries and then apply the OR operation at the end,

412
00:21:47,020 --> 00:21:51,970
then all we need to do is to change the notion of the distance between the query,

413
00:21:51,970 --> 00:21:55,090
the embedding of the query um, and the entity.

414
00:21:55,090 --> 00:21:58,210
And the way we can write this out mathematically is very intuitive.

415
00:21:58,210 --> 00:22:01,750
We say that um, the query in the disjunctive normal forum,

416
00:22:01,750 --> 00:22:05,365
conjunctive query q_1 or q_2 or q_3,

417
00:22:05,365 --> 00:22:08,050
we can simply define the distance between the embedding of

418
00:22:08,050 --> 00:22:11,380
this query and the entity to be- to be the minimum of

419
00:22:11,380 --> 00:22:14,920
the distances between the- the box distances

420
00:22:14,920 --> 00:22:17,590
between the individual conjunctive queries and that entity.

421
00:22:17,590 --> 00:22:21,340
So basically we say the entity is an answer uh,

422
00:22:21,340 --> 00:22:24,790
to the query if it is inside at

423
00:22:24,790 --> 00:22:28,660
least one of the individual conjunctive query boxes, right?

424
00:22:28,660 --> 00:22:32,620
So that it is close to at least one of the,

425
00:22:32,620 --> 00:22:34,615
uh, conjunctive queries q.

426
00:22:34,615 --> 00:22:36,700
So that's why we have the minimum here, right?

427
00:22:36,700 --> 00:22:39,534
So as long as v is the answer to the one conjunction,

428
00:22:39,534 --> 00:22:45,050
query q then the distance between that query and v will be uh, very small.

429
00:22:45,050 --> 00:22:51,045
And we achieve this by using this minimum uh, based uh, distance.

430
00:22:51,045 --> 00:22:55,510
So, um, this now, uh, er, uh,

431
00:22:55,510 --> 00:22:58,180
allows us basically to- to answer uh,

432
00:22:58,180 --> 00:23:01,330
arbitrary AND-OR predictive queries.

433
00:23:01,330 --> 00:23:03,160
So the way we would go about this,

434
00:23:03,160 --> 00:23:07,705
if- as we are given a query q at the beginning,

435
00:23:07,705 --> 00:23:11,020
we would rewrite it into a disjunctive normal form.

436
00:23:11,020 --> 00:23:15,700
So a, uh, disjunction of conjunctive queries q_1 to q_m.

437
00:23:15,700 --> 00:23:21,610
We would uh, embed this q_1 to q_m using this set of box operations,

438
00:23:21,610 --> 00:23:25,000
meaning uh, projections and uh, intersections.

439
00:23:25,000 --> 00:23:29,530
And then we would simply calculate the box distance between each q_i uh,

440
00:23:29,530 --> 00:23:36,490
from the disjunctive normal form and entity v and uh, take the minimum of these distances.

441
00:23:36,490 --> 00:23:40,360
And then the final score of an entity is simply the dista- is

442
00:23:40,360 --> 00:23:44,390
this minimum base distance between the entire uh, query uh, and uh,

443
00:23:44,390 --> 00:23:47,860
the- and the embedding of a given entity uh,

444
00:23:47,860 --> 00:23:52,915
for which we are interested in assessing how likely is that the entity an answer uh,

445
00:23:52,915 --> 00:23:55,285
to our uh, to our query.

446
00:23:55,285 --> 00:23:59,560
So now we have talked about how the method

447
00:23:59,560 --> 00:24:04,090
works from the point of view of once the embeddings are there,

448
00:24:04,090 --> 00:24:06,970
once the box operators are there, uh,

449
00:24:06,970 --> 00:24:11,380
how do we apply it to answer an arbitrary predictive query?

450
00:24:11,380 --> 00:24:17,425
The question is, uh what kind of training procedure do we use to learn this all?

451
00:24:17,425 --> 00:24:18,880
What does this mean is,

452
00:24:18,880 --> 00:24:22,840
we need basically a simil- a- a setup similar to knowledge graph

453
00:24:22,840 --> 00:24:27,235
completion task so that we can learn all these parameters, right?

454
00:24:27,235 --> 00:24:28,839
Um, when I say parameters,

455
00:24:28,839 --> 00:24:31,030
I mean we need to learn entity embeddings,

456
00:24:31,030 --> 00:24:33,340
we need to learn these relation embeddings,

457
00:24:33,340 --> 00:24:39,205
these box transformations, and we need to learn the intersection operator.

458
00:24:39,205 --> 00:24:44,335
And the way we are going to learn this is basically that we are going to select uh,

459
00:24:44,335 --> 00:24:47,365
or sample or create a set of queries.

460
00:24:47,365 --> 00:24:50,920
For every query, we are going to have a positive set of entities.

461
00:24:50,920 --> 00:24:52,570
This will be our set of answers.

462
00:24:52,570 --> 00:24:54,910
We are going to have a negative set of entities,

463
00:24:54,910 --> 00:24:56,920
this will be non-answers.

464
00:24:56,920 --> 00:25:00,790
And, uh, our goal will be to- to learn all these uh,

465
00:25:00,790 --> 00:25:04,840
parameters in such a way that answers are included

466
00:25:04,840 --> 00:25:09,895
in the final box and non-answers are uh, outside the box.

467
00:25:09,895 --> 00:25:13,780
So let me, uh, uh, summarize this.

468
00:25:13,780 --> 00:25:18,010
So we are going to first randomly sample query q from

469
00:25:18,010 --> 00:25:20,065
the training knowledge graph and

470
00:25:20,065 --> 00:25:25,090
identify an- an entity v that is the answer uh, to that query.

471
00:25:25,090 --> 00:25:29,215
Then we are also going to identify some negative entity,

472
00:25:29,215 --> 00:25:30,550
let's call it v prime,

473
00:25:30,550 --> 00:25:33,160
that is not an answer to the query, right?

474
00:25:33,160 --> 00:25:34,450
So for example, I could say,

475
00:25:34,450 --> 00:25:36,655
uh, I start uh, with uh,

476
00:25:36,655 --> 00:25:37,990
let's go back to our uh,

477
00:25:37,990 --> 00:25:40,390
Barack Obama nationality American.

478
00:25:40,390 --> 00:25:45,565
So, uh, I would say- I would sample a query um, uh, nationality.

479
00:25:45,565 --> 00:25:48,310
This is a simple kind of knowledge graph completion query,

480
00:25:48,310 --> 00:25:50,185
not even a multi- multi-hop.

481
00:25:50,185 --> 00:25:51,910
Uh, I start with Obama,

482
00:25:51,910 --> 00:25:53,410
along with the nationality,

483
00:25:53,410 --> 00:25:55,885
I find American, so that's a positive entity.

484
00:25:55,885 --> 00:26:00,175
And then perhaps I say a negative entity could be some other random uh,

485
00:26:00,175 --> 00:26:02,695
entity in uh, in the graph.

486
00:26:02,695 --> 00:26:05,590
Um, perhaps it could be Paris, uh,

487
00:26:05,590 --> 00:26:08,320
or if I want to be smarter I say I have the true entities

488
00:26:08,320 --> 00:26:11,200
of type Americans, so United States.

489
00:26:11,200 --> 00:26:14,500
So I want to pick another country, perhaps Germany,

490
00:26:14,500 --> 00:26:15,940
as a negative example,

491
00:26:15,940 --> 00:26:18,850
as a non-answer uh, to this query.

492
00:26:18,850 --> 00:26:21,265
Now that um, I,

493
00:26:21,265 --> 00:26:25,164
now that I have sampled the query and the answer and non-answer,

494
00:26:25,164 --> 00:26:32,035
I embed the query using the transformations and then I calculate the score function f uh,

495
00:26:32,035 --> 00:26:35,125
of entity v, which is the answer entity,

496
00:26:35,125 --> 00:26:36,640
and the entity v prime,

497
00:26:36,640 --> 00:26:39,640
which is the non-answer uh, entity.

498
00:26:39,640 --> 00:26:43,960
And then the goal is that now I can compute the gradients, uh,

499
00:26:43,960 --> 00:26:46,165
with respect, uh, to this, uh,

500
00:26:46,165 --> 00:26:49,990
loss function l where the goal is to maximize,

501
00:26:49,990 --> 00:26:53,995
uh, the- the score of the entity v. So basically, uh,

502
00:26:53,995 --> 00:26:56,605
it means maximize the negative distance,

503
00:26:56,605 --> 00:26:58,420
which means minimize the distance,

504
00:26:58,420 --> 00:27:02,965
while minimizing, uh, the distance of the non-answer.

505
00:27:02,965 --> 00:27:06,100
So the lo- the way we write the loss is, we say, uh, s- uh, uh,

506
00:27:06,100 --> 00:27:09,820
f- uh, Sigma is a sigmoid function,

507
00:27:09,820 --> 00:27:11,425
uh, that has value,

508
00:27:11,425 --> 00:27:12,730
you know, between 0 and 1,

509
00:27:12,730 --> 00:27:14,635
so basically, I'm saying I want,

510
00:27:14,635 --> 00:27:17,140
uh, to, uh, maximize, uh,

511
00:27:17,140 --> 00:27:19,360
f for, uh, the answer,

512
00:27:19,360 --> 00:27:20,935
and I wanna minimize,

513
00:27:20,935 --> 00:27:23,020
uh, f for the non-answer.

514
00:27:23,020 --> 00:27:26,440
And now I can take gradient or derivative with

515
00:27:26,440 --> 00:27:30,280
respect to this loss function to then be able to update

516
00:27:30,280 --> 00:27:34,180
both the entity embeddings as well as the projection and

517
00:27:34,180 --> 00:27:39,985
intersection operator parameters in order to be able to learn this, uh, well.

518
00:27:39,985 --> 00:27:45,670
Of course, we are not only to  going to sample one-hop queries,

519
00:27:45,670 --> 00:27:47,950
we are also going to sample two-hop queries,

520
00:27:47,950 --> 00:27:51,130
three-hop queries, intersection type queries, uh,

521
00:27:51,130 --> 00:27:53,695
all kinds of different, uh, query structures,

522
00:27:53,695 --> 00:27:54,970
and that will be, uh,

523
00:27:54,970 --> 00:27:56,740
our, uh, training set.

524
00:27:56,740 --> 00:27:58,060
And then given these queries,

525
00:27:58,060 --> 00:27:59,200
given an answer entity,

526
00:27:59,200 --> 00:28:00,955
the- and non-answer entity,

527
00:28:00,955 --> 00:28:03,895
we are going to, uh, optimize this likelihood,

528
00:28:03,895 --> 00:28:07,090
meaning we are going to find parameters of the model

529
00:28:07,090 --> 00:28:10,285
which is embeddings of entities plus these,

530
00:28:10,285 --> 00:28:12,685
uh, operators so that all these, uh,

531
00:28:12,685 --> 00:28:16,210
will, uh, optimize, uh, the loss function.

532
00:28:16,210 --> 00:28:18,700
So how do we, uh,

533
00:28:18,700 --> 00:28:20,380
how do we instantiate, uh,

534
00:28:20,380 --> 00:28:22,285
a query, uh, in the knowledge graph?

535
00:28:22,285 --> 00:28:25,690
We will assume we are given a query template, and then we, uh,

536
00:28:25,690 --> 00:28:28,075
in- instantiate the query, uh,

537
00:28:28,075 --> 00:28:30,625
will simply be to do the backward walking.

538
00:28:30,625 --> 00:28:33,595
Uh, what I mean by that is we are, uh,

539
00:28:33,595 --> 00:28:36,790
basically start from the initial answer entity,

540
00:28:36,790 --> 00:28:41,740
and then we are kind of going to walk backwards towards the anchored entities, right?

541
00:28:41,740 --> 00:28:43,210
So, um, in our case,

542
00:28:43,210 --> 00:28:44,440
for example, we could say,

543
00:28:44,440 --> 00:28:48,100
let's take fulvestrant as our, uh, answer entity.

544
00:28:48,100 --> 00:28:50,740
So now we are going- now that we have kind of

545
00:28:50,740 --> 00:28:53,650
randomly picked this entity from the knowledge graph,

546
00:28:53,650 --> 00:28:56,440
we're going to kind of move backward, uh,

547
00:28:56,440 --> 00:28:59,890
along the knowledge graph to then get the- the query plan,

548
00:28:59,890 --> 00:29:00,940
the query structure, right?

549
00:29:00,940 --> 00:29:02,590
So we are just at fulvestrant,

550
00:29:02,590 --> 00:29:04,720
then we, um, uh, move,

551
00:29:04,720 --> 00:29:08,529
we say we're- we will need to take intersection of two relations,

552
00:29:08,529 --> 00:29:09,940
relation 1 and relation 2,

553
00:29:09,940 --> 00:29:12,100
so let's pick two relations from,

554
00:29:12,100 --> 00:29:14,770
uh, fulvestrant and move backward.

555
00:29:14,770 --> 00:29:17,020
And then now that we are here,

556
00:29:17,020 --> 00:29:19,330
we moved across TreatedBy.

557
00:29:19,330 --> 00:29:22,255
Uh, now, we can again move one step, uh,

558
00:29:22,255 --> 00:29:25,795
backward along the projection operator, um,

559
00:29:25,795 --> 00:29:29,530
for the second type of relation like, uh, associated.

560
00:29:29,530 --> 00:29:33,025
And, uh, now this will now become my anchor entity.

561
00:29:33,025 --> 00:29:36,985
And now, uh, I do the same thing for the second relation,

562
00:29:36,985 --> 00:29:40,930
uh, here CausedBy and find the second, uh, anchor entity.

563
00:29:40,930 --> 00:29:45,835
So now I have just sampled the query that goes from ESR2 and shortness of breath,

564
00:29:45,835 --> 00:29:51,715
through associated TreatedBy, as well as from shortness of breath to CausedBy,

565
00:29:51,715 --> 00:29:54,010
and the intersection of them is the fulvestrant.

566
00:29:54,010 --> 00:29:56,890
So this is now my sampling, uh, of the query.

567
00:29:56,890 --> 00:29:58,705
And then what I can do is, uh,

568
00:29:58,705 --> 00:30:03,625
find some entity that is not answer to this query and use that as a,

569
00:30:03,625 --> 00:30:06,625
uh, non, uh, answer, right?

570
00:30:06,625 --> 00:30:10,660
Uh, it is important when we do this sampling to be careful, uh,

571
00:30:10,660 --> 00:30:13,150
because the query q must have answers,

572
00:30:13,150 --> 00:30:14,950
uh, on the KG.

573
00:30:14,950 --> 00:30:19,630
Um, and we will take one of the answers as instantiated, uh,

574
00:30:19,630 --> 00:30:21,415
uh, answer for our, uh,

575
00:30:21,415 --> 00:30:24,760
positive example, and, um,

576
00:30:24,760 --> 00:30:28,390
we're then going to basically randomly sample some negative,

577
00:30:28,390 --> 00:30:32,740
uh, examples, non-answers, which are basically other entities, uh,

578
00:30:32,740 --> 00:30:36,685
in the knowledge graph, but we have to be careful that we are not, uh,

579
00:30:36,685 --> 00:30:39,955
by accident sampling some other entity that's also,

580
00:30:39,955 --> 00:30:42,400
uh, answer, uh, to the query.

581
00:30:42,400 --> 00:30:45,895
So that's, uh, essentially the idea.

582
00:30:45,895 --> 00:30:50,455
Um, and the- the- the impressive thing is that we can actually make this,

583
00:30:50,455 --> 00:30:54,385
uh, all work and that now we are able to answer arbitrary, uh,

584
00:30:54,385 --> 00:30:57,070
predictive queries in knowledge graphs, uh,

585
00:30:57,070 --> 00:30:59,785
even though they might be notoriously, uh,

586
00:30:59,785 --> 00:31:02,290
incomplete or, uh, may not have,

587
00:31:02,290 --> 00:31:03,895
uh, uh, all the edges.

588
00:31:03,895 --> 00:31:05,590
And what I wanna do to, uh,

589
00:31:05,590 --> 00:31:08,260
finish the lecture is give you a quick,

590
00:31:08,260 --> 00:31:10,970
um, example of how would this look like.

591
00:31:10,970 --> 00:31:15,930
So, for example, here we are going to take the Freebase 15,000, uh,

592
00:31:15,930 --> 00:31:18,790
knowledge graph, which is a knowledge graph about, uh,

593
00:31:18,790 --> 00:31:20,980
real-world entities, uh, people,

594
00:31:20,980 --> 00:31:22,255
uh, things like that.

595
00:31:22,255 --> 00:31:25,225
And imagine we wanna have a query, uh, you know,

596
00:31:25,225 --> 00:31:30,795
who are all male instrumentalists who play string instruments, right?

597
00:31:30,795 --> 00:31:32,205
Uh, and we are going to, uh,

598
00:31:32,205 --> 00:31:35,865
use our system to learn the embedding of, uh,

599
00:31:35,865 --> 00:31:40,184
all the nodes, uh, all the entities to learn the projection operator,

600
00:31:40,184 --> 00:31:42,215
to learn the conjunction operator.

601
00:31:42,215 --> 00:31:45,465
Um, and then we are going to take this, uh,

602
00:31:45,465 --> 00:31:48,765
high-dimensional embedding and we are going to project it

603
00:31:48,765 --> 00:31:52,765
down to just two dimensions so we can visualize it, right?

604
00:31:52,765 --> 00:31:55,300
So, um, here's the visualization, right?

605
00:31:55,300 --> 00:31:57,190
So here is at, uh,

606
00:31:57,190 --> 00:31:59,844
15,000, uh, different dots,

607
00:31:59,844 --> 00:32:03,700
one corresponding to the embedding of, uh, each entity,

608
00:32:03,700 --> 00:32:06,520
and these are real entities with real embeddings,

609
00:32:06,520 --> 00:32:08,890
and here is our, uh, query plan, right?

610
00:32:08,890 --> 00:32:10,690
We, uh, we wanna answer, uh,

611
00:32:10,690 --> 00:32:14,124
you know, who are male instrumentalists who play string instruments,

612
00:32:14,124 --> 00:32:18,820
so we'll start with string instruments as the anchor entity, go over, um,

613
00:32:18,820 --> 00:32:24,565
the instance of relation to find all st- instances of string instruments,

614
00:32:24,565 --> 00:32:26,140
then we are going to go over,

615
00:32:26,140 --> 00:32:29,575
uh, PlayedBy, uh, relation, uh,

616
00:32:29,575 --> 00:32:32,320
to identify all the- all the people who

617
00:32:32,320 --> 00:32:35,140
play these string instruments, any of them, right?

618
00:32:35,140 --> 00:32:38,245
And then we are going to go from node male to say

619
00:32:38,245 --> 00:32:41,995
instance of to find all the instances of male, uh,

620
00:32:41,995 --> 00:32:43,749
males in our dataset,

621
00:32:43,749 --> 00:32:46,990
and now we need to take the intersection to find all the males

622
00:32:46,990 --> 00:32:50,395
who are also playing any of the string, uh, instruments.

623
00:32:50,395 --> 00:32:52,660
So let me show you how this, uh,

624
00:32:52,660 --> 00:32:56,184
actually works in this, uh, two-dimensional projection.

625
00:32:56,184 --> 00:32:58,930
So, uh, the anchor node for string instrument,

626
00:32:58,930 --> 00:33:00,370
if you would, uh, locate it,

627
00:33:00,370 --> 00:33:02,665
is actually here, uh, the blue one.

628
00:33:02,665 --> 00:33:07,990
Now I will take and apply a box transformation that will say,

629
00:33:07,990 --> 00:33:13,120
uh, what are the instances of the string, uh, instrument, right?

630
00:33:13,120 --> 00:33:15,085
What are all the individual string instruments?

631
00:33:15,085 --> 00:33:17,245
Um, and if I do this,

632
00:33:17,245 --> 00:33:19,270
um, actually notice now,

633
00:33:19,270 --> 00:33:24,250
um, the- the dot- the- the dots will have different types of colors.

634
00:33:24,250 --> 00:33:28,480
True-positive means, this is a string instrument inside the box.

635
00:33:28,480 --> 00:33:32,860
Um, false-negative means this is a string instrument outside the box.

636
00:33:32,860 --> 00:33:35,860
Uh, false-positive would be, um,

637
00:33:35,860 --> 00:33:39,700
other entities that are not string instruments but are inside the box.

638
00:33:39,700 --> 00:33:44,125
And true-entities are non-string instruments outside the box.

639
00:33:44,125 --> 00:33:47,020
And what you see here is that basically,

640
00:33:47,020 --> 00:33:51,865
we are able to perfectly enclose all the string instruments inside the box,

641
00:33:51,865 --> 00:33:54,340
and there are 10- 10, uh,

642
00:33:54,340 --> 00:33:57,325
instances of a string instrument in our dataset.

643
00:33:57,325 --> 00:33:59,650
So we have just identified,

644
00:33:59,650 --> 00:34:03,055
uh, all the string instruments in the embedding space.

645
00:34:03,055 --> 00:34:06,910
Now we wanna take the box of, um,

646
00:34:06,910 --> 00:34:10,675
all the string instruments and transform it to cover,

647
00:34:10,675 --> 00:34:13,270
uh, the- the people,

648
00:34:13,270 --> 00:34:15,114
uh, females and males, right?

649
00:34:15,114 --> 00:34:16,944
Who play these instruments.

650
00:34:16,945 --> 00:34:19,659
Uh, and if we do this, uh, here is the,

651
00:34:19,659 --> 00:34:22,494
uh, these are the entities that are inside the box.

652
00:34:22,495 --> 00:34:25,630
Again, because this is a two-dimensional projection, you know,

653
00:34:25,630 --> 00:34:27,310
this is not a box,

654
00:34:27,310 --> 00:34:29,350
uh, but in high-dimensions it is.

655
00:34:29,350 --> 00:34:33,085
And again, we see that we are able to cover, basically, um,

656
00:34:33,085 --> 00:34:36,429
98, uh, percent of all the- all the,

657
00:34:36,429 --> 00:34:38,259
uh, all the- all the, uh,

658
00:34:38,260 --> 00:34:40,840
instrumentalists of string instruments,

659
00:34:40,840 --> 00:34:42,699
and that, we have a few false positives,

660
00:34:42,699 --> 00:34:45,774
basically a few other entities, um,

661
00:34:45,775 --> 00:34:48,610
that are not instrumentalists of string instruments,

662
00:34:48,610 --> 00:34:50,050
but are still inside the box, right?

663
00:34:50,050 --> 00:34:51,400
So there is a bit of error,

664
00:34:51,400 --> 00:34:55,239
but the point is now we have 472 instrumentalists,

665
00:34:55,239 --> 00:34:57,820
both musicians, female and male,

666
00:34:57,820 --> 00:35:00,580
who play string instruments like a guitar, right?

667
00:35:00,580 --> 00:35:02,215
So now, uh, with this,

668
00:35:02,215 --> 00:35:05,455
let's move to the second part where we take the male,

669
00:35:05,455 --> 00:35:06,850
uh, the node male.

670
00:35:06,850 --> 00:35:08,950
Um, the male- the node, uh,

671
00:35:08,950 --> 00:35:11,815
is here, uh, and now we wanna say, uh,

672
00:35:11,815 --> 00:35:14,080
do the box transformation instance of to

673
00:35:14,080 --> 00:35:17,455
cover all the males in this, uh, knowledge graph.

674
00:35:17,455 --> 00:35:22,855
And if we do this, this is kind of the entities that are inside the male box,

675
00:35:22,855 --> 00:35:25,750
it's, uh, 3,500 of them.

676
00:35:25,750 --> 00:35:30,775
So we basically went from one entity to a giant box that covers,

677
00:35:30,775 --> 00:35:34,015
uh, 3,500, uh, males that are,

678
00:35:34,015 --> 00:35:36,385
uh, represented in this dataset.

679
00:35:36,385 --> 00:35:38,755
Now that we have these two boxes,

680
00:35:38,755 --> 00:35:41,605
we wanna apply the intersection,

681
00:35:41,605 --> 00:35:43,540
uh, operator, uh, to this,

682
00:35:43,540 --> 00:35:46,765
that you take the two boxes and take the intersection between them.

683
00:35:46,765 --> 00:35:50,185
Um, and if you do this, the intersection, um,

684
00:35:50,185 --> 00:35:53,530
has, uh, almost 400 different entities,

685
00:35:53,530 --> 00:35:58,225
and these are the entities that are predicted to be,

686
00:35:58,225 --> 00:36:01,900
uh, male players of string, uh, instruments.

687
00:36:01,900 --> 00:36:04,720
What is interesting, you see that basically,

688
00:36:04,720 --> 00:36:07,420
we are able to almost perfectly answer, uh,

689
00:36:07,420 --> 00:36:11,065
this query even though we were doing all these operations,

690
00:36:11,065 --> 00:36:13,820
uh, directly, uh, in the embedding space.

691
00:36:13,820 --> 00:36:17,730
And this is just one example how we can basically answer, uh,

692
00:36:17,730 --> 00:36:19,860
arbitrary predictive queries, uh,

693
00:36:19,860 --> 00:36:24,485
over these, uh, types of incomplete, uh, knowledge graphs.

694
00:36:24,485 --> 00:36:28,255
So, um, to summarize today's lecture;

695
00:36:28,255 --> 00:36:29,740
uh, we introduced, uh,

696
00:36:29,740 --> 00:36:32,005
um, the problem of a, uh,

697
00:36:32,005 --> 00:36:36,850
logical reasoning in knowledge graphs using embeddings, and in particular,

698
00:36:36,850 --> 00:36:40,210
we talked about how are we formulating

699
00:36:40,210 --> 00:36:44,875
answering queries as a predictive machine learning task.

700
00:36:44,875 --> 00:36:48,745
So we basically, rather than traversing the knowledge graph,

701
00:36:48,745 --> 00:36:54,175
we have defined the task in terms of a binary prediction task that says,

702
00:36:54,175 --> 00:36:58,550
"Predict what entities are the answer to a given query."

703
00:36:58,550 --> 00:37:02,220
And the benefit of our approach is that it is,

704
00:37:02,220 --> 00:37:04,500
uh, very scalable, meaning, uh,

705
00:37:04,500 --> 00:37:07,935
answering queries is very simple because it just requires, uh,

706
00:37:07,935 --> 00:37:12,830
transforming boxes and then checking what entities are inside the box.

707
00:37:12,830 --> 00:37:16,060
Um, and it is also very robust because we

708
00:37:16,060 --> 00:37:19,285
don't rely on individual links of the knowledge graph,

709
00:37:19,285 --> 00:37:24,640
but we really rely on the embeddings and the relationships in the embedding space.

710
00:37:24,640 --> 00:37:29,170
Um, and the key idea for today's lecture was we wanna

711
00:37:29,170 --> 00:37:33,520
embed queries by navigating the embedding space, right?

712
00:37:33,520 --> 00:37:36,220
We have this com- we've- we took advantage of

713
00:37:36,220 --> 00:37:40,900
this compositional property of uh, TransE method,

714
00:37:40,900 --> 00:37:44,290
and then we extended TransE to this notion of

715
00:37:44,290 --> 00:37:49,660
box embeddings so that we can then define the intersection of boxes.

716
00:37:49,660 --> 00:37:55,420
Um, and we learned how to transform boxes according to given relations,

717
00:37:55,420 --> 00:37:57,445
we call this a projection operator,

718
00:37:57,445 --> 00:38:00,595
um, and then we also showed how the,

719
00:38:00,595 --> 00:38:04,870
um, how the union operations can also be carried

720
00:38:04,870 --> 00:38:10,450
out- carried out by rewriting the query into the- a disjunctive normal form and,

721
00:38:10,450 --> 00:38:12,595
um, apply the union operator,

722
00:38:12,595 --> 00:38:15,680
uh, all the way, uh, at the end.

