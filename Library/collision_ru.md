1. # Введение
    1. Обзор содержания
        1. Глава 2: Проблемы проектирования обнаружения столкновений
        2. Глава 3: Учебник по математике и геометрии
        3. Глава 4: Ограничивающие объёмы
        4. Глава 5: Базовые примитивные тесты
        5. Глава 6: Иерархии ограничивающих объемов
        6. Глава 7: Пространственное разбиение
        7. Глава 8: Иерархии деревьев BSP
        8. Глава 9: Основанные на выпуклости методы
        9. Глава 10: Обнаружение столкновений с помощью GPU
        10. Глава 11: Числовая устойчивость
        11. Глава 12: Геометрическая устойчивость
        12. Глава 13: Оптимизация
    2. О коде
2. # Вопросы проектирования обнаружения столкновений
    1. Факторы проектирования алгоритма коллизий
    2. Представление области приложения
        1. Представления объектов
        2. Столкновение против геометрии рендеринга
        3. Специализация алгоритмов столкновений
    3. Типы запросов
    4. Параметры моделирования окружающей среды
        1. Количество объектов
        2. Последовательное или одновременное движение
        3. Дискретное и непрерывное движение
    5. Производительность
        1. Обзор оптимизации
    6. Надежность
    7. Простота реализации и использования
        1. Отладка системы обнаружения столкновений
    8. Резюме
3. # Учебник по математике и геометрии
    1. Матрицы
        1. Матричная арифметика
        2. Алгебраические тождества с матрицами
        3. Детерминанты
        4. Решение малых систем линейных уравнений с помощью правила Крамера 
        5. Обращение матриц для матриц 2 × 2 и 3 × 3
        6. Детерминантные предикаты
            1. ORIENT2D(A, B, C )
            2. ORIENT3D(A, B, C, D)
            3. INCIRCLE2D(A, B, C, D)
            4. INSPHERE(A, B, C, D, E )
    2. Системы координат и точки
    3. Векторы
        1. Векторная арифметика
        2. Алгебраические тождества с векторами
        3. Скалярное произведение
        4. Алгебраические тождества скалярных произведений
        5. Векторное произведение
        6. Алгебраические тождества векторых произведений
        7. Тройное скалярное произведение
        8. Алгебраические тождества тройных скалярных произведений
    4. Барицентрические координаты
    5. Линии, лучи и сегменты
    6. Плоскости и полупространства
    7. Многоугольники
        1. Проверка многоугольной выпуклости
    8. Многогранники
        1. Проверка многогранной выпуклости
    9. Вычисление выпуклой оболочки
        1. Алгоритм Эндрю
        2. Алгоритм Quickhull
    10. Регионы Вороного
    11. Сумма Минковского и разность
    12. Резюме
4. # Ограничивающие объёмы 
    1. Желательные характеристики BV
    2. Выровненные по оси ограничительные параллелипипеды (Axis-aligned Bounding Boxes, AABBs)
        1. AABB-AABB пересечение
        2. Вычисления и обновления AABBs
        3. AABB из ограничивающей объект сферы
        4. AABB реконструирован из исходного набора точек
        5. AABB из восхождения к вершине представления объекта
        6. AABB пересчитан из повернутого AABB
    3. Сферы
        1. Сфера-сфера пересечения
        2. Вычисление ограничивающей сферы
        3. Ограничивающая сфера из направления максимального распространения
        4. Ограничивающая сфера посредством итеративного уточнения
        5. Минимальная ограничивающая сфера
    4. Ориентированные ограничивающие параллелипипеды (Oriented Bounding Boxes, OBBs)
        1. OBB-OBB пересечение
        2. Повышение надежности теста разделительной оси
        3. Вычисление жесткого OBB
        4. Оптимизация OBB на основе PCA
        5. Установка OBB методом перебора
    5. Объемы, охваченные сферой
        1. Пересечение объемов, охваченных сферой
        2. Вычисление ограничивающих объемов, охватываемых сферой
    6. Объемы пересечения полупространства
        1. Kay–Kajiya объемы на основе плит (Slab)
        2. Дискретно-ориентированные многогранники (Discrete-orientation Polytopes, k-DOPs)
        3. Тест на перекрытие k-DOP – k-DOP
        4. Вычисление и настройка k-DOP
        5. Приблизительные тесты на пересечение выпуклой оболочки
    7. Другие ограничивающие объемы
    8. Резюме
5. # Базовые примитивные тесты
    1. Вычисления ближайших точек
        1. Ближайшая точка на плоскости к точке
        2. Ближайшая точка на отрезке линии к точке
            1. Расстояние от точки до сегмента
        3. Ближайшая точка на AABB к точке
            1. Расстояние от точки до AABB
        4. Ближайшая точка OBB к точке
            1. Расстояние от точки до OBB
            2. Ближайшая точка на 3D-прямоугольнике к точке
        5. Ближайшая точка на Треугольнике к Точке
        6. Ближайшая точка на Тетраэдре к Точке
        7. Ближайшая точка Выпуклого многогранника к Точке
        8. Ближайшие точки двух Линий
        9. Ближайшие точки двух линейных участков
            1. 2D Пересечение Сегментов
        10. Ближайшие точки Отрезка линии и Треугольника
        11. Ближайшие точки двух Треугольников
    2. Тестирование пересечения примитивов
        1. Тест разделяющей оси
            1. Устойчивость теста разделяющей оси
        2. Тестирование пересечения Сферы и Плоскости
        3. Тестирование пересечения Параллелипипеда и Плоскости
        4. Тестирование пересечения Конуса и Плоскости
        5. Тестирование пересечения Сферы и AABB
        6. Тестирование пересечения Сферы и OBB
        7. Тестирование пересечения Сферы и Треугольника
        8. Тестирование пересечения Сферы и Многоугольника
        9. Тестирование пересечения AABB и Треугольника
        10. Тестирование пересечения Треугольника и Треугольника
    3. Пересекающиеся линии, лучи и (направленные) сегменты
        1. Пересекающиеся Сегмент и Плоскость
        2. Пересекающиеся Луч или Сегмент и Сфера
        3. Пересекающиеся Луч или Сегмент и Параллелипипед
        4. Пересекающиеся Линия и Треугольник
        5. Пересекающиеся Линия и Четырехугольник
        6. Пересекающиеся Луч или Сегмент и Треугольник
        7. Пересекающиеся Луч или Сегмент и Цилиндр
        8. Пересекающиеся Луч или Сегмент и Выпуклый многогранник
    4. Дополнительные тесты
        1. Тестирование Точки в многоугольнике
        2. Тестирование Точки в Треугольнике
        3. Тестирование Точки в Многограннике
        4. Пересечение двух Плоскостей
        5. Пересечение трех Плоскостей
    5. Тест динамических пересечений
        1. Уменьшение вдвое интервала пересечения движущихся объектов
        2. Тест разделяющей оси для движущихся выпуклых объектов
        3. Пересечение движущейся Сферы относительно Плоскости
        4. Пересечение движущихся AABB относительно Плоскости
        5. Пересечение движущейся Сферы относительно Сферы
        6. Пересечение движущейся сферы относительно треугольника (и многоугольника)
        7. Пересечение движущейся сферы относительно AABB
        8. Пересечение движущегося AABB относительно AABB
    6. Резюме
6. # Иерархии ограничивающих объемов
    1. Вопросы проектирования иерархии
        1. Желаемые характеристики BVH
        2. Функции стоимости
        3. Степень дерева
    2. Стратегии построения иерархии конструкций
        1. Построение сверху вниз
            1. Стратегии разбиения
            2. Выбор оси разделения
            3. Выбор точки разделения
        2. Построение снизу вверх
            1. Улучшенная конструкция снизу вверх
            2. Другие стратегии строительства снизу вверх
            3. Снизу вверх n-арные деревья кластеризации
        3. Инкрементальная (вставная) конструкция
            1. Метод инкрементной конструкции Goldsmith–Salmon
    3. Обход иерархии
        1. Правила спуска
        2. Общий информированный обход в глубину
        3. Одновременный обход в глубину
        4. Оптимизированный переход по листу в глубину
    4. Пример иерархии ограничивающих объемов
        1. OBB Деревья
        2. Деревья AABB и BoxTrees
        3. Дерево Сферы через Octree Подразделение
        4. Дерево Сферы с покрытых сферой поверхностей
        5. Покрытие сферы генерации и сокращения
        6. k-dop Деревья
    5. Объединение ограничивающих объемов
        1. Слияние двух AABB
        2. Слияние двух сфер
        3. Слияние двух OBB
        4. Слияние двух k-DOP
    6. Эффективное представление дерева и обход
        1. Представление массива
        2. Порядок обхода предзаказа
        3. Смещения вместо указателей
        4. Структуры, удобные для кеширования (Недвоичные деревья)
        5. Узел дерева и порядок примитивов
        6. О рекурсии
        7. Группировка запросов
    7. Улучшенные запросы через кеширование
        1. Кэширование поверхности: кеширование пересекающихся примитивов
        2. Переднее отслеживание
    8. Резюме
7. # Пространственное разбиение
    1. Равномерная сетка
        1. Проблемы с размером ячейки
        2. Сетки как массивы связанных списков
        3. Хешированное хранилище и бесконечные сети
        4. Хранение статических данных
        5. Неявные сетки
        6. Объектно-объектный тест Равномерной сетки
            1. Один тест за раз
            2. Все тесты одновременно
        7. Дополнительные соображения по сетке
    2. Иерархические сетки
        1. Базовая реализация Hgrid
        2. Альтернативные иерархические сеточные представления
        3. Другие иерархические сетки
    3. Деревья
        1. Октодеревья (и Квадродеревья)
        2. Назначение объекта Октодерева
        3. Коды местоположения и поиск октанта для точки
        4. Линейные октодеревья (на основе хэша)
        5. Вычисление ключа Мортона
        6. Свободные октодеревья
        7. k-d Деревья
        8. Гибридные схемы
    4. Обход лучей и отрезков направленных линий
        1. k-d Тест на пересечение деревьев
        2. Тест на пересечение Равномерной сетки
    5. Методы сортировки и поиска
        1. Реализация отсортированного связного списка
        2. Сортировка по массивам
    6. Ячейки и порталы
    7. Избегание повторного тестирования
        1. Битовые флаги
        2. Штамп времени
        3. Амортизированная очистка штампов времени
    8. Резюме
8. # Иерархии деревьев BSP
    1. BSP Деревья
    2. Типы BSP-деревьев
        1. BSP-деревья с хранением узлов
        2. Деревья BSP с хранением Листов
        3. Деревья BSP с твердыми листьями
    3. Построение BSP-дерева
        1. Выбор разделяющих плоскостей
        2. Оценка разделяющих плоскостей
        3. Классификация полигонов по плоскости
        4. Разбиение полигонов на плоскости
        5. Подробнее об устойчивости к разбиению полигонов
        6. Настройка производительности дерева BSP
    4. Использование BSP Дерева
        1. Проверка точки на BSP-дереве с твердыми листьями
        2. Пересечение луча с твердолистным деревом BSP
        3. Многогранники на деревьях BSP с твердыми листьями
    5. Резюме
9. # Основанные на выпуклости методы
    1. Обнаружение столкновений на основе границ
    2. Алгоритмы с Ближайшими особенностями
        1. Алгоритм V-Clip
    3. Иерархические представления многогранников
        1. Иерархия Добкина–Киркпатрика
    4. Линейное и квадратичное программирование
        1. Линейное программирование
            1. Устранение Фурье–Моцкина
            2. Алгоритм Зейделя
        2. Квадратичное программирование
    5. Алгоритм Гилберта–Джонсона–Кирти
        1. Алгоритм Гилберта–Джонсона–Кирти
        2. Нахождение точки минимальной нормы в симплексе
        3. GJK, Ближайшие точки и контактные многообразия
        4. Восхождение на холм для экстремальных вершин
        5. Использование когерентности с помощью кэширования вершин
        6. Оптимизация вращающихся объектов
        7. GJK для движущихся объектов
    6. Алгоритм разделяющих векторов Чанга–Ванга
    7. Резюме
10. # Обнаружение столкновений с помощью GPU
    1. Взаимодействие с графическим процессором
        1. Считывание буфера
        2. Запросы окклюзии
    2. Тестирование выпуклых объектов
    3. Тестирование вогнутых объектов
    4. Фильтрация столкновений на основе графического процессора
    5. Резюме
11. # Числовая устойчивость
    1. Типы проблем устойчивости
    2. Представление действительных чисел
        1. Форматы с плавающей запятой IEEE-754
        2. Бесконечная арифметика
        3. Источники ошибок с плавающей точкой
    3. Надежное использование чисел с плавающей запятой
        1. Сравнение допусков для значений с плавающей запятой
        2. Надежность за счет толстых плоскостей
        3. Надежность за счет совместного использования расчетов
        4. Надежность толстых предметов
    4. Интервальная арифметика
        1. Примеры интервальной арифметики
        2. Интервальная арифметика при обнаружении столкновений
    5. Точные и полуточные вычисления
        1. Точная арифметика с использованием целых чисел
        2. Целочисленное деление
        3. Пересечение сегментов с использованием целочисленной арифметики
    6. Дальнейшие предложения по повышению надежности
    7. Резюме
12. # Геометрическая устойчивость
    1. Вершинная сварка
    2. Вычисление информации о смежности
        1. Вычисление таблицы Vertex-to-Face
        2. Вычисление таблицы Edge-to-Face
        3. Проверка связности
    3. Дыры, Трещины, Зазоры и Т-образные переходы 
    4. Объединение копланарных граней
        1. Проверка копланарности двух многоугольников
        2. Проверка плоскостности многоугольника
    5. Триангуляция и выпуклое разбиение
        1. Триангуляция путем разрезания ушей [1](https://ru.wikipedia.org/wiki/Задача_о_триангуляции_многоугольника#Отрезание_ушей)
            1. Триангуляция многоугольников с отверстиями
        2. Выпуклая декомпозиция многоугольников
        3. Выпуклое разложение многогранников
        4. Работа с «неразложимой» вогнутой геометрией
    6. Проверка непротиворечивости с использованием формулы Эйлера
    7. Резюме
13. # Оптимизация
    1. Кеши процессора
    2. Оптимизация кэша инструкций
    3. Оптимизация кэша данных
        1. Оптимизация структуры
        2. Квантованные и сжатые данные вершин
        3. Предварительная загрузка
    4. Структуры данных и алгоритмы с учетом кеширования
        1. Компактное статическое k-d дерево
        2. Компактное дерево AABB
        3. Кеширование забывчивости
    5. Программное кеширование
        1. Пример кэшированной линеаризации
        2. Амортизированное кэширование с предсказательной линеаризацией
    6. Сглаживание
        1. Анализ псевдонимов на основе типов
        2. Ограниченные указатели
        3. Избегание сглаживаний
    7. Параллелизм благодаря оптимизации SIMD
        1. SIMD-тест «Четыре сферы против четырех сфер»
        2. SIMD-тест «Четыре сферы против четырех AABB»
        3. SIMD-тест «Четыре AABB  против четырех AABB»
    8. Ветвление
    9. Резюме
14. Рекомендации
15. Индекс
16. О коде


# Введение

Это произведение посвящено теме обнаружения столкновений, широкой теме, связанной с, казалось бы, простой проблемой: обнаружение пересечения двух (или более) объектов. Обнаружение столкновений касается проблем определения того, **есть ли* соприкосновение, *когда* и *где* двух объектов. *“Есть ли”* включает установление логического результата, ответ на вопрос, пересекаются ли объекты. *“Когда”* дополнительно необходимо определить, в какое время во время движения произошло столкновение. *“Где”* устанавливает, как предметы входят в контакт. Грубо говоря, на эти три типа запросов становится все сложнее отвечать в указанном порядке. Сбор информации о том, когда и где (в дополнение к логическому результату обнаружения столкновения) иногда обозначается как *«обнаружение столкновения»*. Термины *«обнаружение пересечения»* и *«обнаружение помех»* иногда используются как синонимы «обнаружение столкновения».

Обнаружение столкновений является фундаментальным для многих разнообразных приложений, включая компьютерные игры, физическое моделирование (например, компьютерную анимацию), робототехнику, виртуальное прототипирование и инженерное моделирование (и это лишь некоторые из них). В компьютерных играх обнаружение столкновений гарантирует сохранение иллюзии твердого мира. Он не дает персонажам игроков проходить сквозь стены или проваливаться через пол; он обеспечивает запросы о прямой видимости, сообщая противникам, видят ли они игрока и, следовательно, могут ли они атаковать; и он удерживает скейтбордиста прикрепленным к невидимой направляющей поверхности, гарантируя, что игрок безопасно вернется в хафпайп после того, как поднялся в воздух.

В компьютерной анимации обнаружение столкновений используется, например, для ограничения физической симуляции ткани, чтобы одежда выглядела реалистично и не соскальзывала с персонажа при его движении. Обнаружение столкновений используется для планирования пути в робототехнике, помогая роботам избегать препятствий. В виртуальном прототипировании обнаружение столкновений помогает вычислить зазоры и в целом позволяет дорабатывать прототипы без создания физических моделей. Обнаружение столкновений используется в краш-тестах и другом инженерном моделировании.

Некоторые приложения, такие как планирование пути и рендеринг анимации, не требуют работы их систем столкновения в реальном времени. Другие приложения, в частности компьютерные игры, предъявляют особые требования к эффективности систем обнаружения столкновений в реальном времени. Экшн-игры для компьютеров и консолей включают моделирование, требующее выполнения большого количества запросов с частотой кадров от 30 до 60 кадров в секунду (fps). С такими жесткими временными ограничениями и с обнаружением столкновений, являющимся неотъемлемой частью игровых и физических движков, обнаружение столкновений может составлять большую часть времени, необходимого для создания игрового кадра. В компьютерных играх плохо спроектированная система столкновений может легко стать ключевым узким местом.

Это произведение не только об обнаружении коллизий в целом, но и конкретно об эффективной реализации структур данных и алгоритмов для решения проблем обнаружения коллизий в приложениях реального времени. В то время как область игр часто используется в качестве примеров, некоторые неигровые приложения имеют требования к производительности, аналогичные (или даже превышающие) требования к играм, включая системы тактильной (силовой обратной связи), симуляции частиц, хирургические симуляторы и другие симуляции виртуальной реальности. Описанные здесь методы одинаково хорошо применимы к этим приложениям.

Многие из обсуждаемых здесь методов применимы к областям, отличным от обнаружения столкновений. Например, методы, обсуждаемые в главах с 6 по 8, могут использоваться для ускорения трассировки лучей и их преобразования (например, для вычисления освещения сцены), а также в отношении географических информационных систем (ГИС) для ответа на запросы в больших географических базах данных. Некоторые проблемы из области компьютерной графики могут быть решены как проблемы обнаружения столкновений. Например, отсечение усеченного вида можно решить, используя методы, описанные в главах 6 и 7.

## 1.1 Обзор содержания

В следующих разделах дается краткое описание глав этой книги.

### 1.1.1 Глава 2: Проблемы проектирования обнаружения столкновений

В этой главе рассказывается о проблемах, которые необходимо учитывать при построении системы обнаружения столкновений, и о факторах, влияющих на проектирование. К таким факторам относятся то, как представлены объекты, их количество, как они перемещаются и какие типы запросов о столкновениях пользователь хочет задать. Глава 2 также знакомит с терминологией, которая используется в остальной части книги.

### 1.1.2 Глава 3: Учебник по математике и геометрии

Любая нетривиальная система обнаружения столкновений требует много математических расчетов, основанных на геометрии, чтобы определить, есть ли, когда и где для запросов столкновения. Глава 3 знакомит с математическими и геометрическими понятиями, необходимыми для понимания материала, изучаемого в остальных главах.

### 1.1.3 Глава 4: Граничные объемы

Чтобы ускорить выполнение запросов на столкновение, сначала используются простые геометрические объекты, такие как сферы и прямоугольники, для представления объектов более сложной природы. Только в случае столкновения «простых» ограничивающих объемов (которые достаточно велики для инкапсуляции сложных объектов) выполняются тесты на сложной геометрии. Глава 4 описывает несколько типов ограничивающих объемов, как выполнять для них тесты на пересечение и как подогнать ограничивающий объем к сложному объекту.

### 1.1.4 Глава 5: Базовые тесты примитивов

В предыдущей главе мы начали рассматривать тесты на пересечение. В главе 5 подробно описывается большое количество тестов для определения статуса пересечения и расстояния между парами объектов разного типа, включая линии, лучи, сегменты, плоскости, треугольники, многоугольники, сферы, параллелипипеды, цилиндры и многогранники. В этих тестах рассматриваются как статические, так и движущиеся объекты.

### 1.1.5 Глава 6: Иерархии ограничивающих объемов

Для больших объектов и для коллекций объектов повышение производительности может быть достигнуто за счет построения иерархий ограничивающих объемов над объектом (объектами). Такие иерархии обеспечивают быструю идентификацию объектов или частей объекта, которые не могут участвовать в столкновении, позволяя запросам ограничивать тестирование небольшим количеством объектов или частей объекта. В главе 6 рассказывается о желаемых характеристиках иерархий ограничивающих объёмов и способах построения и выполнения запросов к ним. В главе также исследуются эффективные способы представления этих иерархий.

### 1.1.6 Глава 7: Пространственное разбиение

Когда рассматривается большое количество объектов для столкновения, объекты должны быть разделены на небольшие непересекающиеся подгруппы для облегчения быстрых тестов (с целью избежать наихудшего квадратичного поведения тестирования всех объектов относительно всех других объектов). Иерархии ограничивающих объемов, обсуждаемые в главе 6, представляют собой один из способов выполнения такого разделения. Глава 7 исследует другие подходы к разделению, основанные на сетках, деревьях и сортировке объектов.

### 1.1.7 Глава 8: Иерархии деревьев BSP

Одной из наиболее универсальных древовидных структур для представления данных обнаружения столкновений является дерево разделения двоичного пространства (binary space partitioning, BSP). Деревья BSP можно использовать для разделения пространства независимо от объектов в пространстве. Их также можно использовать для отделения границы объекта от пространства, в котором он находится, тем самым эффективно формируя объемное представление объекта. Глава 8 рассказывает о надежном построении BSP-деревьев и о том, как выполнять тесты на полученных деревьях.

### 1.1.8 Глава 9: Основанные на выпуклости методы

Глава 9 рассматривает ряд более продвинутых методов выполнения запросов на столкновение с выпуклыми объектами, используя особые свойства выпуклых объектов. Представлены иерархические представления, алгоритм ближайших особенностей V-Clip, математические методы оптимизации линейного и квадратичного программирования, эффективный алгоритм Гилберта–Джонсона–Кирти и алгоритм разделяющих векторов Чанга и Ванга.

### 1.1.9 Глава 10: Обнаружение столкновений с помощью GPU

Обычные графические карты для ПК достигли такой степени, что обладают большей вычислительной мощностью, чем основной процессор ПК. Это изменение вызвало интерес к переложению вычислений на видеокарты. В главе 10 кратко рассказывается, как выполнять тесты обнаружения столкновений с использованием графического оборудования.

### 1.1.10 Глава 11: Числовая устойчивость

Даже самые маленькие ошибки в системе обнаружения столкновений могут привести к катастрофическим сбоям. Например: объекты не могут столкнуться со статическим пейзажем геометрии мира и, таким образом, выпадают из мира. В этой главе обсуждаются вопросы устойчивости, связанные с работой с арифметикой с плавающей запятой, и предлагаются подходы к решению этих проблем.

### 1.1.11 Глава 12: Геометрическая устойчивость

В то время как Глава 11 рассматривает, как надежно выполнять вычисления, Глава 12 рассматривает проблему взятия произвольного набора многоугольников и превращения его в хорошо сформированную геометрию, пригодную для ввода в систему обнаружения столкновений. Представлены методы сварки вершин, удаления зазоров и трещин, сращивания копланарных граней и разложения объектов на выпуклые (или треугольные) части.

### 1.1.12 Глава 13: Оптимизация

В последней главе книги рассказывается о том, как взять эффективные структуры данных и алгоритмы, представленные в книге, и сделать их еще более эффективными, нацелив и настроив их для конкретной аппаратной платформы. Значительный прирост производительности может быть достигнут за счет оптимизации кода для использования преимуществ иерархии памяти (кешей) и параллелизма кода и данных. В главе 13 представлено подробное описание того, как проводить такую оптимизацию.

## 1.2 О коде

В рамках практического характера этой книги многие из представленных идей дополняются примерами кода. В то время как многие книги полагаются исключительно на высокоуровневый псевдокод для передачи общих идей алгоритма, здесь большая часть кода дается на C++. Есть две причины для представления кода в этом виде. Во-первых, он предоставляет детали, которые часто жизненно важны для понимания (и реализации) алгоритма. Во-вторых, понимание теперь можно дополнительно получить, запустив код и изучив значения переменных во время выполнения. Последнее особенно важно для читателя, который не может полностью разбираться в математике, необходимой для реализации конкретного алгоритма. Лишь в нескольких местах книги данный код выражен псевдокодом, в основном там, где было бы непрактично предоставить полную реализацию.

Хотя C++ используется для кода в книге, следует подчеркнуть, что основное внимание в книге уделяется не C++. C++ используется только как средство для представления подробных исполняемых алгоритмов описанных концепций. Этой цели мог бы служить любой компьютерный язык, но C++ был выбран по нескольким причинам, включая его популярность и его способность кратко абстрагироваться от низкоуровневых манипуляций с геометрическими объектами, такими как точки и векторы, с использованием классов и (перегруженных) инфиксных операторов. Чтобы сделать представленный код доступным как можно большему количеству программистов (например, тех, кто знаком только с C или Java), по возможности намеренно избегали определенных функций C++, таких как шаблоны и STL (Стандартная библиотека шаблонов). Любители C++ могут захотеть сделать несколько глубоких вдохов в начале каждой главы!

Точно так же это не книга по разработке программного обеспечения. Чтобы основные идеи были представлены как можно лучше, код должен быть кратким и по существу. Были сделаны уступки, чтобы не загромождать текст подробным синтаксисом C++. Например, определения классов намеренно минималистичны (или отсутствуют), глобальные переменные иногда заменяют правильные переменные-члены, указатели не объявляются как константы (или ограничивают), а массивы часто объявляются фиксированного размера вместо того, чтобы динамически выделяться соответствующего размера. Имена переменных также были ограничены по длине, чтобы строки кода лучше вписывались на страницу набора.

Чтобы превратить представленный код в реальный производственный код, могут потребоваться некоторые дополнения. Например, тесты на деление на ноль не всегда выполняются, чтобы не вдаваться в детали, которые могут затруднить понимание общего подхода. Точно так же некоторые тесты кода могут потребовать добавления значений допуска для полной устойчивости. Цель состоит в том, чтобы обсудить надежность в главе 11, чтобы прояснить, какие изменения (если таковые имеются) необходимы для превращения представленного кода в надежный производственный код. Чтобы прояснить, какие аргументы функции являются входами, а какие - выходами, входные переменные часто передаются по значению, а выходные переменные - по ссылке. В некоторых случаях было бы более эффективно передавать входные переменные по ссылке. Это оставлено в качестве упражнения для читателя.

Комментарии набираются курсивом, а код - жирным шрифтом. Имена функций, классов, структур и определяемых пользователем типов начинаются с заглавной буквы, а переменные - с строчной буквы. Где возможно, имена переменных были выбраны в соответствии с обозначениями, используемыми в сопроводительном тексте. В некоторых случаях эти правила противоречат друг другу. Например, точки в тексте обозначаются заглавными буквами, а в коде - строчными.

Представленный в книге код реализован в большей степени в проекте Эрвина Куманса [«Bullet»](https://github.com/bulletphysics/bullet3).

# Глава 2
# Вопросы проектирования обнаружения столкновений

Проектирование эффективной системы обнаружения столкновений немного похоже на сборку головоломки: необходимо соединить множество частей, прежде чем появится общая картина. Подобным образом большая часть этой книги посвящена изучению отдельных частей, в которых используются различные подходы к обнаружению столкновений. Общая картина станет ясной по ходу книги. В этой главе дается краткий обзор ряда вопросов, которые необходимо учитывать при выборе подходов, и того, как соотносятся компоненты этих подходов. В этой главе также вводится ряд терминов, определения и пояснения которых будут даны в следующих главах. Более подробно затронутые здесь вопросы представлены в остальных главах книги.

## 2.1 Факторы проектирования алгоритма коллизий

Есть несколько факторов, влияющих на выбор, сделанный при разработке системы обнаружения столкновений. Эти факторы будут разбиты на следующие категории:

1. *Представление области приложения*. Геометрические представления, используемые для сцены и ее объектов, имеют прямое отношение к используемым алгоритмам. С меньшими ограничениями, накладываемыми на эти представления, необходимо использовать более общие решения по обнаружению столкновений с возможными последствиями для производительности.
2. *Различные типы запросов*. Как правило, чем более подробны типы запросов и результаты, тем больше вычислительных усилий требуется для их получения. Для поддержки определенных запросов могут потребоваться дополнительные структуры данных. Не все представления объектов поддерживают все типы запросов.
3. *Параметры моделирования окружающей среды*. Само моделирование содержит несколько параметров, оказывающих непосредственное влияние на систему обнаружения столкновений. Сюда входит количество объектов, их относительные размеры и положение, перемещаются ли они и как, разрешено ли им проникать друг в друга, и являются ли они жесткими или гибкими.
4. *Производительность*. Системы обнаружения столкновений в реальном времени работают с жесткими ограничениями по времени и размеру. Поскольку время и пространство всегда являются компромиссом, несколько функций обычно сбалансированы для удовлетворения заявленных требований к производительности.
5. *Надежность*. Не все приложения требуют одинакового уровня физического моделирования. Например, укладка кирпичей друг на друга требует гораздо большей сложности от системы обнаружения столкновений, чем наличие баскетбольного мяча, подпрыгивающего на баскетбольной площадке. Мяч, отскочивший слишком рано или под несколько большим углом, останется незамеченным, но даже малейшие ошибки в вычислении точек соприкосновения сложенных кирпичей могут привести к тому, что они медленно начнут проникать друг в друга или соскальзывать друг с друга.
6. *Простота реализации и использования*. Большинство проектов выполняются в установленные сроки. Планирование функций системы обнаружения столкновений ничего не значит, если система не может быть завершена и введена в эксплуатацию вовремя. Поэтому решения относительно простоты реализации играют большую роль в выборе подхода.

Эти вопросы более подробно рассматриваются в оставшейся части главы.

## 2.2 Представление области приложения

Чтобы выбрать подходящие алгоритмы обнаружения столкновений, важно учитывать типы геометрических представлений, которые будут использоваться для сцены и ее объектов. В этом разделе вкратце рассказывается о различных представлениях объектов, о том, как упрощенную геометрию можно использовать вместо геометрии моделирования, и как знание конкретных приложений может позволить использовать специализированные решения вместо более общих решений.

### 2.2.1 Представления объектов

В большинстве современных аппаратных средств в качестве основного примитива рендеринга используются треугольники. Следовательно, *многоугольное представление* является естественным выбором для сцен и объектов сцены, а также для их соответствующей геометрии столкновения. Самым общим полигональным представлением является *буфер из полигонов*: неупорядоченный набор полигонов без информации о связности, указывающей, как один полигон связан с другим. Без каких-либо ограничений, буфер из многоугольников является привлекательным представлением для художников и дизайнеров уровней. Алгоритмы, работающие с буферами полигонов, применимы к любому набору полигонов, но, как правило, менее эффективны и менее надежны, чем те, которые полагаются на дополнительную информацию. Например, многоугольный буфер не содержит информации о «внутренней части» объекта, поэтому нет простого способа узнать, оказался ли объект каким-то образом ошибочно внутри другого объекта. Упомянутая дополнительная информация может включать в себя, какие ребра соединяются с какими вершинами и какие грани соединяются с данной гранью, образует ли объект замкнутое твердое тело и является ли объект выпуклым или вогнутым.


**Рисунок 2.1** Геометрические модели, подобные изображенной на картинке, обычно строятся из набора полигональных сеток.

Многоугольники могут быть соединены друг с другом на своих краях, чтобы сформировать большую многоугольную поверхность, называемую *многоугольной сеткой*. Построение объектов из набора полигональных сеток - один из наиболее распространенных методов создания геометрических моделей (рис. 2.1).

Многоугольные объекты определяются в терминах их вершин, ребер и граней. Говорят, что при таком построении объекты имеют *явное* представление. *Неявные* объекты относятся к сферам, конусам, цилиндрам, эллипсоидам, торам и другим геометрическим примитивам, которые не определены явно таким образом, но неявно через математическое выражение. Неявные объекты часто описываются как отображение функций из трехмерного пространства в действительные числа, f:ℝ<sup>3</sup>→ℝ, где точки заданы f(x,y,z)<0
и принадлежат объекту, f(x,y,z)=0 граница, и f(x,y,z)>0 находятся вне объекта (рисунок 2.2). Граница объекта, определяемая неявной функцией, называется неявной поверхностью. Неявные объекты могут использоваться как грубые аппроксимации объектов сцены для быстрой отбраковки. Неявная форма может позволить проводить быстрые тесты на пересечение, особенно с линиями и лучами - факт, используемый в приложениях для трассировки лучей. Несколько примеров неявных тестов приведены в главе 5.

Convex polygonal objects can also be described as the intersection of a number
of halfspaces. For example, a cube can be expressed as the intersection of six half-
spaces, each halfspace“trimming away”the portion of space that lies outside a face of
the cube. Halfspaces and halfspace intersection volumes are described in more detail
in Chapter 3.

### 2.2.2 Столкновение против геометрии рендеринга
### 2.2.3 Специализация алгоритмов столкновений
## 2.3 Типы запросов
## 2.4 Параметры моделирования окружающей среды
### 2.4.1 Количество объектов
### 2.4.2 Последовательное или одновременное движение
### 2.4.3 Дискретное и непрерывное движение
## 2.5 Производительность
### 2.5.1 Обзор оптимизации
## 2.6 Надежность
## 2.7 Простота реализации и использования
### 2.7.1 Отладка системы обнаружения столкновений
## 2.8 Резюме