1
00:00:04,799 --> 00:00:06,399
приветствую всех, это четвертая часть

2
00:00:06,399 --> 00:00:08,000
нашей серии статей о методах и метриках, мы

3
00:00:08,000 --> 00:00:09,200
собираемся поговорить о том, как мы

4
00:00:09,200 --> 00:00:11,519
организуем наборы данных для целей

5
00:00:11,519 --> 00:00:14,320
проведения оценок в nlp,

6
00:00:14,320 --> 00:00:16,560
давайте начнем с классического

7
00:00:16,560 --> 00:00:19,359
разделения тестов для разработчиков поездов, это очень распространенный формат

8
00:00:19,359 --> 00:00:21,039
для  наборы данных в нашей области, особенно

9
00:00:21,039 --> 00:00:22,960
для очень

10
00:00:22,960 --> 00:00:25,039
больших общедоступных, и это действительно хорошо в том

11
00:00:25,039 --> 00:00:27,199
смысле, что, выпуская наборы данных с

12
00:00:27,199 --> 00:00:29,519
этими предварительно определенными разбиениями, мы обеспечиваем

13
00:00:29,519 --> 00:00:31,359
некоторую согласованность между различными

14
00:00:31,359 --> 00:00:33,680
оценками, которые проводят люди,

15
00:00:33,680 --> 00:00:35,360
это предполагает, что вы  иметь

16
00:00:35,360 --> 00:00:37,600
довольно большой набор данных, потому что, в конце концов,

17
00:00:37,600 --> 00:00:39,600
с самого начала вы

18
00:00:39,600 --> 00:00:41,760
откладываете в сторону множество примеров в разделах разработки

19
00:00:41,760 --> 00:00:43,760
и тестирования, которые вы вообще не можете использовать

20
00:00:43,760 --> 00:00:45,840
для обучения своих систем, поэтому даже если

21
00:00:45,840 --> 00:00:47,280
ваша система может извлечь выгоду из  эти

22
00:00:47,280 --> 00:00:49,120
примеры вы не можете использовать их в этом

23
00:00:49,120 --> 00:00:50,800
контексте их можно использовать только для

24
00:00:50,800 --> 00:00:52,800
оценки вы просто отказываетесь от

25
00:00:52,800 --> 00:00:56,399
множества потенциально полезных примеров

26
00:00:56,399 --> 00:00:58,399
как мы обсуждали много раз мы все

27
00:00:58,399 --> 00:00:59,840
на  Система чести, когда дело доходит до

28
00:00:59,840 --> 00:01:01,760
этого набора тестов, он распространяется как часть

29
00:01:01,760 --> 00:01:03,600
набора данных, но у него есть привилегированный

30
00:01:03,600 --> 00:01:04,640
статус,

31
00:01:04,640 --> 00:01:06,960
набор тестов можно использовать только после того, как

32
00:01:06,960 --> 00:01:10,000
вся разработка системы завершена,

33
00:01:10,000 --> 00:01:12,000
а затем вы выполняете единственную оценку

34
00:01:12,000 --> 00:01:13,600
набора тестов и  сообщить, что число

35
00:01:13,600 --> 00:01:15,200
полностью исключено,

36
00:01:15,200 --> 00:01:17,119
это жизненно важно для нашей области, потому что

37
00:01:17,119 --> 00:01:18,799
это единственный способ, с помощью которого мы можем даже надеяться

38
00:01:18,799 --> 00:01:21,360
получить истинную картину того, как наши

39
00:01:21,360 --> 00:01:25,200
системы действительно обобщают новые примеры,

40
00:01:25,200 --> 00:01:26,799
которые говорят

41
00:01:26,799 --> 00:01:29,280
об обратной стороне предварительно определенных разделений

42
00:01:29,280 --> 00:01:31,520
тестов для разработки поездов.  заключается в том, что

43
00:01:31,520 --> 00:01:33,920
все неизбежно используют одни и те же

44
00:01:33,920 --> 00:01:35,119
наборы для разработки и тестирования,

45
00:01:35,119 --> 00:01:37,439
и это означает, что со временем, когда

46
00:01:37,439 --> 00:01:39,439
мы видим последовательный прогресс в

47
00:01:39,439 --> 00:01:41,200
задаче эталонного тестирования,

48
00:01:41,200 --> 00:01:42,880
мы проводим одно и то же измерение на

49
00:01:42,880 --> 00:01:44,960
одном и том же наборе тестов, и может быть трудно

50
00:01:44,960 --> 00:01:46,399
быть уверенным, что  мы видим реальный

51
00:01:46,399 --> 00:01:48,960
прогресс в выполнении основной задачи

52
00:01:48,960 --> 00:01:51,200
или результат множества неявных

53
00:01:51,200 --> 00:01:52,960
уроков, которые люди усвоили о

54
00:01:52,960 --> 00:01:55,200
том, что работает, а что нет для этого

55
00:01:55,200 --> 00:01:57,360
конкретного набора тестов, и это верно, даже

56
00:01:57,360 --> 00:01:59,920
если все  подчиняется этому кодексу чести

57
00:01:59,920 --> 00:02:01,759
и делает это, используя тестовый набор только для

58
00:02:01,759 --> 00:02:04,479
действительно окончательных оценок, тем не менее,

59
00:02:04,479 --> 00:02:06,640
информация может просочиться, и мы можем

60
00:02:06,640 --> 00:02:09,440
начать ошибаться с истинным прогрессом, когда

61
00:02:09,440 --> 00:02:11,120
мы на самом деле просто видим прогресс на

62
00:02:11,120 --> 00:02:13,200
этом конкретном тестовом наборе, и я думаю, что это

63
00:02:13,200 --> 00:02:15,200
единственный способ  что мы действительно можем бороться с этим

64
00:02:15,200 --> 00:02:17,280
, постоянно устанавливая

65
00:02:17,280 --> 00:02:19,760
для себя новые тестовые задачи с новыми наборами тестов,

66
00:02:19,760 --> 00:02:22,080
чтобы мы видели, как системы работают

67
00:02:22,080 --> 00:02:25,760
в действительно невидимых средах,

68
00:02:25,840 --> 00:02:28,319
когда вы покидаете nlp. Обычно можно найти

69
00:02:28,319 --> 00:02:30,080
наборы данных, которые не идут с этим

70
00:02:30,080 --> 00:02:32,879
заранее определенным поездом  dev test split, и это

71
00:02:32,879 --> 00:02:34,879
ставит перед вами некоторые методологические вопросы.

72
00:02:34,879 --> 00:02:36,879
Это особенно верно для небольших

73
00:02:36,879 --> 00:02:39,680
общедоступных наборов данных, которые вы видите там.

74
00:02:39,680 --> 00:02:41,599


75
00:02:41,599 --> 00:02:43,760


76
00:02:43,760 --> 00:02:45,519


77
00:02:45,519 --> 00:02:47,599


78
00:02:47,599 --> 00:02:49,440
одинаковые разбиения,

79
00:02:49,440 --> 00:02:51,120
и это особенно важно, если

80
00:02:51,120 --> 00:02:53,200
набор данных небольшой, потому что, конечно, в

81
00:02:53,200 --> 00:02:54,800
небольшом наборе данных вы, вероятно,

82
00:02:54,800 --> 00:02:57,519
получите больше дисперсии.  пересекать разные прогоны,

83
00:02:57,519 --> 00:02:58,959
и это может очень затруднить

84
00:02:58,959 --> 00:03:01,280
сравнение вне экспериментальной работы

85
00:03:01,280 --> 00:03:02,400
, которую вы делаете, если кто-то

86
00:03:02,400 --> 00:03:05,599
опубликовал результаты какого-то случайного

87
00:03:05,599 --> 00:03:08,480
разделения теста 70 30 поездов,

88
00:03:08,480 --> 00:03:10,720
если вы не можете точно восстановить

89
00:03:10,720 --> 00:03:12,400
разделения, которые они использовали, это может быть

90
00:03:12,400 --> 00:03:13,920
неясно  проводите ли вы настоящее

91
00:03:13,920 --> 00:03:16,000
сравнение яблок с яблоками, так что об этом

92
00:03:16,000 --> 00:03:17,920
следует помнить, и это

93
00:03:17,920 --> 00:03:19,599
означает, что если вы можете для своих собственных

94
00:03:19,599 --> 00:03:22,480
экспериментов, вы можете ввести разделение

95
00:03:22,480 --> 00:03:24,319
прямо в начале вашего проекта, это

96
00:03:24,319 --> 00:03:26,159
, вероятно, возможно, если набор данных

97
00:03:26,159 --> 00:03:28,560
велика, и это будет означать, что у

98
00:03:28,560 --> 00:03:31,040
вас упрощенная экспериментальная установка,

99
00:03:31,040 --> 00:03:32,400
и вам нужно делать

100
00:03:32,400 --> 00:03:34,640
меньше оптимизации гиперпараметров только

101
00:03:34,640 --> 00:03:36,879
потому, что в вашей базовой экспериментальной установке меньше движущихся частей,

102
00:03:36,879 --> 00:03:39,440


103
00:03:39,440 --> 00:03:40,879
это предполагает, что у вас есть

104
00:03:40,879 --> 00:03:42,640
довольно большой набор данных, потому что, как я  сказал,

105
00:03:42,640 --> 00:03:44,400
прежде чем вам придется отказаться от целой

106
00:03:44,400 --> 00:03:46,560
кучи примеров для разработки и тестирования,

107
00:03:46,560 --> 00:03:48,560
но это упростит другие аспекты

108
00:03:48,560 --> 00:03:51,200
вашего проекта, если это возможно

109
00:03:51,200 --> 00:03:53,200
для небольших наборов данных, которые вы  gh введение

110
00:03:53,200 --> 00:03:55,439
разделения может оставить слишком мало данных, что

111
00:03:55,439 --> 00:03:57,280
приведет к сильно различающейся производительности,

112
00:03:57,280 --> 00:03:58,959
и в этом контексте, если

113
00:03:58,959 --> 00:04:00,640
вы наблюдаете такое поведение,

114
00:04:00,640 --> 00:04:02,319
вы можете захотеть перейти в режим

115
00:04:02,319 --> 00:04:04,400
перекрестной проверки,

116
00:04:04,400 --> 00:04:06,480
поэтому перекрестная проверка в этом контексте мы

117
00:04:06,480 --> 00:04:08,400
берем набор  примеров говорят, что весь наш

118
00:04:08,400 --> 00:04:11,200
набор данных, и мы разделяем их на два

119
00:04:11,200 --> 00:04:13,439
или более разделения тестов поезда,

120
00:04:13,439 --> 00:04:15,120
когда вы могли бы делать это неоднократно, а

121
00:04:15,120 --> 00:04:17,040
затем

122
00:04:17,040 --> 00:04:19,358
каким-то образом усредняли результаты оценок этих разделений,

123
00:04:19,358 --> 00:04:21,519
чтобы дать целостную сводку производительности системы,

124
00:04:21,519 --> 00:04:23,680
и таким образом  даже если

125
00:04:23,680 --> 00:04:25,600
эти числа различаются, они могут иметь

126
00:04:25,600 --> 00:04:27,520
большую дисперсию, которую мы все еще получаем в

127
00:04:27,520 --> 00:04:29,520
среднем, мы надеемся, что это довольно надежная

128
00:04:29,520 --> 00:04:31,759
мера того, как система работает в

129
00:04:31,759 --> 00:04:34,000
целом на доступных данных, и я

130
00:04:34,000 --> 00:04:35,680
собираюсь поговорить о двух способах сделать кросс

131
00:04:35,680 --> 00:04:37,919
проверка, каждая со своими сильными

132
00:04:37,919 --> 00:04:39,919
и слабыми сторонами, давайте начнем с того, что

133
00:04:39,919 --> 00:04:41,919
я назвал здесь случайными разбиениями, поэтому в

134
00:04:41,919 --> 00:04:43,759
режиме случайных разбиений вы берете свой

135
00:04:43,759 --> 00:04:44,960
набор данных

136
00:04:44,960 --> 00:04:46,960
и, скажем, k

137
00:04:46,960 --> 00:04:48,320
раз перетасовываете его.

138
00:04:48,320 --> 00:04:50,479
и вы разделяете его, и у вас есть t процентов

139
00:04:50,479 --> 00:04:52,240
на поезд, а затем, вероятно, остальные

140
00:04:52,240 --> 00:04:53,680
оставляются для тестирования,

141
00:04:53,680 --> 00:04:55,199
и по каждому из этих разделений вы

142
00:04:55,199 --> 00:04:57,600
проводите какую-то оценку,

143
00:04:57,600 --> 00:04:59,759
возвращаете свои показатели, а затем в

144
00:04:59,759 --> 00:05:02,000
конце всех этих k оценок вы,

145
00:05:02,000 --> 00:05:03,759
вероятно, усредняете  эти метрики каким-то

146
00:05:03,759 --> 00:05:06,000
образом дают единое итоговое

147
00:05:06,000 --> 00:05:09,039
число для производительности системы

148
00:05:09,039 --> 00:05:10,880
в целом, но не всегда, когда мы делаем

149
00:05:10,880 --> 00:05:12,560
эти разделения, мы хотим, чтобы они были

150
00:05:12,560 --> 00:05:15,039
стратифицированы в том смысле, что

151
00:05:15,039 --> 00:05:16,400
разделение обучения и тестирования должно иметь

152
00:05:16,400 --> 00:05:18,720
примерно одинаковое распределение

153
00:05:18,720 --> 00:05:21,919
по классам.  э-э, в базовых данных,

154
00:05:21,919 --> 00:05:23,600
но я был осторожен, чтобы сказать, что

155
00:05:23,600 --> 00:05:25,280
это не всегда верно,

156
00:05:25,280 --> 00:05:26,960
например, может быть контекст, в котором вы хотели бы,

157
00:05:26,960 --> 00:05:29,120
чтобы ваш тестовый набор нагрузил вашу

158
00:05:29,120 --> 00:05:30,720
систему, имея очень другое

159
00:05:30,720 --> 00:05:33,280
распределение, может быть, даже распределение

160
00:05:33,280 --> 00:05:34,960
или  тот, который сильно перекошен в сторону

161
00:05:34,960 --> 00:05:36,639
некоторых из меньших, но более важных

162
00:05:36,639 --> 00:05:37,840
классов,

163
00:05:37,840 --> 00:05:40,479
и это создаст проблему для

164
00:05:40,479 --> 00:05:43,039
режимов тестирования поездов, потому что

165
00:05:43,039 --> 00:05:44,800
опыт системы во время обучения будет

166
00:05:44,800 --> 00:05:46,400
отличаться в этом

167
00:05:46,400 --> 00:05:48,160
смысле распределения высокого уровня от того, что он видит

168
00:05:48,160 --> 00:05:50,639
во время тестирования, но это, конечно, может быть

169
00:05:50,639 --> 00:05:52,560
частью того, что вы пытаетесь реализовать в

170
00:05:52,560 --> 00:05:56,320
рамках своей общей гипотезы.

171
00:05:56,560 --> 00:05:58,000
Компромиссы для такого рода

172
00:05:58,000 --> 00:05:59,759
перекрестной проверки хороши  что вы

173
00:05:59,759 --> 00:06:02,080
можете создавать столько разбиений, сколько хотите,

174
00:06:02,080 --> 00:06:04,000
не оказывая влияния на соотношение

175
00:06:04,000 --> 00:06:05,680
обучения и тестирования примеров,

176
00:06:05,680 --> 00:06:06,400
потому что

177
00:06:06,400 --> 00:06:08,240
k раз мы просто собираемся сделать случайное

178
00:06:08,240 --> 00:06:10,560
разбиение, и может быть последовательно, что мы

179
00:06:10,560 --> 00:06:12,720
делаем независимо от k

180
00:06:12,720 --> 00:06:16,560
70 train 30 test  или 50 50 или что бы мы ни

181
00:06:16,560 --> 00:06:19,039
решили, что мы хотим, это не зависит

182
00:06:19,039 --> 00:06:21,280
от количества разбиений, которые мы установили.

183
00:06:21,280 --> 00:06:22,720
Плохое из этого, конечно, в том,

184
00:06:22,720 --> 00:06:25,360
что нет гарантии, что каждый пример

185
00:06:25,360 --> 00:06:27,280
будет использоваться одинаковое количество раз

186
00:06:27,280 --> 00:06:29,600
для обучения и для тестирования и для

187
00:06:29,600 --> 00:06:31,840
небольших  наборы данных, это, конечно, может

188
00:06:31,840 --> 00:06:33,440
быть проблемой, потому что вы можете

189
00:06:33,440 --> 00:06:36,400
вводить нежелательные корреляции

190
00:06:36,400 --> 00:06:39,520
между разбиениями, например, никогда не

191
00:06:39,520 --> 00:06:41,360
иметь определенных сложных примеров частью

192
00:06:41,360 --> 00:06:43,680
вашего тестового набора просто случайно,

193
00:06:43,680 --> 00:06:45,680
так что  следует иметь в виду, но,

194
00:06:45,680 --> 00:06:47,600
конечно, для очень больших наборов данных

195
00:06:47,600 --> 00:06:49,520
очень маловероятно, что вы будете восприимчивы

196
00:06:49,520 --> 00:06:51,520
к плохой части этого, и тогда вы

197
00:06:51,520 --> 00:06:53,680
получите много преимуществ свободы

198
00:06:53,680 --> 00:06:55,919
от возможности запуска большого количества  эксперименты

199
00:06:55,919 --> 00:06:59,280
с фиксированным соотношением тестов поездов,

200
00:06:59,280 --> 00:07:02,240
и, конечно, как обычно, у scikit есть

201
00:07:02,240 --> 00:07:04,080
много инструментов, которые помогут вам в этом, поэтому я

202
00:07:04,080 --> 00:07:06,000
только что привел несколько классических

203
00:07:06,000 --> 00:07:08,240
примеров из пакета выбора модели, который

204
00:07:08,240 --> 00:07:10,240
вы можете импортировать.

205
00:07:10,240 --> 00:07:12,560


206
00:07:12,560 --> 00:07:14,800
train test split — полезная утилита для

207
00:07:14,800 --> 00:07:16,800
очень быстрого и гибкого создания

208
00:07:16,800 --> 00:07:18,960
разбиений ваших данных, и я активно

209
00:07:18,960 --> 00:07:22,479
использую их в своем собственном коде.

210
00:07:22,479 --> 00:07:24,240
Второй режим перекрестной проверки,

211
00:07:24,240 --> 00:07:26,319
который я хотел бы обсудить, — это

212
00:07:26,319 --> 00:07:27,919
перекрестная проверка k-fold здесь  метод

213
00:07:27,919 --> 00:07:29,840
немного отличается, мы возьмем

214
00:07:29,840 --> 00:07:31,840
наш набор данных и разделим его на три части.

215
00:07:31,840 --> 00:07:33,759
В этом случае для трехкратной

216
00:07:33,759 --> 00:07:35,599
перекрестной проверки вы, конечно, можете

217
00:07:35,599 --> 00:07:37,919
выбрать любое число кратности, которое хотите,

218
00:07:37,919 --> 00:07:39,360
а затем, учитывая это трехкратное

219
00:07:39,360 --> 00:07:40,800
перекрестное  ва  Мы собираемся провести

220
00:07:40,800 --> 00:07:43,120
три эксперимента один, где кратность один

221
00:07:43,120 --> 00:07:44,400
используется для тестирования,

222
00:07:44,400 --> 00:07:46,240
а два и три объединяются вместе

223
00:07:46,240 --> 00:07:47,599
для обучения,

224
00:07:47,599 --> 00:07:49,520
второй эксперимент, в котором мы удерживаем

225
00:07:49,520 --> 00:07:52,000
кратность два для тестирования, а объединение

226
00:07:52,000 --> 00:07:54,080
единиц и трех используется для обучения, а

227
00:07:54,080 --> 00:07:55,919
затем  наконец, третий эксперимент, в котором

228
00:07:55,919 --> 00:07:58,240
для тестирования используется третья складка, а

229
00:07:58,240 --> 00:08:01,120
первая и вторая складки объединяются для

230
00:08:01,120 --> 00:08:03,280
набора поездов.

231
00:08:03,280 --> 00:08:04,639
Компромиссы здесь немного

232
00:08:04,639 --> 00:08:06,400
отличаются от компромиссов для случайных

233
00:08:06,400 --> 00:08:09,120
разделений, поэтому преимущество этого заключается в том, что каждый

234
00:08:09,120 --> 00:08:10,319
пример

235
00:08:10,319 --> 00:08:12,879
появляется в  набор поездов ровно k минус

236
00:08:12,879 --> 00:08:15,360
один раз, и в тестовом наборе ровно один раз

237
00:08:15,360 --> 00:08:17,759
мы гарантируем это в силу того

238
00:08:17,759 --> 00:08:19,520
факта, что здесь мы используем одно

239
00:08:19,520 --> 00:08:22,000
разделение для проведения наших трех экспериментальных

240
00:08:22,000 --> 00:08:23,599
парадигм,

241
00:08:23,599 --> 00:08:25,759
что плохо, конечно, может быть очень

242
00:08:25,759 --> 00:08:28,800
сложно размер  k

243
00:08:28,800 --> 00:08:30,960
определяет размер разделения обученного теста,

244
00:08:30,960 --> 00:08:32,559
просто учтите, что для трехкратной

245
00:08:32,559 --> 00:08:34,958
перекрестной проверки мы собираемся использовать

246
00:08:34,958 --> 00:08:36,559
67 данных для обучения

247
00:08:36,559 --> 00:08:38,479
и 33 для тестирования,

248
00:08:38,479 --> 00:08:40,320
но если три эксперимента  s недостаточно,

249
00:08:40,320 --> 00:08:42,958
если мы хотим 10 раз, результатом этого

250
00:08:42,958 --> 00:08:45,200
будет то, что мы используем 90 наших данных для

251
00:08:45,200 --> 00:08:48,080
торговли и 10 для тестирования, и

252
00:08:48,080 --> 00:08:49,760
суть в том, что это очень

253
00:08:49,760 --> 00:08:51,519
разные экспериментальные сценарии

254
00:08:51,519 --> 00:08:53,040
с точки зрения объема

255
00:08:53,040 --> 00:08:55,120
обучения.  данные, которые есть в вашей системе,

256
00:08:55,120 --> 00:08:57,680
и, возможно, дисперсия, которую вы видите

257
00:08:57,680 --> 00:08:59,200
при тестировании из-за того, как вы

258
00:08:59,200 --> 00:09:01,680
меняете размер тестового набора,

259
00:09:01,680 --> 00:09:03,600
тогда как для случайных разбиений, которые мы

260
00:09:03,600 --> 00:09:05,360
только что обсуждали, у нас есть независимость

261
00:09:05,360 --> 00:09:07,600
от количества сгибов, а затем

262
00:09:07,600 --> 00:09:09,760
процент  примеров обучающих тестов, которые

263
00:09:09,760 --> 00:09:11,519
у нас будут, и которые могут быть очень

264
00:09:11,519 --> 00:09:13,680
свободны, особенно для больших наборов данных,

265
00:09:13,680 --> 00:09:16,720
где ценность здесь, в хорошем,

266
00:09:16,720 --> 00:09:19,120
действительно менее актуальна,

267
00:09:19,120 --> 00:09:21,360
и снова у scikit-learn есть много инструментов

268
00:09:21,360 --> 00:09:23,200
для этого, я на самом деле просто  учитывая

269
00:09:23,200 --> 00:09:25,440
образец из них здесь, у вас есть k-кратная

270
00:09:25,440 --> 00:09:28,000
стратификация k-fold, а затем перекрестная

271
00:09:28,000 --> 00:09:30,240
оценка - это хорошая утилита raptor, которая

272
00:09:30,240 --> 00:09:32,320
снова даст вам гибкий доступ к

273
00:09:32,320 --> 00:09:35,200
множеству различных способов концептуализации

274
00:09:35,200 --> 00:09:38,440
перекрестной проверки.

