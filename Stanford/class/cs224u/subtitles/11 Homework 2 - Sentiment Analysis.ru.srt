1
00:00:04,640 --> 00:00:06,799
привет всем, это видео представляет собой обзор

2
00:00:06,799 --> 00:00:09,040
домашнего задания 2, которое касается контролируемого

3
00:00:09,040 --> 00:00:10,639
анализа тональности, и я бы на самом деле

4
00:00:10,639 --> 00:00:12,880
думал об этом как об эксперименте в

5
00:00:12,880 --> 00:00:14,719
междоменном анализе тональности, давайте просто

6
00:00:14,719 --> 00:00:16,000
пройдемся по этому блокноту, и я постараюсь

7
00:00:16,000 --> 00:00:18,080
дать вам представление о проблеме.  и

8
00:00:18,080 --> 00:00:19,840
наше мышление, стоящее за этим,

9
00:00:19,840 --> 00:00:22,640
так что сюжет обычный,

10
00:00:22,640 --> 00:00:24,240
мы собираемся представить задачу и

11
00:00:24,240 --> 00:00:26,080
связанные данные

12
00:00:26,080 --> 00:00:27,199
и помочь вам с настройкой некоторых

13
00:00:27,199 --> 00:00:29,599
базовых показателей и анализом ошибок, и

14
00:00:29,599 --> 00:00:31,279
это все ведет к этим домашним

15
00:00:31,279 --> 00:00:33,120
заданиям, которые предназначены, чтобы помочь вам

16
00:00:33,120 --> 00:00:35,440
исследовать данные осмысленным образом, а

17
00:00:35,440 --> 00:00:37,360
также установить некоторые дополнительные базовые уровни,

18
00:00:37,360 --> 00:00:38,960
которые могут в

19
00:00:38,960 --> 00:00:40,960
конечном итоге информировать вашу исходную систему, которую

20
00:00:40,960 --> 00:00:44,079
вы затем вводите в банк из

21
00:00:44,079 --> 00:00:46,160
быстрого обзора, мы проводим тройной анализ, который

22
00:00:46,160 --> 00:00:47,840
является положительным, отрицательным, нейтральным анализом настроений, с которым

23
00:00:47,840 --> 00:00:49,280
мы будем иметь дело.

24
00:00:49,280 --> 00:00:51,440
два набора данных из Стэнфордского

25
00:00:51,440 --> 00:00:54,079
банка деревьев настроений и совершенно новый

26
00:00:54,079 --> 00:00:56,399
набор данных для оценки, который представляет собой разделение

27
00:00:56,399 --> 00:00:59,039
предложений, полученных в результате тестирования разработчиков из отзывов о ресторанах, которые

28
00:00:59,039 --> 00:01:01,199
мы даем  вас за обучение набору

29
00:01:01,199 --> 00:01:03,840
поездов sst и просьбу вас

30
00:01:03,840 --> 00:01:06,640
оценить sst dev и test, а также за этот новый раздел dev test с

31
00:01:06,640 --> 00:01:08,479
обзорами ресторанов,

32
00:01:08,479 --> 00:01:10,159
и это междоменный аспект

33
00:01:10,159 --> 00:01:10,960
этого,

34
00:01:10,960 --> 00:01:12,640
вы совершенно не ограничены в том,

35
00:01:12,640 --> 00:01:14,479
что вы делаете с точки зрения привлечения  в новых

36
00:01:14,479 --> 00:01:16,560
данных для обучения и выполнения

37
00:01:16,560 --> 00:01:18,799


38
00:01:18,799 --> 00:01:20,799


39
00:01:20,799 --> 00:01:23,920
действий в процессе разработки одно ограничение, которое нам действительно нужно жестко наложить здесь, заключается в том, что, конечно, тестовый набор sst3 является

40
00:01:23,920 --> 00:01:26,080
общедоступным тестовым набором, который фактически включен

41
00:01:26,080 --> 00:01:27,920
в ваше распределение данных, чтобы другие

42
00:01:27,920 --> 00:01:30,400
ноутбуки могли запускать некоторые базовые системы.

43
00:01:30,400 --> 00:01:32,640
и сравните с литературой, но

44
00:01:32,640 --> 00:01:34,799
этот тестовый набор полностью запрещен

45
00:01:34,799 --> 00:01:36,159
во время

46
00:01:36,159 --> 00:01:37,920
разработки, очень важно, чтобы вы выполняли всю

47
00:01:37,920 --> 00:01:40,159
свою разработку только на разделениях разработчиков

48
00:01:40,159 --> 00:01:42,079
и полностью игнорировали тот факт, что у вас

49
00:01:42,079 --> 00:01:44,880
есть помеченная версия тестового набора ss3 t3

50
00:01:44,880 --> 00:01:46,000


51
00:01:46,000 --> 00:01:47,600
и, как я уже сказал  здесь

52
00:01:47,600 --> 00:01:49,600
большая часть научной целостности нашей

53
00:01:49,600 --> 00:01:51,920
области зависит от людей, придерживающихся этого

54
00:01:51,920 --> 00:01:54,399
кодекса чести, который не занимается разработками

55
00:01:54,399 --> 00:01:56,799
на основе тестовых данных, потому что тесты  Данные

56
00:01:56,799 --> 00:01:58,799
— это наш единственный шанс получить действительно

57
00:01:58,799 --> 00:02:00,719
четкое представление о том, как наши системы

58
00:02:00,719 --> 00:02:02,719
обобщают новые примеры и новый

59
00:02:02,719 --> 00:02:06,560
опыт, поэтому, пожалуйста, имейте в виду,

60
00:02:06,560 --> 00:02:08,479
что смысл этого задания,

61
00:02:08,479 --> 00:02:11,280
конечно же, состоит в том, чтобы помочь вам ознакомиться или

62
00:02:11,280 --> 00:02:12,959
повторно ознакомиться с  основных

63
00:02:12,959 --> 00:02:14,480
концепций и контролировать

64
00:02:14,480 --> 00:02:17,040
анализ настроений и связанный с ним жизненный

65
00:02:17,040 --> 00:02:18,800
цикл разработки систем в этой области,

66
00:02:18,800 --> 00:02:21,280
который включает в себя написание функциональных функций,

67
00:02:21,280 --> 00:02:24,239
опробование архитектуры модели,

68
00:02:24,239 --> 00:02:26,319
настройку гиперпараметров, а также, возможно, выполнение

69
00:02:26,319 --> 00:02:28,000
некоторых сравнений моделей с использованием

70
00:02:28,000 --> 00:02:30,160
статистических тестов, чтобы попытаться понять,

71
00:02:30,160 --> 00:02:31,760
насколько значимы  прогресс, которого

72
00:02:31,760 --> 00:02:34,000
вы добиваетесь, повторяя дизайн своей системы,

73
00:02:34,000 --> 00:02:35,360


74
00:02:35,360 --> 00:02:36,879
и мы также пытаемся подчеркнуть здесь в

75
00:02:36,879 --> 00:02:39,280
этой записной книжке, что анализ ошибок может

76
00:02:39,280 --> 00:02:42,640
быть мощным способом помочь вам найти проблемы

77
00:02:42,640 --> 00:02:45,680
в вашей системе, а затем решить их

78
00:02:45,680 --> 00:02:47,360
еще одним методологическим примечанием, когда вы

79
00:02:47,360 --> 00:02:48,879
посмотрим из этого блокнота, я призываю

80
00:02:48,879 --> 00:02:51,440
вас использовать функциональные возможности этого модуля sst dot

81
00:02:51,440 --> 00:02:53,599
pi, который является частью кода нашего курса

82
00:02:53,599 --> 00:02:56,160
d  istribution, вы не обязаны его

83
00:02:56,160 --> 00:02:57,360
использовать, на

84
00:02:57,360 --> 00:02:59,040
самом деле единственный контракт, который нам нужно иметь

85
00:02:59,040 --> 00:03:00,800
с вами, заключается в том, что ваша исходная система

86
00:03:00,800 --> 00:03:03,040
имеет метод прогнозирования 1, который

87
00:03:03,040 --> 00:03:06,080
очень напрямую отображает строки в прогнозы,

88
00:03:06,080 --> 00:03:07,760
но в остальном вы ничем не ограничены,

89
00:03:07,760 --> 00:03:09,239
я хочу сказать, хотя  что я думаю, что

90
00:03:09,239 --> 00:03:12,480
sst.experiment - это гибкая структура

91
00:03:12,480 --> 00:03:14,239
для проведения множества экспериментов без

92
00:03:14,239 --> 00:03:16,879
написания большого количества шаблонного кода, поэтому,

93
00:03:16,879 --> 00:03:18,959
если вы привыкнете к ней, она должна стать

94
00:03:18,959 --> 00:03:21,200
для вас мощной основой для проведения

95
00:03:21,200 --> 00:03:22,879
множества экспериментов, которые, я думаю, имеют решающее значение

96
00:03:22,879 --> 00:03:25,840
для успеха.  здесь

97
00:03:26,000 --> 00:03:27,920
мы делаем некоторую настройку, загружая кучу

98
00:03:27,920 --> 00:03:29,120
библиотек

99
00:03:29,120 --> 00:03:31,360
и получая указатель на данные, и это

100
00:03:31,360 --> 00:03:33,440
приводит нас к тренировочному набору здесь, так

101
00:03:33,440 --> 00:03:35,040
что это будет загружаться во фрейм данных pandas,

102
00:03:35,040 --> 00:03:37,120
вы можете видеть, что у нас есть около 8

103
00:03:37,120 --> 00:03:39,200
500 примеров

104
00:03:39,200 --> 00:03:41,120
просмотрите блокнот, охватывающий этот

105
00:03:41,120 --> 00:03:42,799
набор данных, здесь есть множество других

106
00:03:42,799 --> 00:03:44,319
опций для этого считывателя поездов, в

107
00:03:44,319 --> 00:03:45,920
частности, вы можете решить,

108
00:03:45,920 --> 00:03:48,239
сохранять или удалять дубликаты, а также вы

109
00:03:48,239 --> 00:03:49,840
можете решить, хотите ли вы тренироваться

110
00:03:49,840 --> 00:03:51,840
на ярлыке  d поддеревьев, которые содержит sst,

111
00:03:51,840 --> 00:03:54,319
что значительно увеличивает

112
00:03:54,319 --> 00:03:56,400
объем имеющихся у вас обучающих данных, которые

113
00:03:56,400 --> 00:03:58,239
будут очень требовательны к вычислениям, но

114
00:03:58,239 --> 00:04:01,040
могут быть очень продуктивными.

115
00:04:01,040 --> 00:04:02,400


116
00:04:02,400 --> 00:04:04,720


117
00:04:04,720 --> 00:04:07,120
может

118
00:04:07,120 --> 00:04:08,959
быть очень продуктивно ввести

119
00:04:08,959 --> 00:04:10,560
динамический

120
00:04:10,560 --> 00:04:12,000
набор данных, который показан в

121
00:04:12,000 --> 00:04:14,480
скринкасте для этого модуля,

122
00:04:14,480 --> 00:04:16,880
этот набор данных содержит множество предложений

123
00:04:16,880 --> 00:04:19,279
из обзоров ресторанов, и он также был

124
00:04:19,279 --> 00:04:21,358
помечен точно таким же образом с использованием

125
00:04:21,358 --> 00:04:23,600
тех же протоколов, которые использовались для

126
00:04:23,600 --> 00:04:24,880
создания  набор

127
00:04:24,880 --> 00:04:26,560
обзоров ресторанов для этого модуля, который,

128
00:04:26,560 --> 00:04:28,960
как я думаю, существенно отличается

129
00:04:28,960 --> 00:04:32,160
от протоколов, которые использовались для

130
00:04:32,160 --> 00:04:34,160
sst, поэтому добавление большего количества торгуемых обучающих данных

131
00:04:34,160 --> 00:04:35,520
может помочь вам не только с проблемой кросс-

132
00:04:35,520 --> 00:04:37,919
доменной, но и с

133
00:04:37,919 --> 00:04:39,759
изменением ярлыка, которое  вероятно, произошло

134
00:04:39,759 --> 00:04:42,080
между sst и этими новыми

135
00:04:42,080 --> 00:04:45,520
наборами данных для разработки, которые мы представляем,

136
00:04:45,919 --> 00:04:47,440
и это подводит меня к наборам для разработчиков

137
00:04:47,440 --> 00:04:49,360
здесь, поэтому у нас есть sst dev, который также

138
00:04:49,360 --> 00:04:51,120
фрейм данных панды, а также этот новый

139
00:04:51,120 --> 00:04:53,520
фрейм данных отзывов о ресторанах, а также

140
00:04:53,520 --> 00:04:55,120
фрейм данных панды, и здесь вы можете увидеть

141
00:04:55,120 --> 00:04:57,520
только три случайно выбранных примера.

142
00:04:57,520 --> 00:05:00,240


143
00:05:00,240 --> 00:05:01,840


144
00:05:01,840 --> 00:05:04,240


145
00:05:04,240 --> 00:05:06,000
всегда ноль, потому что эти

146
00:05:06,000 --> 00:05:08,880
наборы данных оценки имеют только полные примеры, нет

147
00:05:08,880 --> 00:05:10,960
помеченных поддеревьев, как это

148
00:05:10,960 --> 00:05:13,039
делает набор поездов ssd,

149
00:05:13,039 --> 00:05:14,240
и мы можем взглянуть на распределение меток,

150
00:05:14,240 --> 00:05:16,160
и я просто упомяну, что

151
00:05:16,160 --> 00:05:17,840
распределение меток для тестового

152
00:05:17,840 --> 00:05:19,199
набора очень похоже на

153
00:05:19,199 --> 00:05:20,880
это  имеет одно примечательное свойство, которое заключается в

154
00:05:20,880 --> 00:05:23,199
том, что он сильно искажает множество нейтральных

155
00:05:23,199 --> 00:05:25,199
примеров, которые, я думаю, реалистичны для

156
00:05:25,199 --> 00:05:27,360
фактических данных, даже при обзоре данных, а затем

157
00:05:27,360 --> 00:05:29,039
есть перекос в сторону положительности с

158
00:05:29,039 --> 00:05:30,639
наименьшим отрицательным, и этот вид

159
00:05:30,639 --> 00:05:32,720
дисбаланса меток, я думаю, достаточно серьезный,

160
00:05:32,720 --> 00:05:34,400
чтобы  это может повлиять на

161
00:05:34,400 --> 00:05:37,280
выбор оптимизации, который вы сделаете в

162
00:05:37,280 --> 00:05:38,880
следующем разделе, здесь просто устанавливается

163
00:05:38,880 --> 00:05:41,520
мягкий максимальный базовый уровень, мы используем функцию функции unigrams,

164
00:05:41,520 --> 00:05:42,800
это не может быть

165
00:05:42,800 --> 00:05:44,639
s  impler, мы просто разбиваем

166
00:05:44,639 --> 00:05:46,800
пробелы и подсчитываем полученные токены,

167
00:05:46,800 --> 00:05:48,479
а затем у нас есть очень тонкая оболочка

168
00:05:48,479 --> 00:05:50,720
вокруг логистической регрессии, и

169
00:05:50,720 --> 00:05:52,720
это две части, которые собираются вместе для запуска

170
00:05:52,720 --> 00:05:55,520
здесь sst.experiment

171
00:05:55,520 --> 00:05:56,960
хранится много информации о вашем

172
00:05:56,960 --> 00:05:58,880
эксперименте.  в этой переменной

173
00:05:58,880 --> 00:06:00,560
и то, что выводится на печать, является просто

174
00:06:00,560 --> 00:06:02,960
сводным отчетом о классификации, у нас есть

175
00:06:02,960 --> 00:06:05,039
sst dev и запекание, поскольку наши два

176
00:06:05,039 --> 00:06:07,360
кадра данных оценки результаты для

177
00:06:07,360 --> 00:06:08,960
каждого из них печатаются отдельно

178
00:06:08,960 --> 00:06:11,840
здесь, а затем наша метрика запекания -

179
00:06:11,840 --> 00:06:14,240
это среднее значение  средние макроэкономические показатели f1

180
00:06:14,240 --> 00:06:16,560
по двум наборам данных именно эти

181
00:06:16,560 --> 00:06:18,560
два, но, конечно, во время запекания

182
00:06:18,560 --> 00:06:21,199
мы будем использовать тестовые наборы,

183
00:06:21,199 --> 00:06:22,880
поэтому вы можете руководствоваться здесь своего рода

184
00:06:22,880 --> 00:06:24,720
восхождением на холм по этому числу, а также

185
00:06:24,720 --> 00:06:26,720
обращать внимание на эти два числа, которые

186
00:06:26,720 --> 00:06:28,960
вносят свой вклад в это, так что, например, вы

187
00:06:28,960 --> 00:06:31,120
можете видеть здесь, что, как и ожидалось, поскольку мы

188
00:06:31,120 --> 00:06:33,759
тренировались на sst, мы делаем лучше

189
00:06:33,759 --> 00:06:37,360
на sst dev намного, чем на

190
00:06:37,360 --> 00:06:40,400
новых данных

191
00:06:41,120 --> 00:06:42,560
об отжиге в следующем разделе.  ion здесь просто показывает вам

192
00:06:42,560 --> 00:06:44,880
другой тип базовой линии, и это базовая линия

193
00:06:44,880 --> 00:06:46,840
глубокого обучения, и классификатор rnn,

194
00:06:46,840 --> 00:06:49,440
наша функция функции здесь очень

195
00:06:49,440 --> 00:06:50,800
проста, потому что мы просто разделяем

196
00:06:50,800 --> 00:06:52,960
пробелы, и мы полагаемся на

197
00:06:52,960 --> 00:06:55,039
сам rnn, чтобы выполнить всю характеристику, которая

198
00:06:55,039 --> 00:06:56,800
похожа на встраивание  поиск, а затем

199
00:06:56,800 --> 00:06:58,479
обработка примера,

200
00:06:58,479 --> 00:06:59,840
так что это очень просто, а затем

201
00:06:59,840 --> 00:07:01,440
оболочка также очень проста, здесь мы

202
00:07:01,440 --> 00:07:02,960
собираемся установить словарь для

203
00:07:02,960 --> 00:07:05,520
модели, минимальное количество двух, что кажется

204
00:07:05,520 --> 00:07:07,280
продуктивным, а затем, наконец, запустить

205
00:07:07,280 --> 00:07:08,720
эксперимент и одну вещь, которая

206
00:07:08,720 --> 00:07:10,720
важна  здесь единственное изменение заключается в том, что

207
00:07:10,720 --> 00:07:12,960
здесь вы устанавливаете vectorize равным false, в

208
00:07:12,960 --> 00:07:14,880
отличие от предыдущей базовой линии, мы

209
00:07:14,880 --> 00:07:17,680
не используем векторизаторы scikit-learn dict

210
00:07:17,680 --> 00:07:20,000
для обработки словарей count, чтобы перейти

211
00:07:20,000 --> 00:07:22,639
от функций к матрицам функций.

212
00:07:22,639 --> 00:07:24,319
Здесь мы передаем наши примеры

213
00:07:24,319 --> 00:07:26,000
непосредственно в модель.  наша

214
00:07:26,000 --> 00:07:28,319
модель ожидает потоки токенов без каких-либо

215
00:07:28,319 --> 00:07:30,800
проблем, и поэтому векторизованное значение false

216
00:07:30,800 --> 00:07:32,160
даст им возможность пройти через весь

217
00:07:32,160 --> 00:07:33,680
путь к модели, поэтому помните, что

218
00:07:33,680 --> 00:07:36,080
o  в противном случае все это развалится, но в

219
00:07:36,080 --> 00:07:37,520
остальном это точно такая же

220
00:07:37,520 --> 00:07:39,759
установка, давайте запустим ее здесь, у меня есть некоторая

221
00:07:39,759 --> 00:07:41,520
информация о времени, которую мы собираемся перемотать

222
00:07:41,520 --> 00:07:42,800
вперед, потому что это

223
00:07:42,800 --> 00:07:44,560
займет немного времени, но вы увидите

224
00:07:44,560 --> 00:07:46,800
отчет  и в настоящее время я использую очень

225
00:07:46,800 --> 00:07:49,520
старый Mac на базе процессора, так что

226
00:07:49,520 --> 00:07:51,039
это даст вам представление о

227
00:07:51,039 --> 00:07:52,560
стоимости разработки для глубокого обучения в этом

228
00:07:52,560 --> 00:07:55,560
пространстве,

229
00:08:03,039 --> 00:08:04,800
все в порядке. Критерий ранней остановки нашей модели

230
00:08:04,800 --> 00:08:08,240
был выполнен после 49 эпох,

231
00:08:08,240 --> 00:08:10,639
и вот наш взгляд на  результаты, которые

232
00:08:10,639 --> 00:08:12,160
можно сравнить с тем, что мы видели

233
00:08:12,160 --> 00:08:15,199
с базовой линией softmax,

234
00:08:15,199 --> 00:08:16,479
и это подводит нас к анализу ошибок,

235
00:08:16,479 --> 00:08:18,240
который может стать важным шагом

236
00:08:18,240 --> 00:08:20,080
в улучшении вашей системы. Я написал

237
00:08:20,080 --> 00:08:22,000
несколько функций, которые используют всю

238
00:08:22,000 --> 00:08:23,599
закодированную информацию.  в

239
00:08:23,599 --> 00:08:25,919
возвращаемых значениях для эксперимента с ssd, который, я

240
00:08:25,919 --> 00:08:27,599
надеюсь, собрал вместе все, что вам

241
00:08:27,599 --> 00:08:29,759
нужно для расширенного анализа ошибок, воспроизведите

242
00:08:29,759 --> 00:08:31,840
ваши результаты и используйте вашу модель

243
00:08:31,840 --> 00:08:33,760
в последующих экспериментах,

244
00:08:33,760 --> 00:08:35,440
здесь мы собираемся использовать ее для использования этого

245
00:08:35,440 --> 00:08:37,279
функция находит ошибки.

246
00:08:37,279 --> 00:08:39,519
Я сделал небольшую предварительную

247
00:08:39,519 --> 00:08:40,958
обработку найденных ошибок и

248
00:08:40,958 --> 00:08:43,120
упаковал их вместе, а затем эта ячейка

249
00:08:43,120 --> 00:08:44,880
здесь просто пример того,

250
00:08:44,880 --> 00:08:46,480
что вы можете сделать

251
00:08:46,480 --> 00:08:47,920
здесь, мы рассматриваем случаи, когда

252
00:08:47,920 --> 00:08:49,920
модель softmax была правильной, rnn был

253
00:08:49,920 --> 00:08:51,920
неправильным, а правильная метка была

254
00:08:51,920 --> 00:08:53,760
положительной, вы, конечно, могли бы возиться с

255
00:08:53,760 --> 00:08:55,279
этими параметрами здесь,

256
00:08:55,279 --> 00:08:57,600
у нас есть 168 примеров, попадающих в этот

257
00:08:57,600 --> 00:08:59,120
класс, а затем мы могли бы посмотреть на

258
00:08:59,120 --> 00:09:00,800
образец фактического текста и попасть в этот класс

259
00:09:00,800 --> 00:09:02,880
группа как способ выяснить, чем

260
00:09:02,880 --> 00:09:04,560
отличаются эти модели, и, возможно, улучшить одну или

261
00:09:04,560 --> 00:09:06,480
обе из них,

262
00:09:06,480 --> 00:09:07,600
и это подводит нас к

263
00:09:07,600 --> 00:09:09,279
домашним заданиям, и снова они

264
00:09:09,279 --> 00:09:11,279
предназначены для того, чтобы помочь вам изучить данные и

265
00:09:11,279 --> 00:09:12,800
установить некоторые дополнительные базовые показатели, которые

266
00:09:12,800 --> 00:09:15,040
информируют исходную систему.  мы

267
00:09:15,040 --> 00:09:16,399
собираемся начать с того, который ориентирован на данные,

268
00:09:16,399 --> 00:09:18,000
я назвал это различием уровней токенов,

269
00:09:18,000 --> 00:09:20,399
что я пытаюсь сделать, это

270
00:09:20,399 --> 00:09:22,720
привлечь ваше внимание к тому факту,

271
00:09:22,720 --> 00:09:25,040
что данные sst и новый

272
00:09:25,040 --> 00:09:27,360
обзор ресторана  w данные просто кодируются по-

273
00:09:27,360 --> 00:09:28,399
разному на уровне

274
00:09:28,399 --> 00:09:30,320
токенизации, это в основном

275
00:09:30,320 --> 00:09:32,959
результат того, что sst является своего рода результатом

276
00:09:32,959 --> 00:09:34,959
исторического процесса, начавшегося с Pang

277
00:09:34,959 --> 00:09:36,480
в Lead 2005

278
00:09:36,480 --> 00:09:38,480
и продолжающегося через сам проект

279
00:09:38,480 --> 00:09:40,160
sst, так что есть некоторые забавные вещи

280
00:09:40,160 --> 00:09:41,519
о  я думаю, что это, безусловно, может

281
00:09:41,519 --> 00:09:44,000
повлиять на любой вид передачи из одного

282
00:09:44,000 --> 00:09:45,839
домена в другой, и, поскольку вы

283
00:09:45,839 --> 00:09:48,000
тренируетесь на данных

284
00:09:48,000 --> 00:09:49,440
sst, важно знать, как это

285
00:09:49,440 --> 00:09:51,200
может быть идиосинкразическим,

286
00:09:51,200 --> 00:09:52,959
так что это происходит здесь, вы пишете эту

287
00:09:52,959 --> 00:09:54,640
функцию, получаете количество токенов и, как обычно

288
00:09:54,640 --> 00:09:56,800
у вас есть тест вы проходите тест

289
00:09:56,800 --> 00:10:00,240
хм вы в хорошей форме

290
00:10:01,360 --> 00:10:03,120
следующий вопрос относится к

291
00:10:03,120 --> 00:10:05,040
междоменному характеру нашей проблемы обучение на

292
00:10:05,040 --> 00:10:06,959
некоторых данных об отжиге в этой

293
00:10:06,959 --> 00:10:09,040
стандартной парадигме вы тренируетесь на

294
00:10:09,040 --> 00:10:12,160
ssd оценивая на sst а также это новое

295
00:10:12,160 --> 00:10:13,839
выпечка набора данных предложений из отзывов о ресторанах

296
00:10:13,839 --> 00:10:15,040


297
00:10:15,040 --> 00:10:16,959
что произойдет, если вы дополните свой

298
00:10:16,959 --> 00:10:19,120
обучающий набор небольшим количеством данных

299
00:10:19,120 --> 00:10:20,959
из набора предложений для разработки отзывов о ресторанах,

300
00:10:20,959 --> 00:10:22,880
которые у вас есть m  у вас есть

301
00:10:22,880 --> 00:10:24,399
предчувствие, которое улучшит производительность системы,

302
00:10:24,399 --> 00:10:26,800
и этот вопрос здесь

303
00:10:26,800 --> 00:10:28,399
просто просит вас

304
00:10:28,399 --> 00:10:30,880
провести такой эксперимент, как обычно, у вас

305
00:10:30,880 --> 00:10:32,880
есть тест, я думаю, вы обнаружите, что

306
00:10:32,880 --> 00:10:34,480
это очень продуктивно, помогая вашей

307
00:10:34,480 --> 00:10:36,800
системе получить доступ к новым данным и

308
00:10:36,800 --> 00:10:38,399
что  должен быть ключом к тому, как сделать

309
00:10:38,399 --> 00:10:40,240
действительно хорошую работу с

310
00:10:40,240 --> 00:10:42,800
вашей исходной системой.

311
00:10:42,800 --> 00:10:44,560
следующий вопрос здесь о

312
00:10:44,560 --> 00:10:46,480
представлении признаков более мощная

313
00:10:46,480 --> 00:10:48,399
базовая линия векторного усреднения, это шаг к

314
00:10:48,399 --> 00:10:50,480
глубокому обучению, он основан на этом

315
00:10:50,480 --> 00:10:52,560
разделе  блокнот здесь,

316
00:10:52,560 --> 00:10:54,320
где, по сути, мы усредняем вместе

317
00:10:54,320 --> 00:10:56,000
векторные представления слов для

318
00:10:56,000 --> 00:10:58,160
представления каждого примера, и они являются

319
00:10:58,160 --> 00:11:00,240
входными данными для простого классификатора логистической регрессии,

320
00:11:00,240 --> 00:11:01,600


321
00:11:01,600 --> 00:11:03,440
так что это хорошие низкоразмерные модели,

322
00:11:03,440 --> 00:11:05,600
которые, как правило, являются довольно мощными. этот

323
00:11:05,600 --> 00:11:07,200
вопрос просит вас заменить

324
00:11:07,200 --> 00:11:08,800
логистическую регрессию на  неглубокий

325
00:11:08,800 --> 00:11:10,880
нейронный классификатор, поэтому, возможно, здесь более

326
00:11:10,880 --> 00:11:13,200
мощная часть, а также для изучения

327
00:11:13,200 --> 00:11:14,959
широкого спектра гиперпараметров этой

328
00:11:14,959 --> 00:11:17,200
модели.  чтобы понять, какие

329
00:11:17,200 --> 00:11:20,240
настройки лучше всего подходят для нашей проблемы,

330
00:11:20,240 --> 00:11:22,079
и это подводит нас к кодированию burton, и

331
00:11:22,079 --> 00:11:24,160
это похоже на еще один шаг

332
00:11:24,160 --> 00:11:25,200
вперед к глубокому обучению и

333
00:11:25,200 --> 00:11:27,360
тонкой настройке, этот вопрос просто

334
00:11:27,360 --> 00:11:29,839
просит вас кодировать ваши примеры, используя,

335
00:11:29,839 --> 00:11:32,000
в частности, vert  беря сводное

336
00:11:32,000 --> 00:11:34,560
представление над токеном класса,

337
00:11:34,560 --> 00:11:36,640
окончательный вывод там как ваше сводное

338
00:11:36,640 --> 00:11:38,399
представление всего примера, и

339
00:11:38,399 --> 00:11:40,320
они, предположительно, становятся входными данными для

340
00:11:40,320 --> 00:11:42,320
какого-либо нижестоящего классификатора или,

341
00:11:42,320 --> 00:11:44,880
возможно, процесса точной настройки.

342
00:11:44,880 --> 00:11:46,480
Идея, что это на один шаг

343
00:11:46,480 --> 00:11:48,480
лучше, чем векторное усреднение, которое  мы

344
00:11:48,480 --> 00:11:50,320
только что рассмотрели, что вам не нужно

345
00:11:50,320 --> 00:11:52,320
проводить эксперимент с sst, вы

346
00:11:52,320 --> 00:11:54,160
просто реализуете эту функцию

347
00:11:54,160 --> 00:11:55,440
функции здесь,

348
00:11:55,440 --> 00:11:57,360
но поскольку эксперимент с ssd

349
00:11:57,360 --> 00:11:59,120
действительно упрощает проведение экспериментов после

350
00:11:59,120 --> 00:12:01,120
того, как вы реализовали функцию функции,

351
00:12:01,120 --> 00:12:02,720
я бы посоветовал вам выбрать некоторые

352
00:12:02,720 --> 00:12:05,120
модель классификатора и посмотрите, насколько хорошо это

353
00:12:05,120 --> 00:12:07,360
работает, но, как обычно, у вас есть тест,

354
00:12:07,360 --> 00:12:08,880
и тест касается только

355
00:12:08,880 --> 00:12:10,399
функциональной функции и  d это позволит убедиться, что

356
00:12:10,399 --> 00:12:12,880
вы используете все эти значения правильно,

357
00:12:12,880 --> 00:12:14,160
и это приведет нас к исходной

358
00:12:14,160 --> 00:12:15,680
системе, и я просто хочу напомнить вам,

359
00:12:15,680 --> 00:12:17,760
что вы не ограничены, за исключением

360
00:12:17,760 --> 00:12:19,440
того факта, что вы не можете

361
00:12:19,440 --> 00:12:22,320
использовать тестовый набор sst во время разработки.

362
00:12:22,320 --> 00:12:24,000
метки для этого запрещены, но

363
00:12:24,000 --> 00:12:25,600
все остальное - честная игра, введите

364
00:12:25,600 --> 00:12:27,440
новые обучающие данные, попробуйте новые

365
00:12:27,440 --> 00:12:30,399
архитектуры моделей и т. д., и т. д.

366
00:12:30,399 --> 00:12:32,399
Мы дали здесь несколько идей, но

367
00:12:32,399 --> 00:12:34,000
это ни в коем случае не должно быть

368
00:12:34,000 --> 00:12:36,160
ограничительным, это просто означает  чтобы получить

369
00:12:36,160 --> 00:12:38,720
творческие соки, за исключением того, что

370
00:12:38,720 --> 00:12:40,720
это та же процедура, что и домашняя работа

371
00:12:40,720 --> 00:12:42,480
, мы хотим, чтобы описание вашей

372
00:12:42,480 --> 00:12:44,639
системы информировало группу преподавателей о том, что

373
00:12:44,639 --> 00:12:46,720
сработало, а что нет, и было бы

374
00:12:46,720 --> 00:12:48,720
здорово, если бы вы сообщили свой максимальный балл,

375
00:12:48,720 --> 00:12:51,279
который  макроэкономическое среднее из двух

376
00:12:51,279 --> 00:12:54,079
макросов f1 f1 оценивает для двух наших наборов данных,

377
00:12:54,079 --> 00:12:56,720
которые находятся в наборе для разработки,

378
00:12:56,720 --> 00:12:58,320
и это приводит нас к выпечке, и

379
00:12:58,320 --> 00:13:00,639
снова процедура выпекания знакома.

380
00:13:00,639 --> 00:13:03,040
s,

381
00:13:03,040 --> 00:13:05,680
что вы пишете функцию, предсказующую1

382
00:13:05,680 --> 00:13:08,399
функцию, которая сопоставляет текст непосредственно с

383
00:13:08,399 --> 00:13:11,120
предсказанием, используя вашу исходную систему,

384
00:13:11,120 --> 00:13:13,839
теперь приведенную здесь два примера,

385
00:13:13,839 --> 00:13:15,839
ваш может быть проще в зависимости от

386
00:13:15,839 --> 00:13:17,200
того, используете ли вы

387
00:13:17,200 --> 00:13:19,440
экспериментальную структуру ssd или нет,

388
00:13:19,440 --> 00:13:21,120
но это все вместе  здесь с

389
00:13:21,120 --> 00:13:22,639
созданием выпекания при отправке, где вы

390
00:13:22,639 --> 00:13:24,160
вводите эту функцию,

391
00:13:24,160 --> 00:13:25,519
вам не нужно будет изменять этот выходной

392
00:13:25,519 --> 00:13:27,040
файл, и вы можете видеть, что эта функция

393
00:13:27,040 --> 00:13:28,880
здесь загружается в наши два набора тестов, которые

394
00:13:28,880 --> 00:13:30,160
не помечены,

395
00:13:30,160 --> 00:13:32,880
и использует вашу предсказать одну функцию во

396
00:13:32,880 --> 00:13:34,639
всех этих примерах здесь

397
00:13:34,639 --> 00:13:36,560
а затем записывает файл, который вы затем

398
00:13:36,560 --> 00:13:39,279
загружаете в автогрейдер, чтобы оценить объем,

399
00:13:39,279 --> 00:13:41,440
который происходит здесь, поэтому я просто хотел

400
00:13:41,440 --> 00:13:42,959
бы повторить, что

401
00:13:42,959 --> 00:13:45,360
во всех смыслах метки тестовых данных

402
00:13:45,360 --> 00:13:47,360
полностью недоступны для нас, вся

403
00:13:47,360 --> 00:13:49,680
разработка концептуально и в противном случае

404
00:13:49,680 --> 00:13:54,199
должна происходить на  данные разработки

