1
00:00:05,600 --> 00:00:07,359
привет всем, добро пожаловать в часть 5 в нашей

2
00:00:07,359 --> 00:00:09,280
серии об контролируемом анализе настроений.

3
00:00:09,280 --> 00:00:11,040
В центре внимания этого скринкаста находится

4
00:00:11,040 --> 00:00:13,920
модуль sst.pi, который включен в

5
00:00:13,920 --> 00:00:15,839
дистрибутив кода курса.

6
00:00:15,839 --> 00:00:17,359
Он содержит набор инструментов, которые

7
00:00:17,359 --> 00:00:19,359
позволят вам плавно работать, я надеюсь, со

8
00:00:19,359 --> 00:00:21,359
Стэнфордом.  банк дерева настроений и

9
00:00:21,359 --> 00:00:23,439
провести множество экспериментов

10
00:00:23,439 --> 00:00:25,199
для выполнения домашней работы,

11
00:00:25,199 --> 00:00:27,199
а также для создания оригинальной системной записи

12
00:00:27,199 --> 00:00:29,599
для выпечки. Я бы сказал, что мои цели

13
00:00:29,599 --> 00:00:31,359
для скринкаста двоякие, во-первых,

14
00:00:31,359 --> 00:00:32,800
я просто хочу познакомить вас с

15
00:00:32,800 --> 00:00:34,719
этим кодом.  так что вы можете работать с ним

16
00:00:34,719 --> 00:00:36,880
над заданием в выпечке, и,

17
00:00:36,880 --> 00:00:38,480
кроме того, я думаю, я хотел бы поделиться

18
00:00:38,480 --> 00:00:40,719
с вами некоторыми передовыми методами

19
00:00:40,719 --> 00:00:43,120
настройки инфраструктуры кода для

20
00:00:43,120 --> 00:00:45,360
проекта, скажем, что позволит вам провести

21
00:00:45,360 --> 00:00:47,360
много экспериментов  и действительно исследуйте

22
00:00:47,360 --> 00:00:49,200
пространство идей, которые у вас есть,

23
00:00:49,200 --> 00:00:50,879
не вводя много ошибок или не

24
00:00:50,879 --> 00:00:53,199
написав много дополнительного кода,

25
00:00:53,199 --> 00:00:54,640
поэтому давайте начнем, мы начнем с этих

26
00:00:54,640 --> 00:00:56,480
функций чтения вверху и

27
00:00:56,480 --> 00:00:58,480
первая ячейка здесь ij  просто загрузите не только

28
00:00:58,480 --> 00:01:00,559
os, в котором мы можем найти наши файлы, но и

29
00:01:00,559 --> 00:01:03,280
sst, представляющий интерес,

30
00:01:03,280 --> 00:01:05,280
мы настраиваем эту переменную здесь, это

31
00:01:05,280 --> 00:01:07,280
указатель на то, где живет сам набор данных,

32
00:01:07,280 --> 00:01:08,159


33
00:01:08,159 --> 00:01:09,640
а затем эта функция

34
00:01:09,640 --> 00:01:12,080
sst.trainreader позволит вам загрузить в

35
00:01:12,080 --> 00:01:14,320
Фрейм данных pandas, который содержит

36
00:01:14,320 --> 00:01:16,640
набор поездов для sst, вы заметите, что

37
00:01:16,640 --> 00:01:18,880
есть два необязательных ключевых слова include

38
00:01:18,880 --> 00:01:20,560
subtrees, а ddo

39
00:01:20,560 --> 00:01:22,880
dupe удалит повторяющиеся примеры и

40
00:01:22,880 --> 00:01:24,799
включит поддеревья в качестве флага, который позволит

41
00:01:24,799 --> 00:01:27,439
вам включить или исключить все поддеревья,

42
00:01:27,439 --> 00:01:29,920
которые  sst содержит по умолчанию,

43
00:01:29,920 --> 00:01:32,320
мы включим только полные примеры, но

44
00:01:32,320 --> 00:01:35,040
если вы установите значение include subtrees равным true,

45
00:01:35,040 --> 00:01:37,119
вы получите гораздо больший набор данных, как мы

46
00:01:37,119 --> 00:01:39,759
обсуждали в скринкасте самого sst

47
00:01:39,759 --> 00:01:40,960


48
00:01:40,960 --> 00:01:42,479
в ячейке 4, здесь я просто даю вам

49
00:01:42,479 --> 00:01:45,040
взглянуть на  одна случайная запись из этого, так что

50
00:01:45,040 --> 00:01:47,200
помните, что это фрейм данных pandas, но

51
00:01:47,200 --> 00:01:48,720
мы можем получить его как словарь для

52
00:01:48,720 --> 00:01:50,640
немного более легкого взгляда, у нас есть

53
00:01:50,640 --> 00:01:52,960
пример идентификатора, у нас есть текст

54
00:01:52,960 --> 00:01:54,960
предложения, метка, которая либо

55
00:01:54,960 --> 00:01:57,360
отрицательная,  ve или нейтральное, а затем является

56
00:01:57,360 --> 00:01:59,439
поддеревом — это флаг того, является ли

57
00:01:59,439 --> 00:02:01,360
это примером полного корневого уровня или

58
00:02:01,360 --> 00:02:04,719
составной частью такого примера,

59
00:02:04,719 --> 00:02:06,000
поскольку мы загрузили это с

60
00:02:06,000 --> 00:02:08,318
включенными поддеревьями, равными false, мы получаем

61
00:02:08,318 --> 00:02:10,160
это распределение меток здесь, это

62
00:02:10,160 --> 00:02:12,080
просто распределение  меток в

63
00:02:12,080 --> 00:02:13,520
полных примерах,

64
00:02:13,520 --> 00:02:15,200
но, конечно, когда мы изменим эти флаги,

65
00:02:15,200 --> 00:02:16,800
мы получим здесь очень разные подсчеты,

66
00:02:16,800 --> 00:02:18,000


67
00:02:18,000 --> 00:02:19,680
а затем произойдет что-то сопоставимое

68
00:02:19,680 --> 00:02:22,040
с dev reader dev df из

69
00:02:22,040 --> 00:02:24,640
sst.devreader с указателем на домашний

70
00:02:24,640 --> 00:02:26,800
каталог для данных, как и раньше,

71
00:02:26,800 --> 00:02:28,640
и  здесь различие поддеревьев и

72
00:02:28,640 --> 00:02:30,640
различие дедупликации гораздо менее

73
00:02:30,640 --> 00:02:32,239
важны, потому что эти наборы данных

74
00:02:32,239 --> 00:02:34,560
состоят только из примеров корневого уровня, и

75
00:02:34,560 --> 00:02:36,480
в этих наборах данных очень мало дублирующихся примеров, если они вообще

76
00:02:36,480 --> 00:02:39,920
есть.

77
00:02:40,959 --> 00:02:42,480
Теперь давайте обратимся к функциям признаков,

78
00:02:42,480 --> 00:02:44,319
мы начнем создавать  основу для

79
00:02:44,319 --> 00:02:46,879
проведения контролируемого анализа настроений,

80
00:02:46,879 --> 00:02:48,800
и отправной точкой здесь является то, что я

81
00:02:48,800 --> 00:02:50,959
называю функциональной функцией, которая дается в

82
00:02:50,959 --> 00:02:53,599
двух униграммах фи, которые она принимает в тексте, который  t

83
00:02:53,599 --> 00:02:56,319
- это строка, и она возвращает

84
00:02:56,319 --> 00:02:58,640
словарь, который, по сути, является

85
00:02:58,640 --> 00:03:01,040
словарем подсчета по униграммам в этой

86
00:03:01,040 --> 00:03:01,920
строке,

87
00:03:01,920 --> 00:03:03,840
как указано в этой очень простой

88
00:03:03,840 --> 00:03:05,680
схеме токенизации, которая просто

89
00:03:05,680 --> 00:03:08,319
обрабатывает все токены, а затем разбивается

90
00:03:08,319 --> 00:03:09,840
на пробел,

91
00:03:09,840 --> 00:03:12,080
так что в качестве примера  текст, если у меня есть nlu, является

92
00:03:12,080 --> 00:03:13,519
просветляющим пробелом, а затем

93
00:03:13,519 --> 00:03:16,159
восклицательным знаком, и я

94
00:03:16,159 --> 00:03:18,400
вызываю функцию функции для этой строки, я

95
00:03:18,400 --> 00:03:20,319
получаю здесь этот словарь подсчета, который

96
00:03:20,319 --> 00:03:22,000
просто дает количество раз, когда каждый

97
00:03:22,000 --> 00:03:24,560
токен появляется в этой строке в соответствии

98
00:03:24,560 --> 00:03:26,239
с функцией функции

99
00:03:26,239 --> 00:03:27,680
i'  d сказать, что это действительно важно, когда

100
00:03:27,680 --> 00:03:29,360
вы работаете со стандартной

101
00:03:29,360 --> 00:03:30,959
версией этой платформы, выполняя созданные вручную

102
00:03:30,959 --> 00:03:33,360
функции функций, которые вы просто соблюдаете

103
00:03:33,360 --> 00:03:35,120
в контракте, согласно которому все эти функции

104
00:03:35,120 --> 00:03:38,239
функций принимают строки и возвращают

105
00:03:38,239 --> 00:03:40,400
словари, отображающие строки в свои

106
00:03:40,400 --> 00:03:42,879
учетные записи, или если вы  хотите, чтобы они были логическими

107
00:03:42,879 --> 00:03:44,720
или плавающими, или чем-то, что мы можем

108
00:03:44,720 --> 00:03:48,480
использовать, когда мы делаем характеристику,

109
00:03:48,720 --> 00:03:50,239
следующим здесь является то, что я назвал

110
00:03:50,239 --> 00:03:51,920
оболочкой модели, и это  здесь будет

111
00:03:51,920 --> 00:03:53,439
выглядеть немного тривиально, но, как вы увидите,

112
00:03:53,439 --> 00:03:55,120
когда мы пройдемся по более продвинутым

113
00:03:55,120 --> 00:03:56,799
методам в этом разделе, особенно в следующем

114
00:03:56,799 --> 00:03:58,959
скринкасте, действительно приятно иметь

115
00:03:58,959 --> 00:04:01,200
эти обертки вокруг нормали, по

116
00:04:01,200 --> 00:04:04,159
сути, функции подгонки,

117
00:04:04,159 --> 00:04:05,680
поэтому я собираюсь  чтобы использовать линейную модель scikit,

118
00:04:05,680 --> 00:04:07,439
называемую логистической регрессией,

119
00:04:07,439 --> 00:04:09,519
очень стандартную сторону классификатора перекрестной энтропии,

120
00:04:09,519 --> 00:04:12,080
я назвал свою функцию подходящей

121
00:04:12,080 --> 00:04:14,000
классификатором softmax, и она принимает

122
00:04:14,000 --> 00:04:17,199
контролируемый набор данных, поэтому матрица функций

123
00:04:17,199 --> 00:04:19,358
и список меток,

124
00:04:19,358 --> 00:04:21,279
и я настроил свою модель  здесь внизу, и я

125
00:04:21,279 --> 00:04:22,880
использовал некоторые параметры ключевого слова

126
00:04:22,880 --> 00:04:25,440
, для модели scikit есть еще много других,

127
00:04:25,440 --> 00:04:26,639
а затем важно то, что я

128
00:04:26,639 --> 00:04:28,960
вызываю подгонку и возвращаю модель, которая

129
00:04:28,960 --> 00:04:31,360
теперь является обученной моделью, обученной этому

130
00:04:31,360 --> 00:04:32,960
набору данных xy,

131
00:04:32,960 --> 00:04:34,720
это может выглядеть так  все, что я сделал, это вызов

132
00:04:34,720 --> 00:04:36,560
подгонки для модели, которую я настроил, но, как

133
00:04:36,560 --> 00:04:38,639
вы увидите, приятно иметь функцию-оболочку,

134
00:04:38,639 --> 00:04:40,560
так что мы потенциально можем сделать

135
00:04:40,560 --> 00:04:43,199
гораздо больше в рамках этого конкретного шага

136
00:04:43,199 --> 00:04:45,840
в нашем экспериментальном рабочем процессе,

137
00:04:45,840 --> 00:04:47,280
так что теперь le  просто объединим все эти вещи

138
00:04:47,280 --> 00:04:49,360
в так называемый

139
00:04:49,360 --> 00:04:51,440
эксперимент sst, который похож

140
00:04:51,440 --> 00:04:53,360
на покупку полного эксперимента в

141
00:04:53,360 --> 00:04:55,600
контролируемом анализе настроений,

142
00:04:55,600 --> 00:04:57,600
поэтому мы загружаем эти две библиотеки, мы

143
00:04:57,600 --> 00:04:59,360
получаем указатель на наш

144
00:04:59,360 --> 00:05:02,479
набор данных um, а затем вызываем эксперимент ssd

145
00:05:02,479 --> 00:05:04,560
первый  аргумент - это набор, который

146
00:05:04,560 --> 00:05:06,240
будет набором данных, на котором мы будем обучаться, так

147
00:05:06,240 --> 00:05:08,560
что это похоже на обучение df до

148
00:05:08,560 --> 00:05:10,720
того, как у нас будет функция функции и оболочка модели,

149
00:05:10,720 --> 00:05:12,639
а затем эти другие вещи являются

150
00:05:12,639 --> 00:05:14,639
необязательными, поэтому, если я оставлю оценку

151
00:05:14,639 --> 00:05:16,080
кадров данных как нет,

152
00:05:16,080 --> 00:05:18,080
тогда это  сделает случайное разделение на этом

153
00:05:18,080 --> 00:05:20,560
считывателе поездов в соответствии с размером поезда, если

154
00:05:20,560 --> 00:05:22,639
вы укажете здесь несколько кадров данных, их

155
00:05:22,639 --> 00:05:24,400
список, и каждый из них будет использоваться

156
00:05:24,400 --> 00:05:26,720
как отдельная оценка по сравнению с

157
00:05:26,720 --> 00:05:28,560
моделью, которую вы обучаете на этих исходных

158
00:05:28,560 --> 00:05:29,520
данных,

159
00:05:29,520 --> 00:05:31,600
вы можете установить оценку  функция, если вы

160
00:05:31,600 --> 00:05:34,080
хотите, чтобы по умолчанию у нас был макрос f1,

161
00:05:34,080 --> 00:05:35,360
а затем мы вернемся к этим двум

162
00:05:35,360 --> 00:05:36,960
параметрам позже.

163
00:05:36,960 --> 00:05:38,400


164
00:05:38,400 --> 00:05:40,560


165
00:05:40,560 --> 00:05:42,639
off, и вы, вероятно, выключите его,

166
00:05:42,639 --> 00:05:44,479
когда будете проводить эксперименты по глубокому обучению, о

167
00:05:44,479 --> 00:05:46,240
которых мы поговорим позже

168
00:05:46,240 --> 00:05:47,680
в этом модуле.

169
00:05:47,680 --> 00:05:49,520


170
00:05:49,520 --> 00:05:51,120


171
00:05:51,120 --> 00:05:53,440


172
00:05:53,440 --> 00:05:55,680
вы получаете отчет

173
00:05:55,680 --> 00:05:56,479
здесь,

174
00:05:56,479 --> 00:05:58,240
и это просто первый шанс отметить

175
00:05:58,240 --> 00:06:00,160
, что на протяжении всего курса, по

176
00:06:00,160 --> 00:06:02,080
сути, когда мы проводим

177
00:06:02,080 --> 00:06:04,560
эксперименты с классификатором, нашей основной метрикой

178
00:06:04,560 --> 00:06:07,680
будет макросредняя оценка f1, это

179
00:06:07,680 --> 00:06:09,360
полезно для нас, потому что дает равный

180
00:06:09,360 --> 00:06:11,600
вес всем  классы в наших данных,

181
00:06:11,600 --> 00:06:14,160
независимо от их размера, что

182
00:06:14,160 --> 00:06:15,840
обычно отражает нашу ценность, что мы

183
00:06:15,840 --> 00:06:17,759
заботимся даже о небольших классах, которые мы

184
00:06:17,759 --> 00:06:19,440
хотим преуспеть даже в редких событиях в нашем

185
00:06:19,440 --> 00:06:20,639
пространстве,

186
00:06:20,639 --> 00:06:22,160
и это также идеально уравновешивает

187
00:06:22,160 --> 00:06:23,680
точность и отзыв, что похоже на

188
00:06:23,680 --> 00:06:26,240
хорошую нулевую гипотезу, если  нам не говорят

189
00:06:26,240 --> 00:06:28,400
заранее, основываясь на какой-то другой цели

190
00:06:28,400 --> 00:06:30,080
, следует ли нам отдавать предпочтение точности или

191
00:06:30,080 --> 00:06:31,280
отзыву,

192
00:06:31,280 --> 00:06:33,039
так что все приводит нас к некоторому преимуществу

193
00:06:33,039 --> 00:06:35,520
по умолчанию, этот макросредний показатель f1 равен

194
00:06:35,520 --> 00:06:37,600
оценка того, как модель сделала

195
00:06:37,600 --> 00:06:41,240
здесь, у нас есть

196
00:06:41,280 --> 00:06:44,240
51,3 возвращаемое значение sst.experiment, как я уже

197
00:06:44,240 --> 00:06:45,919
сказал, является словарем, и он должен

198
00:06:45,919 --> 00:06:48,080
упаковать для вас все объекты и

199
00:06:48,080 --> 00:06:50,000
информацию, которые вам понадобятся для тестирования

200
00:06:50,000 --> 00:06:52,400
модели, оценить модель и сделать  все

201
00:06:52,400 --> 00:06:54,160
виды глубокого анализа ошибок, что является

202
00:06:54,160 --> 00:06:55,680
философией здесь, что вы должны, если

203
00:06:55,680 --> 00:06:58,000
возможно, собрать как можно больше информации

204
00:06:58,000 --> 00:06:59,520
об эксперименте, который вы

205
00:06:59,520 --> 00:07:00,319


206
00:07:00,319 --> 00:07:01,759
провели, чтобы иметь возможность проводить

207
00:07:01,759 --> 00:07:04,000
последующий анализ того, что

208
00:07:04,000 --> 00:07:05,840
произошло, поэтому здесь я просто даю

209
00:07:05,840 --> 00:07:07,599
пример того, что у нас есть модель

210
00:07:07,599 --> 00:07:09,840
функция функции обученный набор данных

211
00:07:09,840 --> 00:07:11,520
всякий раз, когда использовались оцененные наборы данных,

212
00:07:11,520 --> 00:07:13,120
и если это было случайное разделение

213
00:07:13,120 --> 00:07:14,800
данных поезда, которое будет отражено в

214
00:07:14,800 --> 00:07:16,800
этих двух переменных набор

215
00:07:16,800 --> 00:07:18,479
прогнозов, которые вы сделали о каждой  одна

216
00:07:18,479 --> 00:07:20,720
из оцененных данных устанавливает

217
00:07:20,720 --> 00:07:23,360
выбранные вами показатели и полученные вами баллы,

218
00:07:23,360 --> 00:07:24,880
а затем, если вы погрузитесь, как если бы вы

219
00:07:24,880 --> 00:07:27,120
посмотрели на набор поездов, это стандартный набор данных.

220
00:07:27,120 --> 00:07:30,319
x — ваше будущее пространство. y — ваши

221
00:07:30,319 --> 00:07:32,400
метки.  rizer — это то, к чему я

222
00:07:32,400 --> 00:07:34,479
вернусь, это важная часть о

223
00:07:34,479 --> 00:07:36,319
том, как работает внутренняя работа

224
00:07:36,319 --> 00:07:38,160
эксперимента с ssd, а затем у вас

225
00:07:38,160 --> 00:07:40,160
есть необработанные примеры на случай, если вам понадобится провести

226
00:07:40,160 --> 00:07:42,400
действительно серьезный анализ ошибок на человеческом уровне

227
00:07:42,400 --> 00:07:44,560
в примерах,

228
00:07:44,560 --> 00:07:46,639
в отличие от того, как они  представлены

229
00:07:46,639 --> 00:07:49,599
в этом функциональном пространстве,

230
00:07:49,840 --> 00:07:51,680
так что вот только слайд, который

231
00:07:51,680 --> 00:07:53,199
объединяет все эти части,

232
00:07:53,199 --> 00:07:55,039
это универсальный магазин для всего

233
00:07:55,039 --> 00:07:57,680
эксперимента, который мы загружаем во все наши библиотеки,

234
00:07:57,680 --> 00:07:59,599
у нас есть указатель на данные, а

235
00:07:59,599 --> 00:08:01,199
затем ингредиенты действительно являются  функцию

236
00:08:01,199 --> 00:08:04,080
функции и оболочку модели, и это

237
00:08:04,080 --> 00:08:06,319
все, что вам нужно в нашей настройке по умолчанию,

238
00:08:06,319 --> 00:08:08,000
укажите ее на данные поезда, и она

239
00:08:08,000 --> 00:08:10,639
выполнит свою работу и запишет все, что вам нужно

240
00:08:10,639 --> 00:08:12,560
для этого эксперимента, я надеюсь, что в этой

241
00:08:12,560 --> 00:08:15,919
переменной эксперимента

242
00:08:15,919 --> 00:08:17,520
есть последняя часть, которую я хочу  вернуться

243
00:08:17,520 --> 00:08:19,680
к той переменной векторизатора, которую вы видели

244
00:08:19,680 --> 00:08:22,720
в возвращаемых значениях для эксперимента sst,

245
00:08:22,720 --> 00:08:24,160
и которая использует то, что внутри

246
00:08:24,160 --> 00:08:27,039
комплекта обучения называется векторизатором dict,

247
00:08:27,039 --> 00:08:28,879
и это действительно приятно, удобно

248
00:08:28,879 --> 00:08:31,440
nce для преобразования человеческих

249
00:08:31,440 --> 00:08:33,599
представлений ваших данных в

250
00:08:33,599 --> 00:08:35,440
представления, которые любят использовать модели машинного обучения,

251
00:08:35,440 --> 00:08:37,200


252
00:08:37,200 --> 00:08:38,958
поэтому позвольте мне просто пройтись по этому примеру

253
00:08:38,958 --> 00:08:40,399
здесь, я загрузил

254
00:08:40,399 --> 00:08:42,479
векторизатор, и у меня есть

255
00:08:42,479 --> 00:08:44,399
функции поезда здесь в режиме, который я только что

256
00:08:44,399 --> 00:08:46,399
показал  вы, где здесь у нас есть два

257
00:08:46,399 --> 00:08:48,800
примера, и каждый из них представлен

258
00:08:48,800 --> 00:08:51,040
нашей функциональной функцией в виде словаря,

259
00:08:51,040 --> 00:08:54,560
который отображает похожие слова в их учетные записи,

260
00:08:54,560 --> 00:08:56,080
вы можете быть более гибкими, чем это, но

261
00:08:56,080 --> 00:08:57,680
это похоже на самый простой случай, который мы

262
00:08:57,680 --> 00:08:58,959
рассматриваем,

263
00:08:58,959 --> 00:09:02,560
когда я настроил мой векторизатор в  three,

264
00:09:02,560 --> 00:09:05,279
а затем я вызываю подходящее преобразование в этом

265
00:09:05,279 --> 00:09:06,959
списке словарей,

266
00:09:06,959 --> 00:09:10,320
и результат здесь x train представляет собой матрицу,

267
00:09:10,320 --> 00:09:12,720
где каждый из столбцов

268
00:09:12,720 --> 00:09:15,200
соответствует ключам в словаре,

269
00:09:15,200 --> 00:09:16,880
представляющим уникальную функцию,

270
00:09:16,880 --> 00:09:18,800
и значения, конечно, хранятся

271
00:09:18,800 --> 00:09:21,279
в этом столбце, поэтому  это

272
00:09:21,279 --> 00:09:24,560
пространство признаков здесь было превращено в

273
00:09:24,560 --> 00:09:26,480
матрицу, которая имеет два нулевых примера и

274
00:09:26,480 --> 00:09:28,800
один, всего три признака,

275
00:09:28,800 --> 00:09:31,200
представленные в наших двух примерах a  b

276
00:09:31,200 --> 00:09:32,240
и c

277
00:09:32,240 --> 00:09:34,000
uh, и вы можете видеть, что счетчики

278
00:09:34,000 --> 00:09:36,240
хранятся здесь, поэтому в примере ноль имеет единицу для

279
00:09:36,240 --> 00:09:37,200
a

280
00:09:37,200 --> 00:09:41,120
и ноль для uh один для b и ноль для c,

281
00:09:41,120 --> 00:09:44,560
а пример один имеет ноль для a

282
00:09:44,560 --> 00:09:47,040
один для b и два для c,

283
00:09:47,040 --> 00:09:49,120
так что это записано в  столбцы здесь,

284
00:09:49,120 --> 00:09:50,399
вы, конечно, можете

285
00:09:50,399 --> 00:09:52,720
выполнить этот шаг вручную, но это своего

286
00:09:52,720 --> 00:09:54,959
рода шаг, подверженный ошибкам, и я просто

287
00:09:54,959 --> 00:09:56,800
призываю вас использовать векторизатор члена,

288
00:09:56,800 --> 00:09:59,279
чтобы справиться со всем этим и, по сути, отобразить вас

289
00:09:59,279 --> 00:10:00,880
из этого, который довольно интерпретируется человеком,

290
00:10:00,880 --> 00:10:02,800
в это, что

291
00:10:02,800 --> 00:10:06,000
что-то, что ваши модели любят потреблять,

292
00:10:06,000 --> 00:10:07,839
есть следующее, здесь есть второе

293
00:10:07,839 --> 00:10:09,680
преимущество, которое заключается в том, что если вы

294
00:10:09,680 --> 00:10:12,320
используете векторизатор члена и вам нужно теперь что-

295
00:10:12,320 --> 00:10:14,160
то сделать во время тестирования,

296
00:10:14,160 --> 00:10:16,079
вы можете легко использовать свой векторизатор для

297
00:10:16,079 --> 00:10:17,440
создания пространственных признаков, которые

298
00:10:17,440 --> 00:10:19,440
гармонируют с тем, что вы видели  на тренировке

299
00:10:19,440 --> 00:10:22,160
, например, если мои тестовые функции представляют собой

300
00:10:22,160 --> 00:10:23,680
еще одну пару примеров с

301
00:10:23,680 --> 00:10:25,920
другим символом,

302
00:10:25,920 --> 00:10:28,560
тогда я могу вызвать преобразование

303
00:10:28,560 --> 00:10:31,040
исходной векторизации поезда отсюда,

304
00:10:31,040 --> 00:10:32,720
и он переведет этот список

305
00:10:32,720 --> 00:10:33,760
функций

306
00:10:33,760 --> 00:10:36,079
в матр  ix теперь важно

307
00:10:36,079 --> 00:10:37,440
то, что здесь происходит, это то, что он

308
00:10:37,440 --> 00:10:40,160
собирается упаковать тестовые функции

309
00:10:40,160 --> 00:10:41,839
в исходное обучающее пространство, потому что,

310
00:10:41,839 --> 00:10:43,279
конечно, это функции, которые ваша

311
00:10:43,279 --> 00:10:45,680
модель распознает, это функции

312
00:10:45,680 --> 00:10:47,120
, для которых у вас есть веса, если вы

313
00:10:47,120 --> 00:10:48,959
обучили модель  поэтому важно

314
00:10:48,959 --> 00:10:51,360
вызвать преобразование в пространстве, и в качестве

315
00:10:51,360 --> 00:10:52,880
указания на то, что

316
00:10:52,880 --> 00:10:54,959
здесь произойдет, обратите внимание, что

317
00:10:54,959 --> 00:10:56,959
в тестовых функциях мой второй пример

318
00:10:56,959 --> 00:10:58,959
имеет совершенно новую функцию d,

319
00:10:58,959 --> 00:11:01,279
но d не представлен в учебном

320
00:11:01,279 --> 00:11:03,200
пространстве, которое у нас есть.  для него нет весов, он

321
00:11:03,200 --> 00:11:05,200
просто не является частью этого исходного

322
00:11:05,200 --> 00:11:06,880
набора обучающих данных,

323
00:11:06,880 --> 00:11:08,640
и поэтому результат заключается в том, что когда мы вызываем

324
00:11:08,640 --> 00:11:10,480
преобразование, эта функция просто

325
00:11:10,480 --> 00:11:11,920


326
00:11:11,920 --> 00:11:13,839
выделяется, что является желаемым поведением, поскольку мы

327
00:11:13,839 --> 00:11:16,399
переводим от обучения к тестированию,

328
00:11:16,399 --> 00:11:18,399
и он заметил, что векторизатор члена

329
00:11:18,399 --> 00:11:20,240
просто справился с этим без проблем для

330
00:11:20,240 --> 00:11:21,120
вас,

331
00:11:21,120 --> 00:11:23,360
при условии, что вы помните на втором

332
00:11:23,360 --> 00:11:25,680
этапе, чтобы не вызывать подходящее преобразование, которое

333
00:11:25,680 --> 00:11:28,320
является ошибкой номер один для этого интерфейса.

334
00:11:28,320 --> 00:11:30,079
что если вы вызовете преобразование подгонки во

335
00:11:30,079 --> 00:11:32,320
второй раз, оно просто изменит

336
00:11:32,320 --> 00:11:34,320
пространство функций на то, которое

337
00:11:34,320 --> 00:11:36,480
представлено в ваших тестовых функциях, и

338
00:11:36,480 --> 00:11:38,399
тогда все развалится, и ваша

339
00:11:38,399 --> 00:11:39,440
модель

340
00:11:39,440 --> 00:11:41,360
, обученная ранее, не сможет

341
00:11:41,360 --> 00:11:43,680
использовать эти новые матрицы, которые вы  мы

342
00:11:43,680 --> 00:11:45,839
создали, но при условии, что вы помните,

343
00:11:45,839 --> 00:11:47,600
что ритм соответствует преобразованию, а затем

344
00:11:47,600 --> 00:11:49,200
преобразованию,

345
00:11:49,200 --> 00:11:50,800
это должен быть действительно хороший набор

346
00:11:50,800 --> 00:11:52,720
интерфейсов, и, конечно же, это то, что

347
00:11:52,720 --> 00:11:55,600
sst Experiment делает

348
00:11:55,600 --> 00:11:59,639
для вас по умолчанию под капотом.

