1
00:00:04,880 --> 00:00:06,640
приветствую всех, это вторая часть нашей

2
00:00:06,640 --> 00:00:07,839
серии статей, посвященных пониманию обоснованного языка.

3
00:00:07,839 --> 00:00:10,160
Наша задача в этом разделе, по

4
00:00:10,160 --> 00:00:11,519
сути, состоит в задаче создания естественного языка,

5
00:00:11,519 --> 00:00:13,679
и я назвал этих

6
00:00:13,679 --> 00:00:15,839
говорящих идеями, которые говорящие исходят

7
00:00:15,839 --> 00:00:17,600
из мира, это какая-то неязыковая

8
00:00:17,600 --> 00:00:18,880
вещь, которую они  мы пытаемся

9
00:00:18,880 --> 00:00:21,439
общаться на языке, это на самом деле

10
00:00:21,439 --> 00:00:24,320
центральные агенты, которые мы будем исследовать,

11
00:00:24,320 --> 00:00:25,760
чтобы обосновать все это, у нас будет

12
00:00:25,760 --> 00:00:27,199
простая задача, я начну с

13
00:00:27,199 --> 00:00:29,039
самой простой версии задачи, которая в

14
00:00:29,039 --> 00:00:30,800
конечном итоге будет решать  в нашем задании и

15
00:00:30,800 --> 00:00:33,920
выпечке, и это цветовая ссылка,

16
00:00:33,920 --> 00:00:35,760
так что это примеры, взятые из

17
00:00:35,760 --> 00:00:37,280
корпуса, который изначально был правильно

18
00:00:37,280 --> 00:00:40,160
собран Рэндаллом Монро из XKCD Fame

19
00:00:40,160 --> 00:00:42,000
и обработан в задаче

20
00:00:42,000 --> 00:00:44,960
НЛП Макмахоном в камне 2015. и это простая

21
00:00:44,960 --> 00:00:46,480
формулировка в том, что  состояние

22
00:00:46,480 --> 00:00:48,160
мира, о котором мы хотим сообщить, — это

23
00:00:48,160 --> 00:00:49,440
цветовое пятно,

24
00:00:49,440 --> 00:00:50,960
и задача состоит в том, чтобы просто дать

25
00:00:50,960 --> 00:00:52,879
описание этих цветовых пятен, и

26
00:00:52,879 --> 00:00:54,320
я привел здесь несколько примеров, и вы

27
00:00:54,320 --> 00:00:56,160
можете видеть, что  они варьируются от простых

28
00:00:56,160 --> 00:00:59,120
однословных описаний до

29
00:00:59,120 --> 00:01:00,719
вещей, которые довольно сложны как в

30
00:01:00,719 --> 00:01:02,719
когнитивном, так и в лингвистическом отношении, и я

31
00:01:02,719 --> 00:01:04,559
думаю, что они указывают на идею о том, что, хотя

32
00:01:04,559 --> 00:01:06,720
это простая и ограниченная область,

33
00:01:06,720 --> 00:01:08,159
она довольно

34
00:01:08,159 --> 00:01:11,520
интересна с точки зрения познания и языка,

35
00:01:11,680 --> 00:01:14,320
поэтому  наши динамики, ну, по крайней мере, наши базовые

36
00:01:14,320 --> 00:01:16,320
динамики являются стандартными версиями

37
00:01:16,320 --> 00:01:18,560
моделей кодировщика-декодера, которые мы собираемся

38
00:01:18,560 --> 00:01:20,720
иметь для этой начальной формулировки очень

39
00:01:20,720 --> 00:01:22,720
простой кодировщик задача кодировщика

40
00:01:22,720 --> 00:01:25,280
состоит в том, чтобы просто взять цветовое представление,

41
00:01:25,280 --> 00:01:27,840
которое будет списком с плавающей запятой

42
00:01:27,840 --> 00:01:30,320
вставьте его в какое-то пространство для встраивания, а

43
00:01:30,320 --> 00:01:32,320
затем изучите какое-то скрытое представление

44
00:01:32,320 --> 00:01:34,079
для этого цвета, и это все, что нужно

45
00:01:34,079 --> 00:01:36,400
сделать, так что это всего лишь один шаг,

46
00:01:36,400 --> 00:01:38,240
когда декодер находится там, где происходит говорящая часть

47
00:01:38,240 --> 00:01:40,320
, поэтому начальный токен,

48
00:01:40,320 --> 00:01:42,560
созданный декодером говорящим, всегда является

49
00:01:42,560 --> 00:01:44,320
началом  токен, который просматривается в

50
00:01:44,320 --> 00:01:45,920
пространстве встраивания,

51
00:01:45,920 --> 00:01:47,759
а затем мы получаем наше первое скрытое состояние декодера,

52
00:01:47,759 --> 00:01:50,560
которое создается из представления цвета.

53
00:01:50,560 --> 00:01:52,640
в качестве начального скрытого

54
00:01:52,640 --> 00:01:53,920
состояния в последовательности, которую мы собираемся

55
00:01:53,920 --> 00:01:55,840
построить вместе с встраиванием, и

56
00:01:55,840 --> 00:01:56,799
оба они имеют весовые

57
00:01:56,799 --> 00:01:58,399
преобразования, и их аддитивная

58
00:01:58,399 --> 00:02:00,719
комбинация обеспечивает это

59
00:02:00,719 --> 00:02:02,960
значение h1 здесь,

60
00:02:02,960 --> 00:02:04,799
тогда мы используем некоторые параметры softmax, чтобы

61
00:02:04,799 --> 00:02:06,719
сделать прогноз о  следующий токен

62
00:02:06,719 --> 00:02:08,720
здесь мы предсказали темный,

63
00:02:08,720 --> 00:02:10,800
и мы получаем наш сигнал ошибки, сравнивая

64
00:02:10,800 --> 00:02:12,720
этот прогноз с фактическим токеном,

65
00:02:12,720 --> 00:02:14,319
который появился в наших обучающих данных, в

66
00:02:14,319 --> 00:02:16,319
этом случае это было слово свет, поэтому, поскольку

67
00:02:16,319 --> 00:02:17,520
мы сделали неправильный прогноз, мы

68
00:02:17,520 --> 00:02:18,480
собираемся  чтобы

69
00:02:18,480 --> 00:02:20,480
получить существенный сигнал ошибки, который

70
00:02:20,480 --> 00:02:21,920
затем, как мы надеемся, обновит параметры веса

71
00:02:21,920 --> 00:02:23,760
во всей этой модели таким

72
00:02:23,760 --> 00:02:25,200
образом, чтобы в следующий раз они производили лучшие

73
00:02:25,200 --> 00:02:27,520
поколения,

74
00:02:27,520 --> 00:02:29,040
чуть более подробно, просто как

75
00:02:29,040 --> 00:02:30,800
напоминание, чтобы у нас действительно было вложение для

76
00:02:30,800 --> 00:02:33,519
этого стартового токена  для всех

77
00:02:33,519 --> 00:02:35,680
токенов скрытое состояние получается из

78
00:02:35,680 --> 00:02:38,319
встраивания через преобразование веса

79
00:02:38,319 --> 00:02:40,160
и цветовое представление, которое является

80
00:02:40,160 --> 00:02:42,400
состоянием h0 и повторением, которое мы

81
00:02:42,400 --> 00:02:43,840
строим, и t

82
00:02:43,840 --> 00:02:45,599
к нему также применено преобразование для прохождения

83
00:02:45,599 --> 00:02:47,200
через скрытый слой,

84
00:02:47,200 --> 00:02:49,120
который дает нам состояние h1, а затем у

85
00:02:49,120 --> 00:02:51,519
нас есть параметры softmax поверх этого

86
00:02:51,519 --> 00:02:53,440
h1, которые делают прогноз.

87
00:02:53,440 --> 00:02:55,280
Прогноз, который они делают, является

88
00:02:55,280 --> 00:02:58,000
прогнозом по всему словарю

89
00:02:58,000 --> 00:03:00,000
и  вероятность фактического маркера

90
00:03:00,000 --> 00:03:01,360
дает нам наш сигнал ошибки, поэтому

91
00:03:01,360 --> 00:03:03,120
вероятность света является сигналом ошибки,

92
00:03:03,120 --> 00:03:05,120
который мы будем использовать здесь для обновления параметров модели,

93
00:03:05,120 --> 00:03:07,360


94
00:03:07,360 --> 00:03:09,040
а затем мы начнем со следующего временного

95
00:03:09,040 --> 00:03:11,280
шага, который я назвал этим учителем,

96
00:03:11,280 --> 00:03:12,879
потому что в стандарте  режим, который

97
00:03:12,879 --> 00:03:14,640
является принудительным режимом учителя, даже несмотря на то, что мы

98
00:03:14,640 --> 00:03:17,599
предсказали темноту на первом временном шаге, у

99
00:03:17,599 --> 00:03:19,440
нас будет второй токен,

100
00:03:19,440 --> 00:03:21,440
поиск маркера света,

101
00:03:21,440 --> 00:03:22,879
который является фактическим токеном в

102
00:03:22,879 --> 00:03:24,720
базовых данных обучения, когда мы действуем так,

103
00:03:24,720 --> 00:03:26,480
как если бы мы не  сделать ошибку, поэтому

104
00:03:26,480 --> 00:03:28,560
снова мы выполняем поиск внедрения, мы получаем

105
00:03:28,560 --> 00:03:30,560
наше второе скрытое состояние для декодера

106
00:03:30,560 --> 00:03:33,200
как комбинацию внедрения x37

107
00:03:33,200 --> 00:03:35,040
и предыдущего скрытого состояния, и мы

108
00:03:35,040 --> 00:03:36,720
делаем еще один прогноз, и я  в этом случае

109
00:03:36,720 --> 00:03:38,080
наш прогноз синий, и это

110
00:03:38,080 --> 00:03:40,239
фактический токен, и жизнь немного хороша,

111
00:03:40,239 --> 00:03:41,920
а затем мы переходим к

112
00:03:41,920 --> 00:03:43,280
третьему временному шагу,

113
00:03:43,280 --> 00:03:45,360
фактический токен синий

114
00:03:45,360 --> 00:03:46,560
h3,

115
00:03:46,560 --> 00:03:48,879
и мы предсказываем зеленый, и в этом случае мы

116
00:03:48,879 --> 00:03:50,480
должны были предсказать стоп-токен.  что

117
00:03:50,480 --> 00:03:52,080
заставит нас прекратить обработку

118
00:03:52,080 --> 00:03:53,680
последовательности, мы просто получим

119
00:03:53,680 --> 00:03:55,599
сигнал об ошибке, как обычно, и

120
00:03:55,599 --> 00:03:57,040
распространим его обратно по

121
00:03:57,040 --> 00:03:59,200
модели в надежде, что в следующий раз, когда

122
00:03:59,200 --> 00:04:00,879
мы захотим остановиться, мы действительно создадим

123
00:04:00,879 --> 00:04:04,640
этот токен остановки  что я отказался здесь

124
00:04:05,040 --> 00:04:06,400
во время прогнозирования, конечно,

125
00:04:06,400 --> 00:04:08,480
последовательность не задана, что не

126
00:04:08,480 --> 00:04:10,640
меняет кодировщик, потому что

127
00:04:10,640 --> 00:04:12,159
представление цвета является частью входных данных модели,

128
00:04:12,159 --> 00:04:13,599
но тогда мы должны декодировать и

129
00:04:13,599 --> 00:04:16,639
просто описать без какой-либо обратной связи, поэтому мы

130
00:04:16,639 --> 00:04:18,478
действуем как  мы делали раньше, и мы предсказываем

131
00:04:18,478 --> 00:04:21,040
темноту здесь, а затем темнота должна

132
00:04:21,040 --> 00:04:22,720
стать токеном на следующем временном шаге, потому что

133
00:04:22,720 --> 00:04:24,400
мы не знаем, что такое основная истина,

134
00:04:24,400 --> 00:04:27,120
и мы продолжаем, как раньше, и говорим синий,

135
00:04:27,120 --> 00:04:28,800
и тогда это становится в третий раз

136
00:04:28,800 --> 00:04:30,960
шаг, и, если повезет, в этой третьей

137
00:04:30,960 --> 00:04:33,440
позиции мы предсказываем токен остановки, и

138
00:04:33,440 --> 00:04:36,639
процесс декодирования завершен,

139
00:04:36,639 --> 00:04:38,560
что является фундаментальной моделью,

140
00:04:38,560 --> 00:04:40,000
хотя она проста, она допускает

141
00:04:40,000 --> 00:04:42,080
множество интересных модификаций, позвольте

142
00:04:42,080 --> 00:04:43,919
мне сначала упомянуть некоторые из них:

143
00:04:43,919 --> 00:04:45,680
кодировщик и декодер

144
00:04:45,680 --> 00:04:46,960
Конечно, может быть гораздо больше скрытых

145
00:04:46,960 --> 00:04:49,040
слоев, у меня только что был один, но они могут

146
00:04:49,040 --> 00:04:51,680
быть очень глубокими сетями, мы ожидаем,

147
00:04:51,680 --> 00:04:53,600
что слой учитывается для кодировщика

148
00:04:53,600 --> 00:04:55,040
и декодера и совпадает, так что у вас

149
00:04:55,040 --> 00:04:57,120
есть эта равномерная передача от кодировщика к

150
00:04:57,120 --> 00:04:59,600
декодеру по всем скрытым слоям, но

151
00:04:59,600 --> 00:05:01,280
даже это не является жестким ограничением, я могу

152
00:05:01,280 --> 00:05:03,360
себе представить, что некоторое охлаждение или копирование

153
00:05:03,360 --> 00:05:04,960
могут вместить разное количество

154
00:05:04,960 --> 00:05:08,240
слоев в этих двух компонентах.

155
00:05:08,240 --> 00:05:09,840
В настоящее время

156
00:05:09,840 --> 00:05:11,759
исследователи очень часто связывают параметры встраивания и

157
00:05:11,759 --> 00:05:13,360
классификатора правильно,

158
00:05:13,360 --> 00:05:14,960
встраивание дает нам представление для

159
00:05:14,960 --> 00:05:17,360
каждого элемента словаря и

160
00:05:17,360 --> 00:05:19,120
транспонирование этого может служить набором

161
00:05:19,120 --> 00:05:22,560
параметров для нашего классификатора softmax,

162
00:05:22,560 --> 00:05:24,479
когда мы предсказываем

163
00:05:24,479 --> 00:05:26,400
токены  И связывание этих весов кажется очень

164
00:05:26,400 --> 00:05:28,160
продуктивным с точки зрения эффективности оптимизации,

165
00:05:28,160 --> 00:05:31,199
поэтому вы можете подумать об этом,

166
00:05:31,199 --> 00:05:33,120
и, наконец, во время обучения мы можем

167
00:05:33,120 --> 00:05:35,039
отказаться от этого предположения, навязываемого учителем,

168
00:05:35,039 --> 00:05:36,720
что будет означать, что в небольшом

169
00:05:36,720 --> 00:05:38,639
проценте случаев мы позволим

170
00:05:38,639 --> 00:05:40,720
модели просто действовать так, как если бы  его

171
00:05:40,720 --> 00:05:42,720
предсказанный токен был правильным токеном

172
00:05:42,720 --> 00:05:44,880
для следующего временного шага, даже если это

173
00:05:44,880 --> 00:05:47,280
было ошибочным предположением, очевидным из идеи,

174
00:05:47,280 --> 00:05:49,440
что это может помочь модели исследовать более

175
00:05:49,440 --> 00:05:52,160
широкий диапазон пространства и привнести в свои

176
00:05:52,160 --> 00:05:53,919
гм-поколения некоторое полезное

177
00:05:53,919 --> 00:05:55,520
разнообразие,

178
00:05:55,520 --> 00:05:56,880
а затем есть еще одно  модификация,

179
00:05:56,880 --> 00:05:57,919
которую я хочу упомянуть, потому что вы

180
00:05:57,919 --> 00:05:59,440
увидите это как часть домашней работы и

181
00:05:59,440 --> 00:06:01,120
системы, которую вы разрабатываете, поэтому мы

182
00:06:01,120 --> 00:06:04,160
обнаружили, что в monroidal 2016 было

183
00:06:04,160 --> 00:06:06,240
полезно напоминать декодеру на

184
00:06:06,240 --> 00:06:08,400
каждом из его временных шагов о том, что

185
00:06:08,400 --> 00:06:10,880
он пытался описать более подробно,

186
00:06:10,880 --> 00:06:13,280
у нас были цветовые представления hsv в качестве

187
00:06:13,280 --> 00:06:15,280
входных данных, мы сделали преобразование Фурье, чтобы получить

188
00:06:15,280 --> 00:06:17,600
вложение, и это было обработано int

189
00:06:17,600 --> 00:06:20,080
o скрытое состояние, а затем во время декодирования

190
00:06:20,080 --> 00:06:21,600
мы добавили к каждому из

191
00:06:21,600 --> 00:06:24,160
вложений представление преобразования

192
00:06:24,160 --> 00:06:26,000
Фурье цвета в качестве своего рода

193
00:06:26,000 --> 00:06:28,560
неформального напоминания на каждом временном шаге

194
00:06:28,560 --> 00:06:30,400
о том, как на самом деле выглядел вход,

195
00:06:30,400 --> 00:06:31,680
исходя из предположения, что для длинных

196
00:06:31,680 --> 00:06:33,360
последовательностей, когда мы получаем все  вплоть

197
00:06:33,360 --> 00:06:35,600
до конца у модели могут быть смутные

198
00:06:35,600 --> 00:06:37,600
воспоминания о том, что она пытается описать,

199
00:06:37,600 --> 00:06:39,840
и это действует как своего рода напоминание

200
00:06:39,840 --> 00:06:40,960
в этот момент,

201
00:06:40,960 --> 00:06:42,400
и это оказалось очень эффективным, и

202
00:06:42,400 --> 00:06:44,319
я рекомендую вам изучить это

203
00:06:44,319 --> 00:06:46,240
в домашнем задании

204
00:06:46,240 --> 00:06:47,440
и  затем, я надеюсь, вы видите, что,

205
00:06:47,440 --> 00:06:49,440
хотя эта формулировка задачи проста

206
00:06:49,440 --> 00:06:51,680
, это пример широкого круга

207
00:06:51,680 --> 00:06:53,199
задач, которые мы могли бы исследовать под

208
00:06:53,199 --> 00:06:54,960
заголовком заземления, в конце концов, для

209
00:06:54,960 --> 00:06:56,560
заземления в этом смысле нам просто нужно

210
00:06:56,560 --> 00:06:58,400
какое-то неязыковое представление.

211
00:06:58,400 --> 00:07:00,080
идеи, которые будут

212
00:07:00,080 --> 00:07:02,160
генерировать язык в ответ на этот

213
00:07:02,160 --> 00:07:03,039
ввод,

214
00:07:03,039 --> 00:07:04,800
поэтому захват изображения является примером

215
00:07:04,800 --> 00:07:05,680
этой

216
00:07:05,680 --> 00:07:07,440
сцены, описание, конечно, является еще одним

217
00:07:07,440 --> 00:07:09,759
примером визуального ответа на вопрос.  ing — это

218
00:07:09,759 --> 00:07:11,360
небольшая модификация, в которой входными данными является

219
00:07:11,360 --> 00:07:13,759
не только изображение, но и текст вопроса,

220
00:07:13,759 --> 00:07:15,120
и идея состоит в том, что вы хотите

221
00:07:15,120 --> 00:07:17,039
получить ответ на этот вопрос

222
00:07:17,039 --> 00:07:19,360
относительно входного изображения,

223
00:07:19,360 --> 00:07:20,800
а затем предоставление инструкции будет

224
00:07:20,800 --> 00:07:22,479
более общей формой, где ввод  является

225
00:07:22,479 --> 00:07:24,400
своего рода описанием состояния, и

226
00:07:24,400 --> 00:07:25,599
идея состоит в том, что мы хотим предложить

227
00:07:25,599 --> 00:07:27,919
сложную инструкцию на этой основе,

228
00:07:27,919 --> 00:07:29,759
и я думаю, что мы можем придумать множество других

229
00:07:29,759 --> 00:07:31,440
, которые впишутся в эту форму и

230
00:07:31,440 --> 00:07:33,120
выиграют не только от архитектуры кодер-

231
00:07:33,120 --> 00:07:34,919
декодер, но и от

232
00:07:34,919 --> 00:07:37,280
явной концептуализации.

233
00:07:37,280 --> 00:07:39,280
как обоснованные задачи генерации естественного языка,

234
00:07:39,280 --> 00:07:42,280
которые

235
00:07:44,720 --> 00:07:46,800
вы

