1
00:00:05,279 --> 00:00:07,520
Итак, теперь я хочу перейти к вопросу о

2
00:00:07,520 --> 00:00:10,000
том, как точно сформулировать нашу проблему прогнозирования.

3
00:00:10,000 --> 00:00:12,320


4
00:00:12,320 --> 00:00:13,840
Я хочу быть точным в отношении того, как мы

5
00:00:13,840 --> 00:00:16,720
определяем входные и выходные данные наших

6
00:00:16,720 --> 00:00:17,920
прогнозов,

7
00:00:17,920 --> 00:00:19,760
и это, в свою очередь, будет иметь

8
00:00:19,760 --> 00:00:22,720
последствия для того, как мы присоединяемся к корпусу.

9
00:00:22,720 --> 00:00:24,080
и kb,

10
00:00:24,080 --> 00:00:26,880
как мы создаем отрицательные примеры

11
00:00:26,880 --> 00:00:28,960
для наших алгоритмов обучения

12
00:00:28,960 --> 00:00:31,039
и как мы обрабатываем классификацию с несколькими метками,

13
00:00:31,039 --> 00:00:33,840


14
00:00:34,079 --> 00:00:36,480
поэтому, во-первых, что является входными данными для нашей

15
00:00:36,480 --> 00:00:38,239
проблемы прогнозирования

16
00:00:38,239 --> 00:00:40,719
в контролируемой парадигме обучения

17
00:00:40,719 --> 00:00:44,160
входными данными является пара упоминаний сущности

18
00:00:44,160 --> 00:00:46,960
в контексте определенного  предложение

19
00:00:46,960 --> 00:00:49,520
мы пытаемся пометить предложение так же,

20
00:00:49,520 --> 00:00:52,239
как мы делаем это при маркировке частей речи или

21
00:00:52,239 --> 00:00:54,960
анализе настроений,

22
00:00:54,960 --> 00:00:57,440
но в парадигме дистанционного наблюдения

23
00:00:57,440 --> 00:00:59,440
мы будем делать вещи по-другому,

24
00:00:59,440 --> 00:01:02,160
вход будет парой сущностей,

25
00:01:02,160 --> 00:01:03,680
точка,

26
00:01:03,680 --> 00:01:07,119
независимая от какого-либо конкретного контекста, который

27
00:01:07,119 --> 00:01:08,640
мы  мы пытаемся определить связь

28
00:01:08,640 --> 00:01:11,760
между этим объектом и этим объектом,

29
00:01:11,760 --> 00:01:14,479
и

30
00:01:14,479 --> 00:01:16,080
это еще один вопрос, на который я хочу обратить внимание:

31
00:01:16,080 --> 00:01:17,840
каков результат задачи прогнозирования?

32
00:01:17,840 --> 00:01:20,400
пытаемся

33
00:01:20,400 --> 00:01:24,320
присвоить пару сущностей одному отношению,

34
00:01:24,320 --> 00:01:27,280
которое называется многоклассовой классификацией,

35
00:01:27,280 --> 00:01:28,960
или мы пытаемся назначить пару

36
00:01:28,960 --> 00:01:31,439
сущностей нескольким отношениям, которое

37
00:01:31,439 --> 00:01:34,000
называется многоуровневой классификацией, и

38
00:01:34,000 --> 00:01:36,560
это другой зверь,

39
00:01:36,560 --> 00:01:38,079
поэтому в течение следующих нескольких слайдов я хочу

40
00:01:38,079 --> 00:01:40,640
Чтобы исследовать последствия этих

41
00:01:40,640 --> 00:01:41,759
выборов,

42
00:01:41,759 --> 00:01:43,280
разница между этими двумя

43
00:01:43,280 --> 00:01:45,200
способами мышления о входных данных становится

44
00:01:45,200 --> 00:01:47,920
действительно важной, когда мы говорим о том, как

45
00:01:47,920 --> 00:01:49,520
мы собираемся

46
00:01:49,520 --> 00:01:51,600
соединить корпус и базу

47
00:01:51,600 --> 00:01:53,119
знаний, чтобы использовать дистанционное

48
00:01:53,119 --> 00:01:54,640
наблюдение в парадигме, в которой мы нуждаемся.

49
00:01:54,640 --> 00:01:56,640
соедините эти два, которые нам нужны, чтобы связать

50
00:01:56,640 --> 00:01:58,560
информацию в корпусе с

51
00:01:58,560 --> 00:02:00,320
информацией в kb,

52
00:02:00,320 --> 00:02:02,000
и есть две разные возможности в

53
00:02:02,000 --> 00:02:03,600
зависимости от

54
00:02:03,600 --> 00:02:05,520
того, как мы формулируем проблему прогнозирования, в

55
00:02:05,520 --> 00:02:08,080
зависимости от того, как мы определяем входные данные

56
00:02:08,080 --> 00:02:09,598
для проблемы,

57
00:02:09,598 --> 00:02:12,480
если наша проблема состоит в том, чтобы классифицировать пару

58
00:02:12,480 --> 00:02:14,400
упоминаний сущности

59
00:02:14,400 --> 00:02:17,599
в конкретном примере в корпусе в

60
00:02:17,599 --> 00:02:19,840
конкретном

61
00:02:19,840 --> 00:02:22,879
предложении мы можем использовать kb для предоставления

62
00:02:22,879 --> 00:02:25,360
метки, и вот как это выглядит  например, у

63
00:02:25,360 --> 00:02:28,160
нас есть пример корпуса, подобный этому,

64
00:02:28,160 --> 00:02:30,720
мы пытаемся пометить этот конкретный

65
00:02:30,720 --> 00:02:32,000
пример,

66
00:02:32,000 --> 00:02:34,160
и для этого мы можем проверить

67
00:02:34,160 --> 00:02:38,160
, связаны ли эти два объекта в kb

68
00:02:38,160 --> 00:02:40,640
да, и мы можем использовать это для

69
00:02:40,640 --> 00:02:42,239
создания метки

70
00:02:42,239 --> 00:02:45,280
для этого примера

71
00:02:45,280 --> 00:02:48,480
маркировка конкретных примеров показывает, как работает

72
00:02:48,480 --> 00:02:51,120
полностью контролируемая парадигма,

73
00:02:51,120 --> 00:02:53,440
поэтому это очевидный способ подумать

74
00:02:53,440 --> 00:02:56,000
об использовании дистанционного контроля, который также

75
00:02:56,000 --> 00:02:57,680


76
00:02:57,680 --> 00:03:00,159
можно заставить работать, но на

77
00:03:00,159 --> 00:03:02,720
самом деле это не предпочтительный подход, если мы будем делать

78
00:03:02,720 --> 00:03:04,400
это таким образом, мы будем делать все

79
00:03:04,400 --> 00:03:06,720
точно так же, как  они выполняются в

80
00:03:06,720 --> 00:03:09,120
контролируемой парадигме,

81
00:03:09,120 --> 00:03:11,760
это работает, но это не лучший

82
00:03:11,760 --> 00:03:14,959
способ воспользоваться возможностью,

83
00:03:14,959 --> 00:03:18,159
которую создает дистанционное наблюдение,

84
00:03:18,159 --> 00:03:20,000
есть другой способ ведения дел,

85
00:03:20,000 --> 00:03:23,840
и вместо этого мы определяем

86
00:03:23,840 --> 00:03:25,120
нашу проблему

87
00:03:25,120 --> 00:03:28,400
как классификацию пары сущностей.  не

88
00:03:28,400 --> 00:03:30,480
сущность упоминается в конкретном предложении,

89
00:03:30,480 --> 00:03:34,319
а просто сущности Элон Маск и период Тесла

90
00:03:34,319 --> 00:03:35,360


91
00:03:35,360 --> 00:03:37,519
отдельно от любого предложения,

92
00:03:37,519 --> 00:03:40,000
и если именно так мы определяем входные данные для

93
00:03:40,000 --> 00:03:41,519
нашей проблемы,

94
00:03:41,519 --> 00:03:44,080
тогда мы можем использовать корпус  s,

95
00:03:44,080 --> 00:03:47,120
чтобы обеспечить представление функции,

96
00:03:47,120 --> 00:03:50,159
которое будет входом для прогноза,

97
00:03:50,159 --> 00:03:52,879
поэтому, если у нас есть пара сущностей, таких как elon

98
00:03:52,879 --> 00:03:54,799
musk и spacex,

99
00:03:54,799 --> 00:03:57,360
которую мы рассматриваем добавление к

100
00:03:57,360 --> 00:04:00,720
отношению в kb,

101
00:04:00,720 --> 00:04:04,080
мы можем найти все предложения в корпусе,

102
00:04:04,080 --> 00:04:07,120
содержащие эту пару  сущности,

103
00:04:07,120 --> 00:04:08,959
а затем мы можем использовать все эти

104
00:04:08,959 --> 00:04:11,200
предложения для создания представления функции

105
00:04:11,200 --> 00:04:14,720
для этой пары, поэтому в этом

106
00:04:14,720 --> 00:04:16,959
примере я представляю, что это не

107
00:04:16,959 --> 00:04:18,399
обязательно должно быть так, но я представляю,

108
00:04:18,399 --> 00:04:20,720
что мы используем простой  пакет слов

109
00:04:20,720 --> 00:04:23,040


110
00:04:23,040 --> 00:04:25,199
представляет набор слов пакет слов пришел из

111
00:04:25,199 --> 00:04:28,160
середины, это фраза между

112
00:04:28,160 --> 00:04:30,240
двумя измерениями сущности синие фразы

113
00:04:30,240 --> 00:04:31,360
здесь,

114
00:04:31,360 --> 00:04:33,440
и все, что я сделал, это подсчитал

115
00:04:33,440 --> 00:04:34,400
слова

116
00:04:34,400 --> 00:04:37,199
во всех этих синих фразах

117
00:04:37,199 --> 00:04:38,639
во

118
00:04:38,639 --> 00:04:41,360
всех примерах в  корпус, в котором

119
00:04:41,360 --> 00:04:43,520
эти две сущности встречаются вместе,

120
00:04:43,520 --> 00:04:45,120


121
00:04:45,120 --> 00:04:47,440
и

122
00:04:48,240 --> 00:04:51,280
да, вы можете видеть здесь,

123
00:04:51,280 --> 00:04:54,320
в подсчете токенов, что они включают

124
00:04:54,320 --> 00:04:58,160
токены из различных примеров,

125
00:04:58,160 --> 00:05:00,960
все эти примеры вместе используются

126
00:05:00,960 --> 00:05:02,800
для создания единого представления функции.

127
00:05:02,800 --> 00:05:04,880
n это представление функции

128
00:05:04,880 --> 00:05:08,479
для этой пары,

129
00:05:08,479 --> 00:05:11,039
и именно это представление

130
00:05:11,039 --> 00:05:13,440
функции будет использовать моя

131
00:05:13,440 --> 00:05:16,080
изученная модель, чтобы сделать

132
00:05:16,080 --> 00:05:19,280
прогноз об этой паре,

133
00:05:19,280 --> 00:05:20,880
так что это очень интересный способ

134
00:05:20,880 --> 00:05:25,120
обратить вещи вместо использования kb

135
00:05:25,120 --> 00:05:28,160
для создания метки  чтобы сделать прогноз

136
00:05:28,160 --> 00:05:30,160
о конкретной

137
00:05:30,160 --> 00:05:32,720
паре сущностей, упоминаемых в конкретном

138
00:05:32,720 --> 00:05:35,520
предложении, я переворачиваю вещи, я

139
00:05:35,520 --> 00:05:37,039
использую корпус

140
00:05:37,039 --> 00:05:39,440
для создания представления функций,

141
00:05:39,440 --> 00:05:42,160
которое я буду использовать, чтобы сделать прогноз

142
00:05:42,160 --> 00:05:44,560
о паре сущностей

143
00:05:44,560 --> 00:05:46,000
в

144
00:05:46,000 --> 00:05:49,039
абстракции пара сущностей  рассматривается просто как

145
00:05:49,039 --> 00:05:50,479
пара сущностей,

146
00:05:50,479 --> 00:05:53,199
просто еще одна мысль по этому

147
00:05:53,199 --> 00:05:55,120
поводу, это все еще что-то вроде темы

148
00:05:55,120 --> 00:05:57,360
объединения корпуса и базы данных, мы

149
00:05:57,360 --> 00:05:59,759
создали класс набора данных, который делает то,

150
00:05:59,759 --> 00:06:02,880
что объединяет корпус и базу

151
00:06:02,880 --> 00:06:05,120
знаний, это просто  вроде скрепляет их вместе

152
00:06:05,120 --> 00:06:07,520
и предоставляет множество удобных

153
00:06:07,520 --> 00:06:09,680
методов для набора данных, и один из

154
00:06:09,680 --> 00:06:11,520
этих удобных методов - это один

155
00:06:11,520 --> 00:06:13,039
пример подсчета,

156
00:06:13,039 --> 00:06:15,680
который показывает для каждого отношения,

157
00:06:15,680 --> 00:06:18,000
сколько примеров  у нас есть в корпусе,

158
00:06:18,000 --> 00:06:20,639
сколько троек у нас есть в kb,

159
00:06:20,639 --> 00:06:24,800
и отношение um, поэтому

160
00:06:24,800 --> 00:06:27,360
общее количество примеров среднее

161
00:06:27,360 --> 00:06:30,080
количество примеров на тройку

162
00:06:30,080 --> 00:06:32,319
для большинства отношений общее количество

163
00:06:32,319 --> 00:06:34,479
примеров довольно велико,

164
00:06:34,479 --> 00:06:37,120
поэтому мы можем с оптимизмом изучать,

165
00:06:37,120 --> 00:06:39,680
какие лингвистические  шаблоны выражают

166
00:06:39,680 --> 00:06:42,000
заданное отношение, я имею в виду, что даже самый маленький из

167
00:06:42,000 --> 00:06:45,199
них имеет не менее 1500

168
00:06:45,199 --> 00:06:46,720
примеров,

169
00:06:46,720 --> 00:06:49,039
которые на самом деле не являются данными промышленного

170
00:06:49,039 --> 00:06:50,000
уровня,

171
00:06:50,000 --> 00:06:50,960


172
00:06:50,960 --> 00:06:53,919
но этого, безусловно, достаточно для

173
00:06:53,919 --> 00:06:55,280
исследования, которое мы здесь проводим,

174
00:06:55,280 --> 00:06:56,400


175
00:06:56,400 --> 00:06:59,280
однако для отдельных пар

176
00:06:59,280 --> 00:07:01,680
объектов число примеров равно  часто довольно низкие, поэтому

177
00:07:01,680 --> 00:07:03,919
некоторые из этих соотношений находятся между некоторыми

178
00:07:03,919 --> 00:07:05,759
из тех, некоторые из этих соотношений находятся

179
00:07:05,759 --> 00:07:06,800
между

180
00:07:06,800 --> 00:07:09,039
одним и двумя,

181
00:07:09,039 --> 00:07:10,240
конечно,

182
00:07:10,240 --> 00:07:12,160
больше данных было бы лучше

183
00:07:12,160 --> 00:07:13,440
намного лучше,

184
00:07:13,440 --> 00:07:14,400
но

185
00:07:14,400 --> 00:07:16,960
больше данных может быстро стать громоздким

186
00:07:16,960 --> 00:07:18,960
для работы с такой записной книжкой,

187
00:07:18,960 --> 00:07:20,400
особенно если вы'  работает на

188
00:07:20,400 --> 00:07:22,639
обычном ноутбуке,

189
00:07:22,639 --> 00:07:24,639
и этих данных будет достаточно,

190
00:07:24,639 --> 00:07:26,560
чтобы мы могли сначала провести плодотворное

191
00:07:26,560 --> 00:07:29,280
расследование.

192
00:07:29,440 --> 00:07:30,880
Я хочу поговорить об отрицательном

193
00:07:30,880 --> 00:07:33,680
примере.  Таким образом, присоединив корпус к

194
00:07:33,680 --> 00:07:37,759
kb, мы можем получить множество положительных

195
00:07:37,759 --> 00:07:40,880
примеров для каждого отношения, но мы не можем

196
00:07:40,880 --> 00:07:44,720
обучить классификатор только на положительных примерах,

197
00:07:44,720 --> 00:07:46,400
нам также понадобятся отрицательные

198
00:07:46,400 --> 00:07:48,720
примеры отрицательных экземпляров,

199
00:07:48,720 --> 00:07:51,120
так что это пары сущностей, которые  не

200
00:07:51,120 --> 00:07:53,919
принадлежат никакому отношению,

201
00:07:53,919 --> 00:07:56,560
мы можем найти такие пары, выполнив поиск в

202
00:07:56,560 --> 00:07:59,199
корпусе примеров, которые содержат

203
00:07:59,199 --> 00:08:01,360
две сущности, которые не принадлежат никакому

204
00:08:01,360 --> 00:08:03,680
отношению в kb,

205
00:08:03,680 --> 00:08:05,680
поэтому мы написали некоторый код для этого, и

206
00:08:05,680 --> 00:08:07,039


207
00:08:07,039 --> 00:08:09,039
в классе набора данных есть метод  называется

208
00:08:09,039 --> 00:08:11,840
find unrelated,

209
00:08:11,840 --> 00:08:13,759
и когда мы запустили его,

210
00:08:13,759 --> 00:08:17,440
ничего себе, он нашел почти 250 000

211
00:08:17,440 --> 00:08:19,120
несвязанных пар,

212
00:08:19,120 --> 00:08:20,800
хм,

213
00:08:20,800 --> 00:08:25,599
итак, 250 000 отрицательных экземпляров для нашей э-э,

214
00:08:25,599 --> 00:08:27,759
для нашей задачи прогнозирования, и это

215
00:08:27,759 --> 00:08:30,000
намного больше, чем количество положительных

216
00:08:30,000 --> 00:08:33,440
экземпляров, если вы помните, что kb имеет 46

217
00:08:33,440 --> 00:08:35,279
000 троек

218
00:08:35,279 --> 00:08:37,919
каждый из  это в основном положительный

219
00:08:37,919 --> 00:08:41,279
пример это то, что мы знаем,

220
00:08:41,279 --> 00:08:43,120
определенно положительный пример

221
00:08:43,120 --> 00:08:44,320
отношения

222
00:08:44,320 --> 00:08:47,600
здесь у нас есть 250 000 отрицательных примеров

223
00:08:47,600 --> 00:08:50,160
это так много, что когда мы обучаем

224
00:08:50,160 --> 00:08:51,279
модели,

225
00:08:51,279 --> 00:08:53,600
мы закончим d  собственная выборка отрицательных

226
00:08:53,600 --> 00:08:55,760
экземпляров в значительной степени, чтобы у нас

227
00:08:55,760 --> 00:08:59,839
было несколько более сбалансированное распределение,

228
00:09:00,399 --> 00:09:02,720
напоминание, хотя

229
00:09:02,720 --> 00:09:05,680
некоторые из этих предположительно отрицательных

230
00:09:05,680 --> 00:09:07,440
экземпляров

231
00:09:07,440 --> 00:09:08,399
могут быть

232
00:09:08,399 --> 00:09:10,080
ложноотрицательными,

233
00:09:10,080 --> 00:09:11,440
они могут быть

234
00:09:11,440 --> 00:09:14,000
парами сущностей, которые не кажутся

235
00:09:14,000 --> 00:09:15,120
связанными,

236
00:09:15,120 --> 00:09:18,320
но в реальном мире на самом деле являются

237
00:09:18,320 --> 00:09:21,279
нашими kb  не является полной, пара

238
00:09:21,279 --> 00:09:23,920
сущностей может быть связана в реальной жизни,

239
00:09:23,920 --> 00:09:26,160
даже если они не появляются вместе в

240
00:09:26,160 --> 00:09:28,880
kb, и, как я уже сказал ранее, в конце концов

241
00:09:28,880 --> 00:09:30,640
, в этом вся суть, что вся

242
00:09:30,640 --> 00:09:33,360
причина, по которой мы делаем извлечение отношений,

243
00:09:33,360 --> 00:09:35,839
состоит в том, чтобы найти вещи, которые  верны в реальной

244
00:09:35,839 --> 00:09:36,880
жизни

245
00:09:36,880 --> 00:09:39,120
и верны в соответствии с каким-то текстом, который

246
00:09:39,120 --> 00:09:43,920
кто-то написал, но еще не находится в нашей базе знаний,

247
00:09:44,959 --> 00:09:47,040
хорошо, теперь я собираюсь перейти

248
00:09:47,040 --> 00:09:50,240
к вопросу, который был задан о

249
00:09:50,240 --> 00:09:53,440
парах, которые принадлежат множественным отношениям,

250
00:09:53,440 --> 00:09:55,839
и это  это связано с

251
00:09:55,839 --> 00:09:57,839
вопросом о результатах нашей

252
00:09:57,839 --> 00:09:59,920
задачи прогнозирования,

253
00:09:59,920 --> 00:10:03,360
мы написали некоторый код для проверки kb

254
00:10:03,360 --> 00:10:05,680
на наличие пар сущностей, которые принадлежат более

255
00:10:05,680 --> 00:10:07,920
чем одному отношению, так что этот метод

256
00:10:07,920 --> 00:10:10,560
подсчитывает отношение combina

257
00:10:10,560 --> 00:10:12,959
и оказывается это очень распространенное

258
00:10:12,959 --> 00:10:15,279
явление в кб есть много

259
00:10:15,279 --> 00:10:18,560
пар которые принадлежат множественным отношениям

260
00:10:18,560 --> 00:10:20,880
например я даже не буду

261
00:10:20,880 --> 00:10:22,800
упоминать самую распространенную но

262
00:10:22,800 --> 00:10:26,160
в кб 143 человека

263
00:10:26,160 --> 00:10:28,160
эээ чье место

264
00:10:28,160 --> 00:10:31,040
Место рождения совпадает с местом их смерти,

265
00:10:31,040 --> 00:10:33,360
и на самом деле это не то удивительное

266
00:10:33,360 --> 00:10:35,760
право, которое имеет смысл,

267
00:10:35,760 --> 00:10:37,760
хм, даже оказывается, что есть не

268
00:10:37,760 --> 00:10:40,079
менее семи человек,

269
00:10:40,079 --> 00:10:43,120
которые удачно вышли замуж за брата или сестру,

270
00:10:43,120 --> 00:10:46,240
поскольку многие пары сущностей

271
00:10:46,240 --> 00:10:48,880
принадлежат более чем к одному родству, которое

272
00:10:48,880 --> 00:10:51,519
мы, вероятно,  не хотим, чтобы нас заставляли

273
00:10:51,519 --> 00:10:54,000
предсказывать одно отношение,

274
00:10:54,000 --> 00:10:56,399
поэтому это предлагает сформулировать нашу проблему

275
00:10:56,399 --> 00:10:59,760
как классификацию с несколькими метками, мы хотим, чтобы

276
00:10:59,760 --> 00:11:01,600
наши модели могли предсказывать

277
00:11:01,600 --> 00:11:05,200
несколько отношений для любой заданной пары сущностей,

278
00:11:05,200 --> 00:11:07,519


279
00:11:08,320 --> 00:11:09,760
есть несколько способов подойти к

280
00:11:09,760 --> 00:11:12,399
многозначной классификации.  классификация, но наиболее

281
00:11:12,399 --> 00:11:15,360
очевидным является метод бинарной релевантности,

282
00:11:15,360 --> 00:11:18,320
который просто делит

283
00:11:18,320 --> 00:11:19,680
классификацию

284
00:11:19,680 --> 00:11:23,600
с несколькими метками по n меткам на n независимых

285
00:11:23,600 --> 00:11:26,079
задач бинарной классификации, по одной для каждой

286
00:11:26,079 --> 00:11:28,000
метки s.  o если у вас есть пара, такая как

287
00:11:28,000 --> 00:11:30,959
pericles и athens, вы хотите иметь

288
00:11:30,959 --> 00:11:33,200
возможность предсказывать любую комбинацию этих

289
00:11:33,200 --> 00:11:34,240
меток,

290
00:11:34,240 --> 00:11:36,800
вы просто обучаете отдельную модель,

291
00:11:36,800 --> 00:11:39,120
отдельный двоичный классификатор

292
00:11:39,120 --> 00:11:42,560
для каждой из меток независимо

293
00:11:42,560 --> 00:11:44,800
друг от друга, каждый из них генерирует прогноз

294
00:11:44,800 --> 00:11:46,240
независимо,

295
00:11:46,240 --> 00:11:48,959
и в этом примере мы  предсказал,

296
00:11:48,959 --> 00:11:50,880
что применяется отношение места рождения,

297
00:11:50,880 --> 00:11:53,360
применяется отношение места смерти, но не

298
00:11:53,360 --> 00:11:57,200
отношение имеет родных братьев и сестер.

299
00:11:57,200 --> 00:11:58,800
Недостаток этого подхода заключается в том, что

300
00:11:58,800 --> 00:12:00,800
он не работает,

301
00:12:00,800 --> 00:12:02,000
потому что он рассматривает проблемы бинарной

302
00:12:02,000 --> 00:12:04,079
классификации как независимые,

303
00:12:04,079 --> 00:12:06,959
он не может использовать корреляции между

304
00:12:06,959 --> 00:12:08,160
метками,

305
00:12:08,160 --> 00:12:10,160
например  вполне может быть

306
00:12:10,160 --> 00:12:12,160
корреляция между местом смерти,

307
00:12:12,160 --> 00:12:13,760
меткой места рождения и меткой места

308
00:12:13,760 --> 00:12:14,959
смерти,

309
00:12:14,959 --> 00:12:17,519
и если у вас уже есть доказательства того,

310
00:12:17,519 --> 00:12:20,720
что метка места рождения применяется,

311
00:12:20,720 --> 00:12:23,200
это может хотя бы немного склонить вас

312
00:12:23,200 --> 00:12:27,680
к тому, чтобы сказать «да» в отношении места смерти.

313
00:12:27,680 --> 00:12:30,160
этот подход разложения их на

314
00:12:30,160 --> 00:12:32,720
независимые

315
00:12:32,720 --> 00:12:35,200
проблемы бинарной классификации не может использовать в своих

316
00:12:35,200 --> 00:12:39,360
интересах эту информацию

317
00:12:39,360 --> 00:12:41,120
но у него большое достоинство

318
00:12:41,120 --> 00:12:42,959
простоты, он невероятно

319
00:12:42,959 --> 00:12:44,880
прост, невероятно прост в

320
00:12:44,880 --> 00:12:46,880
обдумывании и реализации,

321
00:12:46,880 --> 00:12:47,760
и

322
00:12:47,760 --> 00:12:50,320
этого будет достаточно для наших целей.

323
00:12:50,320 --> 00:12:52,639


324
00:12:52,639 --> 00:12:56,240


325
00:12:56,240 --> 00:12:57,120


326
00:12:57,120 --> 00:12:59,680
поставили перед собой цель

327
00:12:59,680 --> 00:13:01,680


328
00:13:01,680 --> 00:13:05,040
установить точную формулировку нашей

329
00:13:05,040 --> 00:13:06,399
задачи прогнозирования,

330
00:13:06,399 --> 00:13:08,720
и когда мы соберем все части вместе,

331
00:13:08,720 --> 00:13:10,160
вот формулировка проблемы, к которой мы

332
00:13:10,160 --> 00:13:13,120
пришли, входными данными для прогнозирования

333
00:13:13,120 --> 00:13:14,079


334
00:13:14,079 --> 00:13:15,760
будут пара сущностей

335
00:13:15,760 --> 00:13:18,959
и отношение-кандидат,

336
00:13:18,959 --> 00:13:21,760
выход будет логическим,

337
00:13:21,760 --> 00:13:23,519
указывающим, является ли  пара сущностей

338
00:13:23,519 --> 00:13:26,720
принадлежит отношению,

339
00:13:26,800 --> 00:13:29,200
поскольку тройка kb является в точности

340
00:13:29,200 --> 00:13:31,680
отношением и парой сущностей, мы могли

341
00:13:31,680 --> 00:13:33,600
бы эквивалентно сказать, что наша

342
00:13:33,600 --> 00:13:35,279
проблема прогнозирования сводится к

343
00:13:35,279 --> 00:13:38,399
бинарной классификации троек kb при

344
00:13:38,399 --> 00:13:40,560
заданной тройке kb-кандидатов, подобной работе

345
00:13:40,560 --> 00:13:43,760
Илона Маска Spacex, предсказываем ли мы, что

346
00:13:43,760 --> 00:13:45,440


347
00:13:45,440 --> 00:13:46,880
это действительно хорошо, потому что это очень

348
00:13:46,880 --> 00:13:49,600
простой способ думать о

349
00:13:49,600 --> 00:13:52,720
том, какую проблему мы берем на себя, у нас есть

350
00:13:52,720 --> 00:13:54,880
куча позиций  Примеры

351
00:13:54,880 --> 00:13:56,560
из нашей базы знаний

352
00:13:56,560 --> 00:13:58,720
у нас есть множество отрицательных примеров,

353
00:13:58,720 --> 00:14:02,000
которые мы синтезируем из корпуса,

354
00:14:02,000 --> 00:14:04,399
используя пары, которые встречаются в корпусе,

355
00:14:04,399 --> 00:14:06,720
но не встречаются в базе знаний.

356
00:14:06,720 --> 00:14:08,880
Теперь у нас есть много данных,

357
00:14:08,880 --> 00:14:12,160
состоящих из троек-кандидатов,

358
00:14:12,160 --> 00:14:14,480
включая положительные  примеры и отрицательные

359
00:14:14,480 --> 00:14:15,600
примеры,

360
00:14:15,600 --> 00:14:18,560
мы можем использовать эти данные как для обучения, так

361
00:14:18,560 --> 00:14:20,880
и для оценки,

362
00:14:20,880 --> 00:14:23,040
и как только мы обучили модель выполнять

363
00:14:23,040 --> 00:14:25,440
эту бинарную классификацию, мы можем теперь

364
00:14:25,440 --> 00:14:28,240
рассмотреть новые триплеты kb, которые

365
00:14:28,240 --> 00:14:30,959
нигде не появляются в наших данных, и спросить

366
00:14:30,959 --> 00:14:32,480
, будет ли модель  предсказывать, что

367
00:14:32,480 --> 00:14:34,639
они истинны, и, делая это, мы можем

368
00:14:34,639 --> 00:14:35,839
обнаружить

369
00:14:35,839 --> 00:14:38,000
новые отношения, которые в настоящее время не являются

370
00:14:38,000 --> 00:14:40,959
частью kb, которые могли бы быть

371
00:14:40,959 --> 00:14:45,079
кандидатами на добавление

