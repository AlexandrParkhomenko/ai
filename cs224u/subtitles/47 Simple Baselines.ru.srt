1
00:00:05,600 --> 00:00:08,080
это хорошая методологическая практика

2
00:00:08,080 --> 00:00:09,200
всякий раз, когда вы

3
00:00:09,200 --> 00:00:12,240
начинаете строить новые модели, начинать с

4
00:00:12,240 --> 00:00:14,559
оценки очень простых моделей, которые

5
00:00:14,559 --> 00:00:17,039
устанавливают базовые уровни, с которыми вы

6
00:00:17,039 --> 00:00:18,800
затем можете сравнить более сложные

7
00:00:18,800 --> 00:00:20,240
модели, которые вы собираетесь построить позже,

8
00:00:20,240 --> 00:00:21,199


9
00:00:21,199 --> 00:00:22,880
поэтому мы собираемся сделать это.  для начала

10
00:00:22,880 --> 00:00:25,119
рассмотрим три простые модели: случайный

11
00:00:25,119 --> 00:00:26,160
угадывающий,

12
00:00:26,160 --> 00:00:28,800
очень простая стратегия сопоставления фраз,

13
00:00:28,800 --> 00:00:30,560
а затем наш первый

14
00:00:30,560 --> 00:00:32,079
подход, основанный на машинном обучении, который будет простым

15
00:00:32,079 --> 00:00:35,600
классификатором набора слов.

16
00:00:36,079 --> 00:00:38,559


17
00:00:38,559 --> 00:00:41,120


18
00:00:41,120 --> 00:00:44,239
ввода, но просто подбрасывает монетку, и я

19
00:00:44,239 --> 00:00:45,840
настоятельно рекомендую вам всякий раз, когда вы

20
00:00:45,840 --> 00:00:47,920
начинаете приключение по созданию модели

21
00:00:47,920 --> 00:00:50,879
в своем финальном проекте, где бы вы ни

22
00:00:50,879 --> 00:00:53,360
начинали с оценки случайного угадывающего

23
00:00:53,360 --> 00:00:56,160
, это несложно реализовать, это может помочь

24
00:00:56,160 --> 00:00:58,800
устранить перегибы в вашей тестовой системе

25
00:00:58,800 --> 00:01:00,800
и  часто бывает очень информативно установить

26
00:01:00,800 --> 00:01:05,040
пол под тем, как выглядят хорошие оценки,

27
00:01:05,040 --> 00:01:07,439
теперь мы написали

28
00:01:07,439 --> 00:01:09,680
для вас метод оценки, он находится в модуле реликвий, и

29
00:01:09,680 --> 00:01:11,600
это просто  lled оценить,

30
00:01:11,600 --> 00:01:14,640
вы вызываете его с вашими разбиениями,

31
00:01:14,640 --> 00:01:16,560
вашим классификатором

32
00:01:16,560 --> 00:01:17,520


33
00:01:17,520 --> 00:01:18,799
и именем разбиения, которое вы хотите

34
00:01:18,799 --> 00:01:23,040
оценить, какие значения по умолчанию для dev,

35
00:01:23,520 --> 00:01:25,360
когда мы оцениваем наш случайный угадыватель, у нас

36
00:01:25,360 --> 00:01:28,400
есть некоторые интересные результаты, поэтому у нас

37
00:01:28,400 --> 00:01:30,880
есть результаты, разделенные для каждого из

38
00:01:30,880 --> 00:01:32,079
отношений

39
00:01:32,079 --> 00:01:35,280
и для  каждый из них у нас есть точность

40
00:01:35,280 --> 00:01:38,880
отзыва f оценка помните, что f = 0,5,

41
00:01:38,880 --> 00:01:40,479
что придает больше веса точности,

42
00:01:40,479 --> 00:01:42,159
чем отзыву,

43
00:01:42,159 --> 00:01:44,320
у нас есть поддержка, которая представляет собой

44
00:01:44,320 --> 00:01:48,000
количество экземпляров, фактическая метка которых верна,

45
00:01:48,000 --> 00:01:50,000
и у нас есть размер, который представляет собой просто общее

46
00:01:50,000 --> 00:01:52,799
количество экземпляров, которые

47
00:01:52,799 --> 00:01:55,840
мы находим  этот отзыв обычно составляет

48
00:01:55,840 --> 00:01:58,479
около 0,5,

49
00:01:58,479 --> 00:02:01,119
и это имеет смысл, потому что отзыв говорит

50
00:02:01,119 --> 00:02:04,159
о случаях, которые на самом деле верны,

51
00:02:04,159 --> 00:02:06,960
какую пропорцию мы предсказываем верно хорошо

52
00:02:06,960 --> 00:02:08,959
мы предсказываем правду примерно в половине случаев,

53
00:02:08,959 --> 00:02:11,920
потому что мы просто подбрасываем монету

54
00:02:11,920 --> 00:02:14,959
точность с другой стороны обычно

55
00:02:14,959 --> 00:02:16,560
довольно плохо,

56
00:02:16,560 --> 00:02:19,200
потому что точность говорит о случаях,

57
00:02:19,200 --> 00:02:21,440
когда мы предсказываем правду

58
00:02:21,440 --> 00:02:23,120
, которые в основном являются случайной выборкой,

59
00:02:23,120 --> 00:02:25,040
потому что мы просто подбрасываем монету,

60
00:02:25,040 --> 00:02:27,599
сколько ar  На самом деле

61
00:02:27,599 --> 00:02:30,560
верно относительно немного, и на самом деле вы можете

62
00:02:30,560 --> 00:02:32,000
сказать, что, глядя на соотношение

63
00:02:32,000 --> 00:02:34,640
между поддержкой и размером, соотношение

64
00:02:34,640 --> 00:02:36,800
между поддержкой и размером

65
00:02:36,800 --> 00:02:38,480
показывает, сколько случаев на

66
00:02:38,480 --> 00:02:40,000
самом деле верно,

67
00:02:40,000 --> 00:02:42,800
поэтому, когда мы подбрасываем монету,

68
00:02:42,800 --> 00:02:46,080
точность должна быть правильной.  вокруг

69
00:02:46,080 --> 00:02:48,840
соотношения между поддержкой и

70
00:02:48,840 --> 00:02:50,400
размером

71
00:02:50,400 --> 00:02:53,040
наша оценка f также в целом плохая, она

72
00:02:53,040 --> 00:02:55,120
остается близкой к точности

73
00:02:55,120 --> 00:02:57,840
по двум причинам: первая, потому

74
00:02:57,840 --> 00:03:00,480
что гармоники, среднее гармоническое остается ближе

75
00:03:00,480 --> 00:03:02,080
к меньшему числу,

76
00:03:02,080 --> 00:03:05,360
и вторая, потому что мы используем f 0,5,

77
00:03:05,360 --> 00:03:07,519
что дает больше  вес к точности,

78
00:03:07,519 --> 00:03:10,239
чем вспоминать,

79
00:03:10,239 --> 00:03:13,120
и в итоге наша макросредняя

80
00:03:13,120 --> 00:03:15,840
оценка f составляет 9,7,

81
00:03:15,840 --> 00:03:18,400
так что это число, которое нужно побить

82
00:03:18,400 --> 00:03:20,239
, это довольно низкая планка,

83
00:03:20,239 --> 00:03:24,400
но в конце концов это случайная догадка,

84
00:03:24,879 --> 00:03:26,400
хорошо, поэтому давайте посмотрим на другой подход,

85
00:03:26,400 --> 00:03:28,799
который очень прост, но умнее, чем

86
00:03:28,799 --> 00:03:30,480
случайное угадывание, и это простая

87
00:03:30,480 --> 00:03:33,040
стратегия сопоставления с образцом, и идея состоит в том

88
00:03:33,040 --> 00:03:35,599
, чтобы для каждого отношения

89
00:03:35,599 --> 00:03:37,760
пройтись по корпусу

90
00:03:37,760 --> 00:03:40,879
и найти наиболее распространенные фразы,

91
00:03:40,879 --> 00:03:43,599
которые соединяют две сущности, которые  t и в

92
00:03:43,599 --> 00:03:46,400
этом отношении наиболее распространенные срединные в

93
00:03:46,400 --> 00:03:48,080
нашей терминологии,

94
00:03:48,080 --> 00:03:50,560
так что вот некоторый код, который делает это,

95
00:03:50,560 --> 00:03:53,040
я не буду вдаваться в подробности,

96
00:03:53,040 --> 00:03:55,599
но следует отметить, что он

97
00:03:55,599 --> 00:03:56,720


98
00:03:56,720 --> 00:03:59,439
отдельно считает средние, которые соединяют субъект с

99
00:03:59,439 --> 00:04:03,040
объектом, поэтому здесь он получает все  примеры

100
00:04:03,040 --> 00:04:04,480
и

101
00:04:04,480 --> 00:04:05,760
um

102
00:04:05,760 --> 00:04:07,760
подсчитывает средние числа, он подсчитывает

103
00:04:07,760 --> 00:04:08,720
средние значения

104
00:04:08,720 --> 00:04:10,799
и делает это отдельно от

105
00:04:10,799 --> 00:04:13,599
примеров, которые связывают объект с

106
00:04:13,599 --> 00:04:14,480
субъектом,

107
00:04:14,480 --> 00:04:17,040
и сохраняет их в нескольких отдельных

108
00:04:17,040 --> 00:04:20,079
словарях um под клавишами вперед

109
00:04:20,079 --> 00:04:22,160
и назад, поэтому у нас будут

110
00:04:22,160 --> 00:04:24,639
прямые средние и обратные  средние

111
00:04:24,639 --> 00:04:26,800
хранятся отдельно, хранятся и подсчитываются

112
00:04:26,800 --> 00:04:29,800
отдельно,

113
00:04:30,320 --> 00:04:32,639
если мы запустим этот код, вот что мы получим,

114
00:04:32,639 --> 00:04:34,240
я показываю результаты, я собираюсь

115
00:04:34,240 --> 00:04:36,240
показать результаты только для трех отношений

116
00:04:36,240 --> 00:04:38,720
здесь, а не для всех 16.

117
00:04:38,720 --> 00:04:41,040
все 16 находятся в блокноте Python, если

118
00:04:41,040 --> 00:04:42,800
хотите  чтобы взглянуть, но даже из

119
00:04:42,800 --> 00:04:44,080
этого образца есть несколько вещей, которые

120
00:04:44,080 --> 00:04:46,000
бросаются в глаза в

121
00:04:46,000 --> 00:04:48,560
первую очередь некоторые из наиболее частых средних

122
00:04:48,560 --> 00:04:51,520
являются действительно естественными и интуитивно понятными,

123
00:04:51,520 --> 00:04:52,880
например,

124
00:04:52,880 --> 00:04:54,639
запятая

125
00:04:54,639 --> 00:04:57,759
в звездочке указывает на реверс  отношение производительности фильма,

126
00:04:57,759 --> 00:04:58,960


127
00:04:58,960 --> 00:05:00,639
гм, так что это будет то, где фильм

128
00:05:00,639 --> 00:05:04,320
стоит на первом месте, а актер на втором,

129
00:05:04,320 --> 00:05:06,639
я думаю, это имеет смысл, э-э,

130
00:05:06,639 --> 00:05:07,919


131
00:05:07,919 --> 00:05:11,840
запятая в звездных войнах с Марком Хэмиллом в главной роли, точно так

132
00:05:12,000 --> 00:05:14,960
же запятая сын

133
00:05:14,960 --> 00:05:18,400
указывает на отношения передового родителя, так что

134
00:05:18,400 --> 00:05:21,120
это будет то, где  сын идет

135
00:05:21,120 --> 00:05:23,600
первым ребенок идет первым, а

136
00:05:23,600 --> 00:05:26,479
родитель идет вторым,

137
00:05:26,479 --> 00:05:28,240
поэтому они чрезвычайно интуитивно понятны, и

138
00:05:28,240 --> 00:05:30,800
их обнадеживает то, что они находятся

139
00:05:30,800 --> 00:05:33,840
в верхней части списка наиболее распространенных

140
00:05:33,840 --> 00:05:35,680
средних

141
00:05:35,680 --> 00:05:38,560


142
00:05:38,560 --> 00:05:41,840
слов. еще одно наблюдение заключается в том, что знаки препинания и стоп-слова, такие как запятая

143
00:05:41,840 --> 00:05:43,120
и и

144
00:05:43,120 --> 00:05:45,759
, чрезвычайно распространены в

145
00:05:45,759 --> 00:05:46,720
отличие от

146
00:05:46,720 --> 00:05:48,639
некоторых  другие приложения nlp,

147
00:05:48,639 --> 00:05:50,720
наверное, плохая идея выбрасывать их,

148
00:05:50,720 --> 00:05:54,800
они несут много полезной информации,

149
00:05:54,800 --> 00:05:56,720
с другой стороны, пунктуация и стоп-

150
00:05:56,720 --> 00:05:59,600
слова, как правило, очень неоднозначны,

151
00:05:59,600 --> 00:06:01,440
например, если вы просмотрите весь

152
00:06:01,440 --> 00:06:03,600
диапазон всех 16 отношений, вы увидите,

153
00:06:03,600 --> 00:06:05,520
что  медвежья запятая

154
00:06:05,520 --> 00:06:08,080
является вероятной серединой почти для каждого

155
00:06:08,080 --> 00:06:10,800
отношения по крайней мере в одном направлении,

156
00:06:10,800 --> 00:06:13,120
так что запятая очень часто указывает на

157
00:06:13,120 --> 00:06:15,600
отношение, но это не так.  действительно неоднозначный

158
00:06:15,600 --> 00:06:18,160
индикатор

159
00:06:18,479 --> 00:06:20,000
Хорошо, теперь, когда мы определили наиболее

160
00:06:20,000 --> 00:06:22,319
распространенные середины для каждого отношения,

161
00:06:22,319 --> 00:06:24,560
легко построить классификатор

162
00:06:24,560 --> 00:06:26,319
на основе этой информации классификатор,

163
00:06:26,319 --> 00:06:28,080
который предсказывает истину

164
00:06:28,080 --> 00:06:30,160
для тройки кандидата kb

165
00:06:30,160 --> 00:06:32,240
только в том случае, если две сущности в

166
00:06:32,240 --> 00:06:35,120
тройке появляются в корпусе  связаны

167
00:06:35,120 --> 00:06:36,560
одной из фраз, которые мы только что

168
00:06:36,560 --> 00:06:37,759
обнаружили,

169
00:06:37,759 --> 00:06:39,360
я не показываю код для этого здесь, но

170
00:06:39,360 --> 00:06:41,360
он находится в блокноте Python для этого

171
00:06:41,360 --> 00:06:43,280
модуля,

172
00:06:43,280 --> 00:06:45,360
и когда мы оцениваем этот подход, мы

173
00:06:45,360 --> 00:06:48,240
видим некоторые действительно интересные результаты.

174
00:06:48,240 --> 00:06:51,680
первый отзыв намного хуже по всем

175
00:06:51,680 --> 00:06:53,919
направлениям и  это имеет смысл, потому что мы

176
00:06:53,919 --> 00:06:57,360
больше не просто угадываем случайным образом до

177
00:06:57,360 --> 00:07:00,319
того, как сказали «правда» в половине случаев,

178
00:07:00,319 --> 00:07:01,360
теперь мы будем намного более

179
00:07:01,360 --> 00:07:04,479
избирательны в том, что мы говорим «верно»,

180
00:07:04,479 --> 00:07:06,319
но точность

181
00:07:06,319 --> 00:07:09,680
и показатель f значительно улучшились

182
00:07:09,680 --> 00:07:11,360
для некоторых отношений,

183
00:07:11,360 --> 00:07:14,639
особенно для  а присоединяется к автору,

184
00:07:14,639 --> 00:07:18,639
имеет брата, сестру и супруга

185
00:07:18,639 --> 00:07:19,759
, а также есть много других

186
00:07:19,759 --> 00:07:22,400
отношений, где точность и оценка f

187
00:07:22,400 --> 00:07:24,479
все еще довольно плохие,

188
00:07:24,479 --> 00:07:26,720
включая это  Это один из жанров, в котором мы получаем

189
00:07:26,720 --> 00:07:28,639
сплошные нули по всем направлениям. Я не

190
00:07:28,639 --> 00:07:31,120
совсем уверен, что там произошло,

191
00:07:31,120 --> 00:07:33,440
но это указывает на то, что,

192
00:07:33,440 --> 00:07:35,440
хотя в некоторых местах ситуация значительно улучшилась,

193
00:07:35,440 --> 00:07:36,880


194
00:07:36,880 --> 00:07:39,919
в других она все еще довольно плохая,

195
00:07:39,919 --> 00:07:42,240
и наша средняя макро-оценка f

196
00:07:42,240 --> 00:07:44,319
улучшилась.  только скромно, поэтому он улучшился

197
00:07:44,319 --> 00:07:48,319
с 9,7 процента до 11,1 процента, мы

198
00:07:48,319 --> 00:07:50,319
движемся в правильном направлении, но вы

199
00:07:50,319 --> 00:07:51,440
должны сказать, что это все еще

200
00:07:51,440 --> 00:07:53,360
не впечатляет,

201
00:07:53,360 --> 00:07:55,599
чтобы добиться значительных успехов, которые нам

202
00:07:55,599 --> 00:07:59,680
понадобятся для применения машинного обучения,

203
00:07:59,680 --> 00:08:01,280
так что давайте начнем с этого  мы собираемся

204
00:08:01,280 --> 00:08:03,520
создать очень простой классификатор,

205
00:08:03,520 --> 00:08:05,599
используя подход, который должен быть вам знаком

206
00:08:05,599 --> 00:08:08,240
из нашего анализа настроений на прошлой

207
00:08:08,240 --> 00:08:09,599
неделе,

208
00:08:09,599 --> 00:08:11,360
и мы собираемся начать это с

209
00:08:11,360 --> 00:08:13,759
определения очень простой функциональной функции набора слов,

210
00:08:13,759 --> 00:08:15,199


211
00:08:15,199 --> 00:08:17,919
так что вот код для этого

212
00:08:17,919 --> 00:08:20,000
и  позвольте мне кратко рассказать вам,

213
00:08:20,000 --> 00:08:22,000
что мы собираемся сделать, это получить

214
00:08:22,000 --> 00:08:25,680
функции для тройки kb, которая является kbt,

215
00:08:25,680 --> 00:08:26,720
здесь

216
00:08:26,720 --> 00:08:28,800
мы собираемся найти все примеры корпуса,

217
00:08:28,800 --> 00:08:30,080


218
00:08:30,080 --> 00:08:32,799
содержащие две сущности в тройке kb.

219
00:08:32,799 --> 00:08:35,120
Назовите субъект и объект и

220
00:08:35,120 --> 00:08:37,200
обратите внимание, что мы делаем это в обоих направлениях

221
00:08:37,200 --> 00:08:39,839
субъект, субъект и объект, а затем также

222
00:08:39,839 --> 00:08:42,320
объект и субъект

223
00:08:42,320 --> 00:08:45,920
для каждого примера, мы смотрим на середину,

224
00:08:45,920 --> 00:08:47,839
мы разбиваем его на слова,

225
00:08:47,839 --> 00:08:51,440
а затем подсчитываем все слова,

226
00:08:51,440 --> 00:08:54,080
поэтому соедините вещи, чтобы  обратите внимание, что одно из них заключается в

227
00:08:54,080 --> 00:08:56,720
том, что представление признаков для одной

228
00:08:56,720 --> 00:08:58,160
тройки kb

229
00:08:58,160 --> 00:09:02,080
может быть получено из многих примеров корпуса,

230
00:09:02,080 --> 00:09:03,440
и это то, что я пытался подчеркнуть

231
00:09:03,440 --> 00:09:06,080
в прошлый раз

232
00:09:06,080 --> 00:09:09,680
, когда мы используем корпус для создания

233
00:09:09,680 --> 00:09:13,200
признаков для тройки kb-кандидатов

234
00:09:13,200 --> 00:09:15,120
и  Роль корпуса

235
00:09:15,120 --> 00:09:17,680
состоит в том, чтобы обеспечить представление функций,

236
00:09:17,680 --> 00:09:19,760
а представление функций для

237
00:09:19,760 --> 00:09:22,880
тройки kb будет основано на всех

238
00:09:22,880 --> 00:09:24,720
примерах в корпусе, которые содержат

239
00:09:24,720 --> 00:09:26,800
эти два объекта.

240
00:09:26,800 --> 00:09:28,399


241
00:09:28,399 --> 00:09:30,880


242
00:09:30,880 --> 00:09:32,959
вызовите прямые примеры, в

243
00:09:32,959 --> 00:09:35,279
которых сначала есть подлежащее, а затем объект,

244
00:09:35,279 --> 00:09:37,519
и обратные примеры, в которых есть дополнение,

245
00:09:37,519 --> 00:09:39,519
а затем подлежащее, мы смешиваем их все

246
00:09:39,519 --> 00:09:40,560


247
00:09:40,560 --> 00:09:43,360
вместе слова, которые происходят из середины o  f

248
00:09:43,360 --> 00:09:46,000
примеры в любом направлении

249
00:09:46,000 --> 00:09:49,200
объединяются в один счетчик функций,

250
00:09:49,200 --> 00:09:50,800
и у вас могут возникнуть сомнения относительно того

251
00:09:50,800 --> 00:09:54,320
, действительно ли это самый разумный поступок,

252
00:09:55,680 --> 00:09:57,040
поэтому давайте посмотрим, как это

253
00:09:57,040 --> 00:09:58,959
выглядит в действии,

254
00:09:58,959 --> 00:10:02,240
сначала давайте распечатаем самую первую

255
00:10:02,240 --> 00:10:04,480
тройку kb в rkb

256
00:10:04,480 --> 00:10:06,079
мы на самом деле смотрели на это в прошлый раз

257
00:10:06,079 --> 00:10:09,120
, это тройка kb, которая говорит,

258
00:10:09,120 --> 00:10:11,120
что существует связь между

259
00:10:11,120 --> 00:10:14,240
кирпичными полями и центральной железнодорожной станцией Куала-Лумпура,

260
00:10:14,240 --> 00:10:16,839


261
00:10:16,839 --> 00:10:20,079
а теперь давайте посмотрим на первый

262
00:10:20,079 --> 00:10:21,279
пример,

263
00:10:21,279 --> 00:10:22,640
содержащий эти два объекта, так что я

264
00:10:22,640 --> 00:10:23,760
просто собираюсь найти их в

265
00:10:23,760 --> 00:10:26,399
Субъект и объект в прямом направлении Я

266
00:10:26,399 --> 00:10:28,800
получаю все примеры. Я смотрю на

267
00:10:28,800 --> 00:10:30,399
первый и позвольте мне просто распечатать

268
00:10:30,399 --> 00:10:32,480
середину.

269
00:10:32,480 --> 00:10:34,000


270
00:10:34,000 --> 00:10:35,600


271
00:10:35,600 --> 00:10:36,720


272
00:10:36,720 --> 00:10:39,040
кирпичные поля, это было всего в

273
00:10:39,040 --> 00:10:41,200
10 минутах ходьбы от центрального железнодорожного вокзала Куала-Лумпура,

274
00:10:41,200 --> 00:10:43,040


275
00:10:43,040 --> 00:10:45,360
и, возможно, там было больше, а

276
00:10:45,360 --> 00:10:47,200


277
00:10:47,200 --> 00:10:50,880
теперь давайте запустим наш анализатор на этой

278
00:10:50,880 --> 00:10:53,920
тройке kb и посмотрим, какие функции мы получили

279
00:10:53,920 --> 00:10:56,560
итак, мы получаем счетчик, который содержит, что это

280
00:10:56,560 --> 00:11:00,640
была всего лишь быстрая 10-минутная прогулка до,

281
00:11:00,640 --> 00:11:02,800
так что похоже, что он подсчитал

282
00:11:02,800 --> 00:11:04,880
слова в этой середине, что именно то, что

283
00:11:04,880 --> 00:11:06,640
мы ожидали,

284
00:11:06,640 --> 00:11:08,000
если бы, но если вы посмотрите внимательно, здесь есть что-

285
00:11:08,000 --> 00:11:09,760
то неожиданное, потому что

286
00:11:09,760 --> 00:11:12,800
слово  два имеет счет два,

287
00:11:12,800 --> 00:11:15,760
хотя он появляется только один раз в этой

288
00:11:15,760 --> 00:11:18,240
середине, а также слово the имеет

289
00:11:18,240 --> 00:11:20,240
счет 1, хотя он вообще не появлялся в

290
00:11:20,240 --> 00:11:22,800
этой середине,

291
00:11:22,800 --> 00:11:24,800
поэтому откуда они взялись,

292
00:11:24,800 --> 00:11:27,120
хорошо помните, что футуризатор считает

293
00:11:27,120 --> 00:11:30,320
слова  из середины всех примеров,

294
00:11:30,320 --> 00:11:32,480
содержащих эти объекты в любом

295
00:11:32,480 --> 00:11:33,839
направлении,

296
00:11:33,839 --> 00:11:35,519
и оказывается, что корпус

297
00:11:35,519 --> 00:11:37,760
содержит еще один пример, содержащий

298
00:11:37,760 --> 00:11:40,079
эти два объекта, и в этом другом

299
00:11:40,079 --> 00:11:41,760
примере

300
00:11:41,760 --> 00:11:43,680
есть только один другой пример, но в этом

301
00:11:43,680 --> 00:11:47,040
другом примере есть середина к,

302
00:11:47,040 --> 00:11:49,360
и вот где они учитываются  пришел,

303
00:11:49,360 --> 00:11:50,399


304
00:11:50,399 --> 00:11:54,160
так что все хорошо, он поступил правильно,

305
00:11:55,040 --> 00:11:57,120
хорошо, у нас есть простой набор слов,

306
00:11:57,120 --> 00:11:59,360
теперь нам нужен способ обучать

307
00:11:59,360 --> 00:12:00,320
модели

308
00:12:00,320 --> 00:12:03,440
делать прогнозы и

309
00:12:03,440 --> 00:12:06,959
оценивать результаты.  модуль relics содержит

310
00:12:06,959 --> 00:12:09,040
функции для каждой из них, поэтому я

311
00:12:09,040 --> 00:12:11,040
просто хочу дать вам краткий обзор

312
00:12:11,040 --> 00:12:13,680
того, что это за функции,

313
00:12:13,680 --> 00:12:15,680
но вы определенно захотите

314
00:12:15,680 --> 00:12:17,839
прочитать код для этого, чтобы вы

315
00:12:17,839 --> 00:12:19,839
лучше знали,

316
00:12:19,839 --> 00:12:21,519
как это может быть.  используется, и большая часть этого

317
00:12:21,519 --> 00:12:24,800
кода появляется в файле с именем rel x rel

318
00:12:24,800 --> 00:12:28,000
underscore x dot pi,

319
00:12:28,000 --> 00:12:30,160
поэтому мы начнем с функции, называемой

320
00:12:30,160 --> 00:12:32,560
модели обучения,

321
00:12:32,560 --> 00:12:35,120
которая принимает в качестве аргументов

322
00:12:35,120 --> 00:12:38,079
словарь данных разбивает список характеристик, и

323
00:12:38,079 --> 00:12:40,560
здесь у нас есть список, состоящий  всего лишь

324
00:12:40,560 --> 00:12:42,959
наш простой набор слов,

325
00:12:42,959 --> 00:12:45,600
характеризующий имя разделения, на котором следует обучать,

326
00:12:45,600 --> 00:12:47,920
которое по умолчанию обучается,

327
00:12:47,920 --> 00:12:51,519
и фабрику моделей, которая представляет собой функцию

328
00:12:51,519 --> 00:12:55,200
,

329
00:12:57,120 --> 00:12:59,760
возвращающую классификатор,

330
00:12:59,760 --> 00:13:02,160
и,

331
00:13:02,160 --> 00:13:04,639
извините, функцию, которая инициализирует классификатор sk,

332
00:13:04,639 --> 00:13:06,959
и по умолчанию это

333
00:13:06,959 --> 00:13:09,279
логистическая регрессия.  классификатор, как показано

334
00:13:09,279 --> 00:13:11,360
здесь, но вы можете легко заменить

335
00:13:11,360 --> 00:13:14,480
его каким-либо другим классификатором обучения sksk,

336
00:13:14,480 --> 00:13:16,560


337
00:13:16,560 --> 00:13:17,920
он возвращает

338
00:13:17,920 --> 00:13:20,320
эту вещь, называемую результатом поезда, который представляет

339
00:13:20,320 --> 00:13:23,760
собой словарь, содержащий функции

340
00:13:23,760 --> 00:13:25,600
векторизатора, который использовался.  d для создания

341
00:13:25,600 --> 00:13:28,320
обучающей матрицы и, что наиболее важно,

342
00:13:28,320 --> 00:13:31,040
словаря, содержащего обученные модели по

343
00:13:31,040 --> 00:13:33,360
одной на отношение, так что это словарь,

344
00:13:33,360 --> 00:13:38,240
который сопоставляет имена отношений с моделями,

345
00:13:38,240 --> 00:13:40,639
поэтому затем идут модели обучения.

346
00:13:40,639 --> 00:13:43,440
предсказать, что

347
00:13:43,440 --> 00:13:45,120
это функция, которая принимает в качестве

348
00:13:45,120 --> 00:13:47,600
аргументов словарь данных,

349
00:13:47,600 --> 00:13:51,199
вывод обученных моделей, которые тренируют

350
00:13:51,199 --> 00:13:53,440
результат,

351
00:13:53,440 --> 00:13:54,880
и имя разделения, по которому можно

352
00:13:54,880 --> 00:13:56,720
делать прогнозы, и по умолчанию это

353
00:13:56,720 --> 00:13:58,000
dev,

354
00:13:58,000 --> 00:14:00,639
и он возвращает два параллельных словаря,

355
00:14:00,639 --> 00:14:02,800
один содержит прогнозы, сгруппированные по

356
00:14:02,800 --> 00:14:03,839
отношению,

357
00:14:03,839 --> 00:14:05,600
а другой содержит истинные метки,

358
00:14:05,600 --> 00:14:08,560
сгруппированные по отношению,

359
00:14:09,519 --> 00:14:12,160
и наш третий  строительным блоком является оценка

360
00:14:12,160 --> 00:14:14,079
прогнозов, так что это функция, которая

361
00:14:14,079 --> 00:14:17,040
принимает в качестве аргументов два параллельных

362
00:14:17,040 --> 00:14:19,360
словаря прогнозов и истинных

363
00:14:19,360 --> 00:14:22,480
меток, созданных прогнозированием,

364
00:14:22,480 --> 00:14:24,959
и печатает метрики оценки для

365
00:14:24,959 --> 00:14:28,800
каждого отношения, как мы видели ранее,

366
00:14:28,800 --> 00:14:30,560
прежде чем мы остановимся на этих результатах, я

367
00:14:30,560 --> 00:14:33,519
хочу показать один  больше функции,

368
00:14:33,519 --> 00:14:37,279
которая называется экспериментом,

369
00:14:37,279 --> 00:14:40,000
а эксперимент просто связывает

370
00:14:40,000 --> 00:14:41,600
вместе три  функции, которые я только что показал

371
00:14:41,600 --> 00:14:43,600
вам, изменились вместе с

372
00:14:43,600 --> 00:14:46,240
прогнозированием обучения и оценкой,

373
00:14:46,240 --> 00:14:48,000
так что это очень удобно

374
00:14:48,000 --> 00:14:50,240
для проведения сквозных экспериментов.

375
00:14:50,240 --> 00:14:52,880
Я не показал здесь все параметры,

376
00:14:52,880 --> 00:14:54,240
но если вы посмотрите на исходный код,

377
00:14:54,240 --> 00:14:55,839
вы увидите, что это на самом деле  принимает

378
00:14:55,839 --> 00:14:57,760
множество необязательных параметров, и эти

379
00:14:57,760 --> 00:15:00,320
параметры позволяют вам указать

380
00:15:00,320 --> 00:15:02,000
все, что касается запуска

381
00:15:02,000 --> 00:15:03,680
эксперимента, позволяют вам указать свои

382
00:15:03,680 --> 00:15:06,560
характеристики, вашу фабрику моделей, которая

383
00:15:06,560 --> 00:15:10,399
разделяется для обучения и тестирования, и многое другое,

384
00:15:10,399 --> 00:15:12,880
например, ранее я упоминал, что

385
00:15:12,880 --> 00:15:15,519
крошечное разделение действительно полезно для  проведение

386
00:15:15,519 --> 00:15:18,320
быстрых экспериментов для устранения перегибов,

387
00:15:18,320 --> 00:15:20,720
если вы хотите сделать это, очень легко

388
00:15:20,720 --> 00:15:23,040
использовать функцию эксперимента, просто

389
00:15:23,040 --> 00:15:25,040
установив тренировочный и тестовый

390
00:15:25,040 --> 00:15:27,839
интервалы на крошечные, чтобы провести очень быстрый

391
00:15:27,839 --> 00:15:30,480
эксперимент, а

392
00:15:31,680 --> 00:15:34,079
теперь вот результаты оценки

393
00:15:34,079 --> 00:15:36,959
нашего простого пакета  слова

394
00:15:36,959 --> 00:15:39,040
классификатор логистической регрессии, и давайте

395
00:15:39,040 --> 00:15:40,399
посмотрим поближе, потому

396
00:15:40,399 --> 00:15:42,959
что это довольно ошеломляюще,

397
00:15:42,959 --> 00:15:44,720
хотя это почти самый

398
00:15:44,720 --> 00:15:47,120
простой из возможных классификаторов, которые

399
00:15:47,120 --> 00:15:49,680
мы  добились огромных успехов по сравнению с

400
00:15:49,680 --> 00:15:51,440
подходом сопоставления фраз.

401
00:15:51,440 --> 00:15:53,279
Первое, что бросается в глаза, это то, что

402
00:15:53,279 --> 00:15:56,079
наша макросредняя оценка f подскочила

403
00:15:56,079 --> 00:16:00,399
с 11,1 до 56,7,

404
00:16:00,399 --> 00:16:03,199
и мы видим большой прирост точности

405
00:16:03,199 --> 00:16:06,399
почти для каждого отношения

406
00:16:06,399 --> 00:16:11,120
и, соответственно, большой прирост f-показателя,

407
00:16:11,120 --> 00:16:12,720
с другой стороны.  есть еще

408
00:16:12,720 --> 00:16:15,279
много возможностей для улучшения, я имею в виду, что это

409
00:16:15,279 --> 00:16:16,240


410
00:16:16,240 --> 00:16:18,320
намного более впечатляюще, чем то, где мы

411
00:16:18,320 --> 00:16:21,120
были раньше, но мы очень далеки от совершенства, у нас есть большой

412
00:16:21,120 --> 00:16:24,399
запас и

413
00:16:24,399 --> 00:16:28,759
возможность продолжать совершенствоваться.

